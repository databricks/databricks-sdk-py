import React, { useState } from 'react';
import Button from '@mui/material/Button';
import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import ListItemIcon from '@mui/material/ListItemIcon';
import ListItemText from '@mui/material/ListItemText';
import DownloadIcon from '@mui/icons-material/Download';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import {useLocation} from '@docusaurus/router';
import styles from './StackqlDeployDropdown.module.css';

/**
 * Collects all DOM elements between a heading and the next <h2>.
 */
function getElementsBetweenHeadings(heading) {
  const elements = [];
  let el = heading.nextElementSibling;
  while (el && el.tagName !== 'H2') {
    elements.push(el);
    el = el.nextElementSibling;
  }
  return elements;
}

/**
 * Extracts text from a <code> element, preserving newlines.
 * prism-react-renderer wraps each line in a child element (div or span),
 * and textContent concatenates them without newlines, so we join manually.
 */
function getCodeText(codeEl) {
  if (codeEl.children.length > 0) {
    return Array.from(codeEl.children)
      .map(line => line.textContent.replace(/\n$/, ''))
      .join('\n');
  }
  return codeEl.textContent;
}

/**
 * Extracts the text content of a code block from within a set of elements.
 * If preferredTab is provided, looks for a tab with that label first.
 */
function extractCodeFromElements(elements, preferredTab) {
  if (preferredTab) {
    for (const el of elements) {
      const tabs = el.querySelectorAll('[role="tab"]');
      const panels = el.querySelectorAll('[role="tabpanel"]');
      for (let i = 0; i < tabs.length; i++) {
        const tabLabel = tabs[i].textContent.trim().toLowerCase();
        if (tabLabel === preferredTab.toLowerCase() && panels[i]) {
          const codeEl = panels[i].querySelector('pre code');
          if (codeEl) return getCodeText(codeEl);
        }
      }
    }
  }
  // Fallback: first code block in the section
  for (const el of elements) {
    const codeEl = el.querySelector('pre code');
    if (codeEl) return getCodeText(codeEl);
  }
  return null;
}

/**
 * Scans the rendered page DOM for SQL example sections and extracts
 * code blocks to build a context-aware stackql-deploy template.
 *
 * Section heading IDs generated by Docusaurus:
 *   ## `SELECT` examples  → #select-examples
 *   ## `INSERT` examples  → #insert-examples
 *   ## `UPDATE` examples  → #update-examples
 *   ## `REPLACE` examples → #replace-examples
 *   ## `DELETE` examples  → #delete-examples
 *   ## Lifecycle Methods   → #lifecycle-methods
 */
function extractTemplateFromPage() {
  const sections = {};

  // --- SELECT (prefer "get" tab for a single-resource check) ---
  const selectH2 = document.getElementById('select-examples');
  if (selectH2) {
    const els = getElementsBetweenHeadings(selectH2);
    sections.select = extractCodeFromElements(els, 'get')
                   || extractCodeFromElements(els);
  }

  // --- INSERT (prefer "create" tab — skip "Manifest" yaml tab) ---
  const insertH2 = document.getElementById('insert-examples');
  if (insertH2) {
    const els = getElementsBetweenHeadings(insertH2);
    sections.insert = extractCodeFromElements(els, 'create')
                   || extractCodeFromElements(els);
  }

  // --- UPDATE ---
  const updateH2 = document.getElementById('update-examples');
  if (updateH2) {
    const els = getElementsBetweenHeadings(updateH2);
    sections.update = extractCodeFromElements(els);
  }

  // --- REPLACE ---
  const replaceH2 = document.getElementById('replace-examples');
  if (replaceH2) {
    const els = getElementsBetweenHeadings(replaceH2);
    sections.replace = extractCodeFromElements(els);
  }

  // --- DELETE (standalone section) ---
  const deleteH2 = document.getElementById('delete-examples');
  if (deleteH2) {
    const els = getElementsBetweenHeadings(deleteH2);
    sections.delete = extractCodeFromElements(els);
  }

  // --- Lifecycle Methods: look for a "delete" tab if no standalone DELETE ---
  if (!sections.delete) {
    const lifecycleH2 = document.getElementById('lifecycle-methods');
    if (lifecycleH2) {
      const els = getElementsBetweenHeadings(lifecycleH2);
      sections.delete = extractCodeFromElements(els, 'delete');
    }
  }

  return sections;
}

/**
 * Parses a SELECT SQL string into its components:
 *   fields  - column names from the SELECT list
 *   table   - fully-qualified table reference after FROM
 *   where   - the raw WHERE clause (conditions only, no leading WHERE)
 */
function parseSelectSQL(sql) {
  const selectFromMatch = sql.match(/SELECT\s+([\s\S]+?)\s+FROM\s+/i);
  const fromMatch = sql.match(/FROM\s+(\S+)/i);
  const whereMatch = sql.match(/WHERE\s+([\s\S]+?)(?:\s*;\s*$|$)/i);

  const fields = selectFromMatch
    ? selectFromMatch[1]
        .split(',')
        .map(f => f.trim())
        .filter(f => f && f !== '*')
    : [];

  const table = fromMatch ? fromMatch[1] : '';
  const where = whereMatch ? whereMatch[1].trim().replace(/;\s*$/, '').trim() : '';

  return { fields, table, where };
}

/**
 * Builds /*+ exists */ - a simplified count query using only the
 * original WHERE params (required parameters from the page).
 */
function buildExistsQuery(parsed) {
  let sql = `SELECT count(*) as count\nFROM ${parsed.table}`;
  if (parsed.where) {
    sql += `\nWHERE ${parsed.where}`;
  }
  sql += '\n;';
  return sql;
}

/**
 * Builds /*+ statecheck */ - a count query where SELECT fields become
 * equality checks in the WHERE clause, followed by the original WHERE params.
 */
function buildStatecheckQuery(parsed) {
  const fieldConditions = parsed.fields
    .map(f => `${f} = {{ ${f} }}`)
    .join(' AND\n');

  let whereClause = fieldConditions;
  if (parsed.where) {
    if (whereClause) {
      whereClause += ' AND\n';
    }
    whereClause += parsed.where;
  }

  let sql = `SELECT count(*) as count\nFROM ${parsed.table}`;
  if (whereClause) {
    sql += `\nWHERE \n${whereClause}`;
  }
  sql += '\n;';
  return sql;
}

/**
 * Builds the stackql-deploy IQL template from extracted sections.
 * Only includes anchors for operations that actually exist on the page.
 */
function buildTemplate(sections) {
  const parts = [];
  let parsed = null;

  if (sections.select) {
    parsed = parseSelectSQL(sections.select);
    parts.push(`/*+ exists */\n${buildExistsQuery(parsed)}`);
  }

  if (sections.insert) {
    parts.push(`/*+ createorupdate */\n${sections.insert}`);
  } else if (sections.update) {
    parts.push(`/*+ createorupdate */\n${sections.update}`);
  } else if (sections.replace) {
    parts.push(`/*+ createorupdate */\n${sections.replace}`);
  }

  if (parsed) {
    parts.push(`/*+ statecheck, retries=5, retry_delay=10 */\n${buildStatecheckQuery(parsed)}`);
    parts.push(`/*+ exports */\n${sections.select}`);
  }

  if (sections.delete) {
    parts.push(`/*+ delete */\n${sections.delete}`);
  }

  return parts.join('\n\n');
}

function getResourceName(pathname) {
  const match = pathname.match(/\/services\/[^/]+\/([^/]+)/);
  return match ? match[1] : null;
}

export default function StackqlDeployDropdown() {
  const [anchorEl, setAnchorEl] = useState(null);
  const [copied, setCopied] = useState(false);
  const open = Boolean(anchorEl);
  const location = useLocation();

  const resourceName = getResourceName(location.pathname);

  // Only render on resource pages (URL: /services/{service}/{resource})
  if (!resourceName) return null;

  const filename = `${resourceName}.iql`;

  function getTemplate() {
    const sections = extractTemplateFromPage();
    return buildTemplate(sections);
  }

  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleDownload = () => {
    const template = getTemplate();
    if (!template) {
      handleClose();
      return;
    }
    const blob = new Blob([template], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    handleClose();
  };

  const handleCopy = async () => {
    const template = getTemplate();
    if (!template) {
      handleClose();
      return;
    }
    try {
      await navigator.clipboard.writeText(template);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch {
      const textarea = document.createElement('textarea');
      textarea.value = template;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
    handleClose();
  };

  return (
    <div className={styles.dropdownWrapper}>
      <Button
        variant="outlined"
        size="small"
        endIcon={<KeyboardArrowDownIcon />}
        onClick={handleClick}
        sx={{
          textTransform: 'none',
          fontFamily: 'var(--ifm-font-family-base)',
          fontWeight: 600,
          fontSize: '0.75rem',
          borderColor: 'var(--ifm-color-primary)',
          color: 'var(--ifm-color-primary)',
          '&:hover': {
            borderColor: 'var(--ifm-color-primary)',
            backgroundColor: 'rgba(0, 65, 101, 0.04)',
          },
        }}
      >
        stackql-deploy Template
      </Button>
      <Menu
        anchorEl={anchorEl}
        open={open}
        onClose={handleClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        transformOrigin={{ vertical: 'top', horizontal: 'right' }}
        sx={{
          '& .MuiPaper-root': {
            fontFamily: 'var(--ifm-font-family-base)',
            minWidth: 180,
          },
        }}
      >
        <MenuItem onClick={handleDownload}>
          <ListItemIcon>
            <DownloadIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText
            primaryTypographyProps={{
              fontSize: '0.85rem',
              fontFamily: 'var(--ifm-font-family-base)',
            }}
          >
            Download
          </ListItemText>
        </MenuItem>
        <MenuItem onClick={handleCopy}>
          <ListItemIcon>
            <ContentCopyIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText
            primaryTypographyProps={{
              fontSize: '0.85rem',
              fontFamily: 'var(--ifm-font-family-base)',
            }}
          >
            {copied ? 'Copied!' : 'Copy'}
          </ListItemText>
        </MenuItem>
      </Menu>
    </div>
  );
}
