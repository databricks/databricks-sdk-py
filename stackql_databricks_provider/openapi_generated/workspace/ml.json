{
  "openapi": "3.0.0",
  "info": {
    "title": "Databricks Ml API (workspace)",
    "description": "OpenAPI specification for the Databricks ml service (workspace-level APIs), generated from the Databricks Python SDK.",
    "version": "0.1.0"
  },
  "servers": [
    {
      "url": "https://{workspace}.cloud.databricks.com",
      "description": "Databricks workspace",
      "variables": {
        "workspace": {
          "default": "your-workspace",
          "description": "Your Databricks workspace name"
        }
      }
    }
  ],
  "paths": {
    "/api/2.0/mlflow/experiments/create": {
      "post": {
        "operationId": "experiments_create_experiment",
        "summary": "Creates an experiment with a name. Returns the ID of the newly created experiment. Validates that",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Creates an experiment with a name. Returns the ID of the newly created experiment. Validates that\nanother experiment with the same name does not already exist and fails if another experiment with the\nsame name already exists.\n\nThrows `RESOURCE_ALREADY_EXISTS` if an experiment with the given name exists.\n\n:param name: str\n  Experiment name.\n:param artifact_location: str (optional)\n  Location where all artifacts for the experiment are stored. If not provided, the remote server will\n  select an appropriate default.\n:param tags: List[:class:`ExperimentTag`] (optional)\n  A collection of tags to set on the experiment. Maximum tag size and number of tags per request\n  depends on the storage backend. All storage backends are guaranteed to support tag keys up to 250\n  bytes in size and tag values up to 5000 bytes in size. All storage backends are also guaranteed to\n  support up to 20 tags per request.\n\n:returns: :class:`CreateExperimentResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Experiment name."
                  },
                  "artifact_location": {
                    "type": "string",
                    "description": "Location where all artifacts for the experiment are stored. If not provided, the remote server will select an appropriate default."
                  },
                  "tags": {
                    "type": "string",
                    "description": "A collection of tags to set on the experiment. Maximum tag size and number of tags per request depends on the storage backend. All storage backends are guaranteed to support tag keys up to 250 bytes in size and tag values up to 5000 bytes in size. All storage backends are also guaranteed to support up to 20 tags per request."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateExperimentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models": {
      "post": {
        "operationId": "experiments_create_logged_model",
        "summary": "Create a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Create a logged model.\n\n:param experiment_id: str\n  The ID of the experiment that owns the model.\n:param model_type: str (optional)\n  The type of the model, such as ``\"Agent\"``, ``\"Classifier\"``, ``\"LLM\"``.\n:param name: str (optional)\n  The name of the model (optional). If not specified one will be generated.\n:param params: List[:class:`LoggedModelParameter`] (optional)\n  Parameters attached to the model.\n:param source_run_id: str (optional)\n  The ID of the run that created the model.\n:param tags: List[:class:`LoggedModelTag`] (optional)\n  Tags attached to the model.\n\n:returns: :class:`CreateLoggedModelResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "The ID of the experiment that owns the model."
                  },
                  "model_type": {
                    "type": "string",
                    "description": "The type of the model, such as ``\"Agent\"``, ``\"Classifier\"``, ``\"LLM\"``."
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the model (optional). If not specified one will be generated."
                  },
                  "params": {
                    "type": "string",
                    "description": "Parameters attached to the model."
                  },
                  "source_run_id": {
                    "type": "string",
                    "description": "The ID of the run that created the model."
                  },
                  "tags": {
                    "type": "string",
                    "description": "Tags attached to the model."
                  }
                },
                "required": [
                  "experiment_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateLoggedModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/create": {
      "post": {
        "operationId": "experiments_create_run",
        "summary": "Creates a new run within an experiment. A run is usually a single execution of a machine learning or",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Creates a new run within an experiment. A run is usually a single execution of a machine learning or\ndata ETL pipeline. MLflow uses runs to track the `mlflowParam`, `mlflowMetric`, and `mlflowRunTag`\nassociated with a single execution.\n\n:param experiment_id: str (optional)\n  ID of the associated experiment.\n:param run_name: str (optional)\n  The name of the run.\n:param start_time: int (optional)\n  Unix timestamp in milliseconds of when the run started.\n:param tags: List[:class:`RunTag`] (optional)\n  Additional metadata for run.\n:param user_id: str (optional)\n  ID of the user executing the run. This field is deprecated as of MLflow 1.0, and will be removed in\n  a future MLflow release. Use 'mlflow.user' tag instead.\n\n:returns: :class:`CreateRunResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "ID of the associated experiment."
                  },
                  "run_name": {
                    "type": "string",
                    "description": "The name of the run."
                  },
                  "start_time": {
                    "type": "string",
                    "description": "Unix timestamp in milliseconds of when the run started."
                  },
                  "tags": {
                    "type": "string",
                    "description": "Additional metadata for run."
                  },
                  "user_id": {
                    "type": "string",
                    "description": "ID of the user executing the run. This field is deprecated as of MLflow 1.0, and will be removed in a future MLflow release. Use 'mlflow.user' tag instead."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateRunResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/delete": {
      "post": {
        "operationId": "experiments_delete_experiment",
        "summary": "Marks an experiment and associated metadata, runs, metrics, params, and tags for deletion. If the",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Marks an experiment and associated metadata, runs, metrics, params, and tags for deletion. If the\nexperiment uses FileStore, artifacts associated with the experiment are also deleted.\n\n:param experiment_id: str\n  ID of the associated experiment.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "ID of the associated experiment."
                  }
                },
                "required": [
                  "experiment_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models/{model_id}": {
      "delete": {
        "operationId": "experiments_delete_logged_model",
        "summary": "Delete a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Delete a logged model.\n\n:param model_id: str\n  The ID of the logged model to delete.",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "experiments_finalize_logged_model",
        "summary": "Finalize a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Finalize a logged model.\n\n:param model_id: str\n  The ID of the logged model to finalize.\n:param status: :class:`LoggedModelStatus`\n  Whether or not the model is ready for use. ``\"LOGGED_MODEL_UPLOAD_FAILED\"`` indicates that something\n  went wrong when logging the model weights / agent code.\n\n:returns: :class:`FinalizeLoggedModelResponse`",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to finalize."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "status": {
                    "type": "string",
                    "description": "Whether or not the model is ready for use. ``\"LOGGED_MODEL_UPLOAD_FAILED\"`` indicates that something went wrong when logging the model weights / agent code."
                  }
                },
                "required": [
                  "status"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FinalizeLoggedModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "experiments_get_logged_model",
        "summary": "Get a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Get a logged model.\n\n:param model_id: str\n  The ID of the logged model to retrieve.\n\n:returns: :class:`GetLoggedModelResponse`",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to retrieve."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetLoggedModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models/{model_id}/tags/{tag_key}": {
      "delete": {
        "operationId": "experiments_delete_logged_model_tag",
        "summary": "Delete a tag on a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Delete a tag on a logged model.\n\n:param model_id: str\n  The ID of the logged model to delete the tag from.\n:param tag_key: str\n  The tag key.",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to delete the tag from."
          },
          {
            "name": "tag_key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The tag key."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/delete": {
      "post": {
        "operationId": "experiments_delete_run",
        "summary": "Marks a run for deletion.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Marks a run for deletion.\n\n:param run_id: str\n  ID of the run to delete.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to delete."
                  }
                },
                "required": [
                  "run_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/databricks/runs/delete-runs": {
      "post": {
        "operationId": "experiments_delete_runs",
        "summary": "Bulk delete runs in an experiment that were created prior to or at the specified timestamp. Deletes at",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Bulk delete runs in an experiment that were created prior to or at the specified timestamp. Deletes at\nmost max_runs per request. To call this API from a Databricks Notebook in Python, you can use the\nclient code snippet on\n\n:param experiment_id: str\n  The ID of the experiment containing the runs to delete.\n:param max_timestamp_millis: int\n  The maximum creation timestamp in milliseconds since the UNIX epoch for deleting runs. Only runs\n  created prior to or at this timestamp are deleted.\n:param max_runs: int (optional)\n  An optional positive integer indicating the maximum number of runs to delete. The maximum allowed\n  value for max_runs is 10000.\n\n:returns: :class:`DeleteRunsResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "The ID of the experiment containing the runs to delete."
                  },
                  "max_timestamp_millis": {
                    "type": "integer",
                    "description": "The maximum creation timestamp in milliseconds since the UNIX epoch for deleting runs. Only runs created prior to or at this timestamp are deleted."
                  },
                  "max_runs": {
                    "type": "string",
                    "description": "An optional positive integer indicating the maximum number of runs to delete. The maximum allowed value for max_runs is 10000."
                  }
                },
                "required": [
                  "experiment_id",
                  "max_timestamp_millis"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteRunsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/delete-tag": {
      "post": {
        "operationId": "experiments_delete_tag",
        "summary": "Deletes a tag on a run. Tags are run metadata that can be updated during a run and after a run",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Deletes a tag on a run. Tags are run metadata that can be updated during a run and after a run\ncompletes.\n\n:param run_id: str\n  ID of the run that the tag was logged under. Must be provided.\n:param key: str\n  Name of the tag. Maximum size is 255 bytes. Must be provided.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run that the tag was logged under. Must be provided."
                  },
                  "key": {
                    "type": "string",
                    "description": "Name of the tag. Maximum size is 255 bytes. Must be provided."
                  }
                },
                "required": [
                  "run_id",
                  "key"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/get-by-name": {
      "get": {
        "operationId": "experiments_get_by_name",
        "summary": "Gets metadata for an experiment.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets metadata for an experiment.\n\nThis endpoint will return deleted experiments, but prefers the active experiment if an active and\ndeleted experiment share the same name. If multiple deleted experiments share the same name, the API\nwill return one of them.\n\nThrows `RESOURCE_DOES_NOT_EXIST` if no experiment with the specified name exists.\n\n:param experiment_name: str\n  Name of the associated experiment.\n\n:returns: :class:`GetExperimentByNameResponse`",
        "parameters": [
          {
            "name": "experiment_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the associated experiment."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetExperimentByNameResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/get": {
      "get": {
        "operationId": "experiments_get_experiment",
        "summary": "Gets metadata for an experiment. This method works on deleted experiments.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets metadata for an experiment. This method works on deleted experiments.\n\n:param experiment_id: str\n  ID of the associated experiment.\n\n:returns: :class:`GetExperimentResponse`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "ID of the associated experiment."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetExperimentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/metrics/get-history": {
      "get": {
        "operationId": "experiments_get_history",
        "summary": "Gets a list of all values for the specified metric for a given run.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets a list of all values for the specified metric for a given run.\n\n:param metric_key: str\n  Name of the metric.\n:param max_results: int (optional)\n  Maximum number of Metric records to return per paginated request. Default is set to 25,000. If set\n  higher than 25,000, a request Exception will be raised.\n:param page_token: str (optional)\n  Token indicating the page of metric histories to fetch.\n:param run_id: str (optional)\n  ID of the run from which to fetch metric values. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run from which to fetch metric values. This field will\n  be removed in a future MLflow version.\n\n:returns: Iterator over :class:`Metric`",
        "parameters": [
          {
            "name": "metric_key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the metric."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of Metric records to return per paginated request. Default is set to 25,000. If set higher than 25,000, a request Exception will be raised."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Token indicating the page of metric histories to fetch."
          },
          {
            "name": "run_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "ID of the run from which to fetch metric values. Must be provided."
          },
          {
            "name": "run_uuid",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "[Deprecated, use `run_id` instead] ID of the run from which to fetch metric values. This field will be removed in a future MLflow version."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Metric"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/experiments/{experiment_id}/permissionLevels": {
      "get": {
        "operationId": "experiments_get_permission_levels",
        "summary": "Gets the permission levels that a user can have on an object.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets the permission levels that a user can have on an object.\n\n:param experiment_id: str\n  The experiment for which to get or manage permissions.\n\n:returns: :class:`GetExperimentPermissionLevelsResponse`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The experiment for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetExperimentPermissionLevelsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/experiments/{experiment_id}": {
      "get": {
        "operationId": "experiments_get_permissions",
        "summary": "Gets the permissions of an experiment. Experiments can inherit permissions from their root object.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets the permissions of an experiment. Experiments can inherit permissions from their root object.\n\n:param experiment_id: str\n  The experiment for which to get or manage permissions.\n\n:returns: :class:`ExperimentPermissions`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The experiment for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "experiments_set_permissions",
        "summary": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct\npermissions if none are specified. Objects can inherit permissions from their root object.\n\n:param experiment_id: str\n  The experiment for which to get or manage permissions.\n:param access_control_list: List[:class:`ExperimentAccessControlRequest`] (optional)\n\n:returns: :class:`ExperimentPermissions`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The experiment for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`ExperimentPermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "experiments_update_permissions",
        "summary": "Updates the permissions on an experiment. Experiments can inherit permissions from their root object.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Updates the permissions on an experiment. Experiments can inherit permissions from their root object.\n\n:param experiment_id: str\n  The experiment for which to get or manage permissions.\n:param access_control_list: List[:class:`ExperimentAccessControlRequest`] (optional)\n\n:returns: :class:`ExperimentPermissions`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The experiment for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`ExperimentPermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/get": {
      "get": {
        "operationId": "experiments_get_run",
        "summary": "Gets the metadata, metrics, params, and tags for a run. In the case where multiple metrics with the",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets the metadata, metrics, params, and tags for a run. In the case where multiple metrics with the\nsame key are logged for a run, return only the value with the latest timestamp.\n\nIf there are multiple values with the latest timestamp, return the maximum of these values.\n\n:param run_id: str\n  ID of the run to fetch. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run to fetch. This field will be removed in a future\n  MLflow version.\n\n:returns: :class:`GetRunResponse`",
        "parameters": [
          {
            "name": "run_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "ID of the run to fetch. Must be provided."
          },
          {
            "name": "run_uuid",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "[Deprecated, use `run_id` instead] ID of the run to fetch. This field will be removed in a future MLflow version."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetRunResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/artifacts/list": {
      "get": {
        "operationId": "experiments_list_artifacts",
        "summary": "List artifacts for a run. Takes an optional `artifact_path` prefix which if specified, the response",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "List artifacts for a run. Takes an optional `artifact_path` prefix which if specified, the response\ncontains only artifacts with the specified prefix. A maximum of 1000 artifacts will be retrieved for\nUC Volumes. Please call `/api/2.0/fs/directories{directory_path}` for listing artifacts in UC Volumes,\nwhich supports pagination. See [List directory contents | Files\nAPI](/api/workspace/files/listdirectorycontents).\n\n:param page_token: str (optional)\n  The token indicating the page of artifact results to fetch. `page_token` is not supported when\n  listing artifacts in UC Volumes. A maximum of 1000 artifacts will be retrieved for UC Volumes.\n  Please call `/api/2.0/fs/directories{directory_path}` for listing artifacts in UC Volumes, which\n  supports pagination. See [List directory contents | Files\n  API](/api/workspace/files/listdirectorycontents).\n:param path: str (optional)\n  Filter artifacts matching this path (a relative path from the root artifact directory).\n:param run_id: str (optional)\n  ID of the run whose artifacts to list. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run whose artifacts to list. This field will be removed\n  in a future MLflow version.\n\n:returns: Iterator over :class:`FileInfo`",
        "parameters": [
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The token indicating the page of artifact results to fetch. `page_token` is not supported when listing artifacts in UC Volumes. A maximum of 1000 artifacts will be retrieved for UC Volumes. Please call `/api/2.0/fs/directories{directory_path}` for listing artifacts in UC Volumes, which supports pagination. See [List directory contents | Files API](/api/workspace/files/listdirectorycontents)."
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Filter artifacts matching this path (a relative path from the root artifact directory)."
          },
          {
            "name": "run_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "ID of the run whose artifacts to list. Must be provided."
          },
          {
            "name": "run_uuid",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "[Deprecated, use `run_id` instead] ID of the run whose artifacts to list. This field will be removed in a future MLflow version."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/list": {
      "get": {
        "operationId": "experiments_list_experiments",
        "summary": "Gets a list of all experiments.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Gets a list of all experiments.\n\n:param max_results: int (optional)\n  Maximum number of experiments desired. If `max_results` is unspecified, return all experiments. If\n  `max_results` is too large, it'll be automatically capped at 1000. Callers of this endpoint are\n  encouraged to pass max_results explicitly and leverage page_token to iterate through experiments.\n:param page_token: str (optional)\n  Token indicating the page of experiments to fetch\n:param view_type: :class:`ViewType` (optional)\n  Qualifier for type of experiments to be returned. If unspecified, return only active experiments.\n\n:returns: Iterator over :class:`Experiment`",
        "parameters": [
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of experiments desired. If `max_results` is unspecified, return all experiments. If `max_results` is too large, it'll be automatically capped at 1000. Callers of this endpoint are encouraged to pass max_results explicitly and leverage page_token to iterate through experiments."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Token indicating the page of experiments to fetch"
          },
          {
            "name": "view_type",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Qualifier for type of experiments to be returned. If unspecified, return only active experiments."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Experiment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/log-batch": {
      "post": {
        "operationId": "experiments_log_batch",
        "summary": "Logs a batch of metrics, params, and tags for a run. If any data failed to be persisted, the server",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Logs a batch of metrics, params, and tags for a run. If any data failed to be persisted, the server\nwill respond with an error (non-200 status code).\n\nIn case of error (due to internal server error or an invalid request), partial data may be written.\n\nYou can write metrics, params, and tags in interleaving fashion, but within a given entity type are\nguaranteed to follow the order specified in the request body.\n\nThe overwrite behavior for metrics, params, and tags is as follows:\n\n* Metrics: metric values are never overwritten. Logging a metric (key, value, timestamp) appends to\nthe set of values for the metric with the provided key.\n\n* Tags: tag values can be overwritten by successive writes to the same tag key. That is, if multiple\ntag values with the same key are provided in the same API request, the last-provided tag value is\nwritten. Logging the same tag (key, value) is permitted. Specifically, logging a tag is idempotent.\n\n* Parameters: once written, param values cannot be changed (attempting to overwrite a param value will\nresult in an error). However, logging the same param (key, value) is permitted. Specifically, logging\na param is idempotent.\n\nRequest Limits ------------------------------- A single JSON-serialized API request may be up to 1 MB\nin size and contain:\n\n* No more than 1000 metrics, params, and tags in total\n\n* Up to 1000 metrics\n\n* Up to 100 params\n\n* Up to 100 tags\n\nFor example, a valid request might contain 900 metrics, 50 params, and 50 tags, but logging 900\nmetrics, 50 params, and 51 tags is invalid.\n\nThe following limits also apply to metric, param, and tag keys and values:\n\n* Metric keys, param keys, and tag keys can be up to 250 characters in length\n\n* Parameter and tag values can be up to 250 characters in length\n\n:param metrics: List[:class:`Metric`] (optional)\n  Metrics to log. A single request can contain up to 1000 metrics, and up to 1000 metrics, params, and\n  tags in total.\n:param params: List[:class:`Param`] (optional)\n  Params to log. A single request can contain up to 100 params, and up to 1000 metrics, params, and\n  tags in total.\n:param run_id: str (optional)\n  ID of the run to log under\n:param tags: List[:class:`RunTag`] (optional)\n  Tags to log. A single request can contain up to 100 tags, and up to 1000 metrics, params, and tags\n  in total.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metrics": {
                    "type": "string",
                    "description": "Metrics to log. A single request can contain up to 1000 metrics, and up to 1000 metrics, params, and tags in total."
                  },
                  "params": {
                    "type": "string",
                    "description": "Params to log. A single request can contain up to 100 params, and up to 1000 metrics, params, and tags in total."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to log under"
                  },
                  "tags": {
                    "type": "string",
                    "description": "Tags to log. A single request can contain up to 100 tags, and up to 1000 metrics, params, and tags in total."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/log-inputs": {
      "post": {
        "operationId": "experiments_log_inputs",
        "summary": "Logs inputs, such as datasets and models, to an MLflow Run.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Logs inputs, such as datasets and models, to an MLflow Run.\n\n:param run_id: str\n  ID of the run to log under\n:param datasets: List[:class:`DatasetInput`] (optional)\n  Dataset inputs\n:param models: List[:class:`ModelInput`] (optional)\n  Model inputs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to log under"
                  },
                  "datasets": {
                    "type": "string",
                    "description": "Dataset inputs"
                  },
                  "models": {
                    "type": "string",
                    "description": "Model inputs"
                  }
                },
                "required": [
                  "run_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models/{model_id}/params": {
      "post": {
        "operationId": "experiments_log_logged_model_params",
        "summary": "Logs params for a logged model. A param is a key-value pair (string key, string value). Examples",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Logs params for a logged model. A param is a key-value pair (string key, string value). Examples\ninclude hyperparameters used for ML model training. A param can be logged only once for a logged\nmodel, and attempting to overwrite an existing param with a different value will result in an error\n\n:param model_id: str\n  The ID of the logged model to log params for.\n:param params: List[:class:`LoggedModelParameter`] (optional)\n  Parameters to attach to the model.",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to log params for."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "params": {
                    "type": "string",
                    "description": "Parameters to attach to the model."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/log-metric": {
      "post": {
        "operationId": "experiments_log_metric",
        "summary": "Log a metric for a run. A metric is a key-value pair (string key, float value) with an associated",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Log a metric for a run. A metric is a key-value pair (string key, float value) with an associated\ntimestamp. Examples include the various metrics that represent ML model accuracy. A metric can be\nlogged multiple times.\n\n:param key: str\n  Name of the metric.\n:param value: float\n  Double value of the metric being logged.\n:param timestamp: int\n  Unix timestamp in milliseconds at the time metric was logged.\n:param dataset_digest: str (optional)\n  Dataset digest of the dataset associated with the metric, e.g. an md5 hash of the dataset that\n  uniquely identifies it within datasets of the same name.\n:param dataset_name: str (optional)\n  The name of the dataset associated with the metric. E.g. \u201cmy.uc.table@2\u201d \u201cnyc-taxi-dataset\u201d,\n  \u201cfantastic-elk-3\u201d\n:param model_id: str (optional)\n  ID of the logged model associated with the metric, if applicable\n:param run_id: str (optional)\n  ID of the run under which to log the metric. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run under which to log the metric. This field will be\n  removed in a future MLflow version.\n:param step: int (optional)\n  Step at which to log the metric",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Name of the metric."
                  },
                  "value": {
                    "type": "number",
                    "description": "Double value of the metric being logged."
                  },
                  "timestamp": {
                    "type": "integer",
                    "description": "Unix timestamp in milliseconds at the time metric was logged."
                  },
                  "dataset_digest": {
                    "type": "string",
                    "description": "Dataset digest of the dataset associated with the metric, e.g. an md5 hash of the dataset that uniquely identifies it within datasets of the same name."
                  },
                  "dataset_name": {
                    "type": "string",
                    "description": "The name of the dataset associated with the metric. E.g. \u201cmy.uc.table@2\u201d \u201cnyc-taxi-dataset\u201d, \u201cfantastic-elk-3\u201d"
                  },
                  "model_id": {
                    "type": "string",
                    "description": "ID of the logged model associated with the metric, if applicable"
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run under which to log the metric. Must be provided."
                  },
                  "run_uuid": {
                    "type": "string",
                    "description": "[Deprecated, use `run_id` instead] ID of the run under which to log the metric. This field will be removed in a future MLflow version."
                  },
                  "step": {
                    "type": "string",
                    "description": "Step at which to log the metric"
                  }
                },
                "required": [
                  "key",
                  "value",
                  "timestamp"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/log-model": {
      "post": {
        "operationId": "experiments_log_model",
        "summary": "**Note:** the [Create a logged model](/api/workspace/experiments/createloggedmodel) API replaces this",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "**Note:** the [Create a logged model](/api/workspace/experiments/createloggedmodel) API replaces this\nendpoint.\n\nLog a model to an MLflow Run.\n\n:param model_json: str (optional)\n  MLmodel file in json format.\n:param run_id: str (optional)\n  ID of the run to log under",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "model_json": {
                    "type": "string",
                    "description": "MLmodel file in json format."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to log under"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/outputs": {
      "post": {
        "operationId": "experiments_log_outputs",
        "summary": "Logs outputs, such as models, from an MLflow Run.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Logs outputs, such as models, from an MLflow Run.\n\n:param run_id: str\n  The ID of the Run from which to log outputs.\n:param models: List[:class:`ModelOutput`] (optional)\n  The model outputs from the Run.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "run_id": {
                    "type": "string",
                    "description": "The ID of the Run from which to log outputs."
                  },
                  "models": {
                    "type": "string",
                    "description": "The model outputs from the Run."
                  }
                },
                "required": [
                  "run_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/log-parameter": {
      "post": {
        "operationId": "experiments_log_param",
        "summary": "Logs a param used for a run. A param is a key-value pair (string key, string value). Examples include",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Logs a param used for a run. A param is a key-value pair (string key, string value). Examples include\nhyperparameters used for ML model training and constant dates and values used in an ETL pipeline. A\nparam can be logged only once for a run.\n\n:param key: str\n  Name of the param. Maximum size is 255 bytes.\n:param value: str\n  String value of the param being logged. Maximum size is 500 bytes.\n:param run_id: str (optional)\n  ID of the run under which to log the param. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run under which to log the param. This field will be\n  removed in a future MLflow version.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Name of the param. Maximum size is 255 bytes."
                  },
                  "value": {
                    "type": "string",
                    "description": "String value of the param being logged. Maximum size is 500 bytes."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run under which to log the param. Must be provided."
                  },
                  "run_uuid": {
                    "type": "string",
                    "description": "[Deprecated, use `run_id` instead] ID of the run under which to log the param. This field will be removed in a future MLflow version."
                  }
                },
                "required": [
                  "key",
                  "value"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/restore": {
      "post": {
        "operationId": "experiments_restore_experiment",
        "summary": "Restore an experiment marked for deletion. This also restores associated metadata, runs, metrics,",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Restore an experiment marked for deletion. This also restores associated metadata, runs, metrics,\nparams, and tags. If experiment uses FileStore, underlying artifacts associated with experiment are\nalso restored.\n\nThrows `RESOURCE_DOES_NOT_EXIST` if experiment was never created or was permanently deleted.\n\n:param experiment_id: str\n  ID of the associated experiment.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "ID of the associated experiment."
                  }
                },
                "required": [
                  "experiment_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/restore": {
      "post": {
        "operationId": "experiments_restore_run",
        "summary": "Restores a deleted run. This also restores associated metadata, runs, metrics, params, and tags.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Restores a deleted run. This also restores associated metadata, runs, metrics, params, and tags.\n\nThrows `RESOURCE_DOES_NOT_EXIST` if the run was never created or was permanently deleted.\n\n:param run_id: str\n  ID of the run to restore.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to restore."
                  }
                },
                "required": [
                  "run_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/databricks/runs/restore-runs": {
      "post": {
        "operationId": "experiments_restore_runs",
        "summary": "Bulk restore runs in an experiment that were deleted no earlier than the specified timestamp. Restores",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Bulk restore runs in an experiment that were deleted no earlier than the specified timestamp. Restores\nat most max_runs per request. To call this API from a Databricks Notebook in Python, you can use the\nclient code snippet on\n\n:param experiment_id: str\n  The ID of the experiment containing the runs to restore.\n:param min_timestamp_millis: int\n  The minimum deletion timestamp in milliseconds since the UNIX epoch for restoring runs. Only runs\n  deleted no earlier than this timestamp are restored.\n:param max_runs: int (optional)\n  An optional positive integer indicating the maximum number of runs to restore. The maximum allowed\n  value for max_runs is 10000.\n\n:returns: :class:`RestoreRunsResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "The ID of the experiment containing the runs to restore."
                  },
                  "min_timestamp_millis": {
                    "type": "integer",
                    "description": "The minimum deletion timestamp in milliseconds since the UNIX epoch for restoring runs. Only runs deleted no earlier than this timestamp are restored."
                  },
                  "max_runs": {
                    "type": "string",
                    "description": "An optional positive integer indicating the maximum number of runs to restore. The maximum allowed value for max_runs is 10000."
                  }
                },
                "required": [
                  "experiment_id",
                  "min_timestamp_millis"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RestoreRunsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/search": {
      "post": {
        "operationId": "experiments_search_experiments",
        "summary": "Searches for experiments that satisfy specified search criteria.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Searches for experiments that satisfy specified search criteria.\n\n:param filter: str (optional)\n  String representing a SQL filter condition (e.g. \"name ILIKE 'my-experiment%'\")\n:param max_results: int (optional)\n  Maximum number of experiments desired. Max threshold is 3000.\n:param order_by: List[str] (optional)\n  List of columns for ordering search results, which can include experiment name and last updated\n  timestamp with an optional \"DESC\" or \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are\n  done by experiment id DESC.\n:param page_token: str (optional)\n  Token indicating the page of experiments to fetch\n:param view_type: :class:`ViewType` (optional)\n  Qualifier for type of experiments to be returned. If unspecified, return only active experiments.\n\n:returns: Iterator over :class:`Experiment`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "filter": {
                    "type": "string",
                    "description": "String representing a SQL filter condition (e.g. \"name ILIKE 'my-experiment%'\")"
                  },
                  "max_results": {
                    "type": "string",
                    "description": "Maximum number of experiments desired. Max threshold is 3000."
                  },
                  "order_by": {
                    "type": "string",
                    "description": "List of columns for ordering search results, which can include experiment name and last updated timestamp with an optional \"DESC\" or \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are done by experiment id DESC."
                  },
                  "page_token": {
                    "type": "string",
                    "description": "Token indicating the page of experiments to fetch"
                  },
                  "view_type": {
                    "type": "string",
                    "description": "Qualifier for type of experiments to be returned. If unspecified, return only active experiments."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Experiment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models/search": {
      "post": {
        "operationId": "experiments_search_logged_models",
        "summary": "Search for Logged Models that satisfy specified search criteria.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Search for Logged Models that satisfy specified search criteria.\n\n:param datasets: List[:class:`SearchLoggedModelsDataset`] (optional)\n  List of datasets on which to apply the metrics filter clauses. For example, a filter with\n  `metrics.accuracy > 0.9` and dataset info with name \"test_dataset\" means we will return all logged\n  models with accuracy > 0.9 on the test_dataset. Metric values from ANY dataset matching the criteria\n  are considered. If no datasets are specified, then metrics across all datasets are considered in the\n  filter.\n:param experiment_ids: List[str] (optional)\n  The IDs of the experiments in which to search for logged models.\n:param filter: str (optional)\n  A filter expression over logged model info and data that allows returning a subset of logged models.\n  The syntax is a subset of SQL that supports AND'ing together binary operations.\n\n  Example: ``params.alpha < 0.3 AND metrics.accuracy > 0.9``.\n:param max_results: int (optional)\n  The maximum number of Logged Models to return. The maximum limit is 50.\n:param order_by: List[:class:`SearchLoggedModelsOrderBy`] (optional)\n  The list of columns for ordering the results, with additional fields for sorting criteria.\n:param page_token: str (optional)\n  The token indicating the page of logged models to fetch.\n\n:returns: :class:`SearchLoggedModelsResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "datasets": {
                    "type": "string",
                    "description": "List of datasets on which to apply the metrics filter clauses. For example, a filter with `metrics.accuracy > 0.9` and dataset info with name \"test_dataset\" means we will return all logged models with accuracy > 0.9 on the test_dataset. Metric values from ANY dataset matching the criteria are considered. If no datasets are specified, then metrics across all datasets are considered in the filter."
                  },
                  "experiment_ids": {
                    "type": "string",
                    "description": "The IDs of the experiments in which to search for logged models."
                  },
                  "filter": {
                    "type": "string",
                    "description": "A filter expression over logged model info and data that allows returning a subset of logged models. The syntax is a subset of SQL that supports AND'ing together binary operations. Example: ``params.alpha < 0.3 AND metrics.accuracy > 0.9``."
                  },
                  "max_results": {
                    "type": "string",
                    "description": "The maximum number of Logged Models to return. The maximum limit is 50."
                  },
                  "order_by": {
                    "type": "string",
                    "description": "The list of columns for ordering the results, with additional fields for sorting criteria."
                  },
                  "page_token": {
                    "type": "string",
                    "description": "The token indicating the page of logged models to fetch."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchLoggedModelsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/search": {
      "post": {
        "operationId": "experiments_search_runs",
        "summary": "Searches for runs that satisfy expressions.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Searches for runs that satisfy expressions.\n\nSearch expressions can use `mlflowMetric` and `mlflowParam` keys.\n\n:param experiment_ids: List[str] (optional)\n  List of experiment IDs to search over.\n:param filter: str (optional)\n  A filter expression over params, metrics, and tags, that allows returning a subset of runs. The\n  syntax is a subset of SQL that supports ANDing together binary operations between a param, metric,\n  or tag and a constant.\n\n  Example: `metrics.rmse < 1 and params.model_class = 'LogisticRegression'`\n\n  You can select columns with special characters (hyphen, space, period, etc.) by using double quotes:\n  `metrics.\"model class\" = 'LinearRegression' and tags.\"user-name\" = 'Tomas'`\n\n  Supported operators are `=`, `!=`, `>`, `>=`, `<`, and `<=`.\n:param max_results: int (optional)\n  Maximum number of runs desired. Max threshold is 50000\n:param order_by: List[str] (optional)\n  List of columns to be ordered by, including attributes, params, metrics, and tags with an optional\n  `\"DESC\"` or `\"ASC\"` annotation, where `\"ASC\"` is the default. Example: `[\"params.input DESC\",\n  \"metrics.alpha ASC\", \"metrics.rmse\"]`. Tiebreaks are done by start_time `DESC` followed by `run_id`\n  for runs with the same start time (and this is the default ordering criterion if order_by is not\n  provided).\n:param page_token: str (optional)\n  Token for the current page of runs.\n:param run_view_type: :class:`ViewType` (optional)\n  Whether to display only active, only deleted, or all runs. Defaults to only active runs.\n\n:returns: Iterator over :class:`Run`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_ids": {
                    "type": "string",
                    "description": "List of experiment IDs to search over."
                  },
                  "filter": {
                    "type": "string",
                    "description": "A filter expression over params, metrics, and tags, that allows returning a subset of runs. The syntax is a subset of SQL that supports ANDing together binary operations between a param, metric, or tag and a constant. Example: `metrics.rmse < 1 and params.model_class = 'LogisticRegression'` You can select columns with special characters (hyphen, space, period, etc.) by using double quotes: `metrics.\"model class\" = 'LinearRegression' and tags.\"user-name\" = 'Tomas'` Supported operators are `=`, `!=`, `>`, `>=`, `<`, and `<=`."
                  },
                  "max_results": {
                    "type": "string",
                    "description": "Maximum number of runs desired. Max threshold is 50000"
                  },
                  "order_by": {
                    "type": "string",
                    "description": "List of columns to be ordered by, including attributes, params, metrics, and tags with an optional `\"DESC\"` or `\"ASC\"` annotation, where `\"ASC\"` is the default. Example: `[\"params.input DESC\", \"metrics.alpha ASC\", \"metrics.rmse\"]`. Tiebreaks are done by start_time `DESC` followed by `run_id` for runs with the same start time (and this is the default ordering criterion if order_by is not provided)."
                  },
                  "page_token": {
                    "type": "string",
                    "description": "Token for the current page of runs."
                  },
                  "run_view_type": {
                    "type": "string",
                    "description": "Whether to display only active, only deleted, or all runs. Defaults to only active runs."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Run"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/set-experiment-tag": {
      "post": {
        "operationId": "experiments_set_experiment_tag",
        "summary": "Sets a tag on an experiment. Experiment tags are metadata that can be updated.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Sets a tag on an experiment. Experiment tags are metadata that can be updated.\n\n:param experiment_id: str\n  ID of the experiment under which to log the tag. Must be provided.\n:param key: str\n  Name of the tag. Keys up to 250 bytes in size are supported.\n:param value: str\n  String value of the tag being logged. Values up to 64KB in size are supported.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "ID of the experiment under which to log the tag. Must be provided."
                  },
                  "key": {
                    "type": "string",
                    "description": "Name of the tag. Keys up to 250 bytes in size are supported."
                  },
                  "value": {
                    "type": "string",
                    "description": "String value of the tag being logged. Values up to 64KB in size are supported."
                  }
                },
                "required": [
                  "experiment_id",
                  "key",
                  "value"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/logged-models/{model_id}/tags": {
      "patch": {
        "operationId": "experiments_set_logged_model_tags",
        "summary": "Set tags for a logged model.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Set tags for a logged model.\n\n:param model_id: str\n  The ID of the logged model to set the tags on.\n:param tags: List[:class:`LoggedModelTag`] (optional)\n  The tags to set on the logged model.",
        "parameters": [
          {
            "name": "model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the logged model to set the tags on."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tags": {
                    "type": "string",
                    "description": "The tags to set on the logged model."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/set-tag": {
      "post": {
        "operationId": "experiments_set_tag",
        "summary": "Sets a tag on a run. Tags are run metadata that can be updated during a run and after a run completes.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Sets a tag on a run. Tags are run metadata that can be updated during a run and after a run completes.\n\n:param key: str\n  Name of the tag. Keys up to 250 bytes in size are supported.\n:param value: str\n  String value of the tag being logged. Values up to 64KB in size are supported.\n:param run_id: str (optional)\n  ID of the run under which to log the tag. Must be provided.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run under which to log the tag. This field will be\n  removed in a future MLflow version.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Name of the tag. Keys up to 250 bytes in size are supported."
                  },
                  "value": {
                    "type": "string",
                    "description": "String value of the tag being logged. Values up to 64KB in size are supported."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run under which to log the tag. Must be provided."
                  },
                  "run_uuid": {
                    "type": "string",
                    "description": "[Deprecated, use `run_id` instead] ID of the run under which to log the tag. This field will be removed in a future MLflow version."
                  }
                },
                "required": [
                  "key",
                  "value"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/experiments/update": {
      "post": {
        "operationId": "experiments_update_experiment",
        "summary": "Updates experiment metadata.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Updates experiment metadata.\n\n:param experiment_id: str\n  ID of the associated experiment.\n:param new_name: str (optional)\n  If provided, the experiment's name is changed to the new name. The new name must be unique.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "experiment_id": {
                    "type": "string",
                    "description": "ID of the associated experiment."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "If provided, the experiment's name is changed to the new name. The new name must be unique."
                  }
                },
                "required": [
                  "experiment_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/runs/update": {
      "post": {
        "operationId": "experiments_update_run",
        "summary": "Updates run metadata.",
        "tags": [
          "ml",
          "experiments"
        ],
        "description": "Updates run metadata.\n\n:param end_time: int (optional)\n  Unix timestamp in milliseconds of when the run ended.\n:param run_id: str (optional)\n  ID of the run to update. Must be provided.\n:param run_name: str (optional)\n  Updated name of the run.\n:param run_uuid: str (optional)\n  [Deprecated, use `run_id` instead] ID of the run to update. This field will be removed in a future\n  MLflow version.\n:param status: :class:`UpdateRunStatus` (optional)\n  Updated status of the run.\n\n:returns: :class:`UpdateRunResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "end_time": {
                    "type": "string",
                    "description": "Unix timestamp in milliseconds of when the run ended."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "ID of the run to update. Must be provided."
                  },
                  "run_name": {
                    "type": "string",
                    "description": "Updated name of the run."
                  },
                  "run_uuid": {
                    "type": "string",
                    "description": "[Deprecated, use `run_id` instead] ID of the run to update. This field will be removed in a future MLflow version."
                  },
                  "status": {
                    "type": "string",
                    "description": "Updated status of the run."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateRunResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/materialized-features:batchCreate": {
      "post": {
        "operationId": "feature_engineering_batch_create_materialized_features",
        "summary": "Batch create materialized features.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Batch create materialized features.\n\n:param requests: List[:class:`CreateMaterializedFeatureRequest`]\n  The requests to create materialized features.\n\n:returns: :class:`BatchCreateMaterializedFeaturesResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "requests": {
                    "type": "string",
                    "description": "The requests to create materialized features."
                  }
                },
                "required": [
                  "requests"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchCreateMaterializedFeaturesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/features": {
      "post": {
        "operationId": "feature_engineering_create_feature",
        "summary": "Create a Feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Create a Feature.\n\n:param feature: :class:`Feature`\n  Feature to create.\n\n:returns: :class:`Feature`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "feature": {
                    "type": "string",
                    "description": "Feature to create."
                  }
                },
                "required": [
                  "feature"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_list_features",
        "summary": "List Features.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "List Features.\n\n:param page_size: int (optional)\n  The maximum number of results to return.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`Feature`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of results to return."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/features/kafka-configs": {
      "post": {
        "operationId": "feature_engineering_create_kafka_config",
        "summary": "Create a Kafka config. During PrPr, Kafka configs can be read and used when creating features under",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Create a Kafka config. During PrPr, Kafka configs can be read and used when creating features under\nthe entire metastore. Only the creator of the Kafka config can delete it.\n\n:param kafka_config: :class:`KafkaConfig`\n\n:returns: :class:`KafkaConfig`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "kafka_config": {
                    "type": "string",
                    "description": ":returns: :class:`KafkaConfig`"
                  }
                },
                "required": [
                  "kafka_config"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KafkaConfig"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_list_kafka_configs",
        "summary": "List Kafka configs. During PrPr, Kafka configs can be read and used when creating features under the",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "List Kafka configs. During PrPr, Kafka configs can be read and used when creating features under the\nentire metastore. Only the creator of the Kafka config can delete it.\n\n:param page_size: int (optional)\n  The maximum number of results to return.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`KafkaConfig`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of results to return."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KafkaConfig"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/materialized-features": {
      "post": {
        "operationId": "feature_engineering_create_materialized_feature",
        "summary": "Create a materialized feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Create a materialized feature.\n\n:param materialized_feature: :class:`MaterializedFeature`\n  The materialized feature to create.\n\n:returns: :class:`MaterializedFeature`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "materialized_feature": {
                    "type": "string",
                    "description": "The materialized feature to create."
                  }
                },
                "required": [
                  "materialized_feature"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaterializedFeature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_list_materialized_features",
        "summary": "List materialized features.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "List materialized features.\n\n:param feature_name: str (optional)\n  Filter by feature name. If specified, only materialized features materialized from this feature will\n  be returned.\n:param page_size: int (optional)\n  The maximum number of results to return. Defaults to 100 if not specified. Cannot be greater than\n  1000.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`MaterializedFeature`",
        "parameters": [
          {
            "name": "feature_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Filter by feature name. If specified, only materialized features materialized from this feature will be returned."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of results to return. Defaults to 100 if not specified. Cannot be greater than 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaterializedFeature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/features/{full_name}": {
      "delete": {
        "operationId": "feature_engineering_delete_feature",
        "summary": "Delete a Feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Delete a Feature.\n\n:param full_name: str\n  Name of the feature to delete.",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the feature to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_get_feature",
        "summary": "Get a Feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Get a Feature.\n\n:param full_name: str\n  Name of the feature to get.\n\n:returns: :class:`Feature`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the feature to get."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "feature_engineering_update_feature",
        "summary": "Update a Feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Update a Feature.\n\n:param full_name: str\n  The full three-part name (catalog, schema, name) of the feature.\n:param feature: :class:`Feature`\n  Feature to update.\n:param update_mask: str\n  The list of fields to update.\n\n:returns: :class:`Feature`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full three-part name (catalog, schema, name) of the feature."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The list of fields to update."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "feature": {
                    "type": "string",
                    "description": "Feature to update."
                  }
                },
                "required": [
                  "feature"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Feature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/features/kafka-configs/{name}": {
      "delete": {
        "operationId": "feature_engineering_delete_kafka_config",
        "summary": "Delete a Kafka config. During PrPr, Kafka configs can be read and used when creating features under",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Delete a Kafka config. During PrPr, Kafka configs can be read and used when creating features under\nthe entire metastore. Only the creator of the Kafka config can delete it.\n\n:param name: str\n  Name of the Kafka config to delete.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the Kafka config to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_get_kafka_config",
        "summary": "Get a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Get a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the\nentire metastore. Only the creator of the Kafka config can delete it.\n\n:param name: str\n  Name of the Kafka config to get.\n\n:returns: :class:`KafkaConfig`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the Kafka config to get."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KafkaConfig"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "feature_engineering_update_kafka_config",
        "summary": "Update a Kafka config. During PrPr, Kafka configs can be read and used when creating features under",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Update a Kafka config. During PrPr, Kafka configs can be read and used when creating features under\nthe entire metastore. Only the creator of the Kafka config can delete it.\n\n:param name: str\n  Name that uniquely identifies this Kafka config within the metastore. This will be the identifier\n  used from the Feature object to reference these configs for a feature. Can be distinct from topic\n  name.\n:param kafka_config: :class:`KafkaConfig`\n  The Kafka config to update.\n:param update_mask: FieldMask\n  The list of fields to update.\n\n:returns: :class:`KafkaConfig`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature. Can be distinct from topic name."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The list of fields to update."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "kafka_config": {
                    "type": "string",
                    "description": "The Kafka config to update."
                  }
                },
                "required": [
                  "kafka_config"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KafkaConfig"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-engineering/materialized-features/{materialized_feature_id}": {
      "delete": {
        "operationId": "feature_engineering_delete_materialized_feature",
        "summary": "Delete a materialized feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Delete a materialized feature.\n\n:param materialized_feature_id: str\n  The ID of the materialized feature to delete.",
        "parameters": [
          {
            "name": "materialized_feature_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the materialized feature to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_engineering_get_materialized_feature",
        "summary": "Get a materialized feature.",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Get a materialized feature.\n\n:param materialized_feature_id: str\n  The ID of the materialized feature.\n\n:returns: :class:`MaterializedFeature`",
        "parameters": [
          {
            "name": "materialized_feature_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the materialized feature."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaterializedFeature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "feature_engineering_update_materialized_feature",
        "summary": "Update a materialized feature (pause/resume).",
        "tags": [
          "ml",
          "feature_engineering"
        ],
        "description": "Update a materialized feature (pause/resume).\n\n:param materialized_feature_id: str\n  Unique identifier for the materialized feature.\n:param materialized_feature: :class:`MaterializedFeature`\n  The materialized feature to update.\n:param update_mask: str\n  Provide the materialization feature fields which should be updated. Currently, only the\n  pipeline_state field can be updated.\n\n:returns: :class:`MaterializedFeature`",
        "parameters": [
          {
            "name": "materialized_feature_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unique identifier for the materialized feature."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Provide the materialization feature fields which should be updated. Currently, only the pipeline_state field can be updated."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "materialized_feature": {
                    "type": "string",
                    "description": "The materialized feature to update."
                  }
                },
                "required": [
                  "materialized_feature"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaterializedFeature"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/online-stores": {
      "post": {
        "operationId": "feature_store_create_online_store",
        "summary": "Create an Online Feature Store.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Create an Online Feature Store.\n\n:param online_store: :class:`OnlineStore`\n  Online store to create.\n\n:returns: :class:`OnlineStore`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "online_store": {
                    "type": "string",
                    "description": "Online store to create."
                  }
                },
                "required": [
                  "online_store"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineStore"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_store_list_online_stores",
        "summary": "List Online Feature Stores.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "List Online Feature Stores.\n\n:param page_size: int (optional)\n  The maximum number of results to return. Defaults to 100 if not specified.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`OnlineStore`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of results to return. Defaults to 100 if not specified."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineStore"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/online-stores/{name}": {
      "delete": {
        "operationId": "feature_store_delete_online_store",
        "summary": "Delete an Online Feature Store.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Delete an Online Feature Store.\n\n:param name: str\n  Name of the online store to delete.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the online store to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "feature_store_get_online_store",
        "summary": "Get an Online Feature Store.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Get an Online Feature Store.\n\n:param name: str\n  Name of the online store to get.\n\n:returns: :class:`OnlineStore`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the online store to get."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineStore"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "feature_store_update_online_store",
        "summary": "Update an Online Feature Store.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Update an Online Feature Store.\n\n:param name: str\n  The name of the online store. This is the unique identifier for the online store.\n:param online_store: :class:`OnlineStore`\n  Online store to update.\n:param update_mask: str\n  The list of fields to update.\n\n:returns: :class:`OnlineStore`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the online store. This is the unique identifier for the online store."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The list of fields to update."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "online_store": {
                    "type": "string",
                    "description": "Online store to update."
                  }
                },
                "required": [
                  "online_store"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineStore"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/online-tables/{online_table_name}": {
      "delete": {
        "operationId": "feature_store_delete_online_table",
        "summary": "Delete online table.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Delete online table.\n\n:param online_table_name: str\n  The full three-part (catalog, schema, table) name of the online table.",
        "parameters": [
          {
            "name": "online_table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full three-part (catalog, schema, table) name of the online table."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/tables/{source_table_name}/publish": {
      "post": {
        "operationId": "feature_store_publish_table",
        "summary": "Publish features.",
        "tags": [
          "ml",
          "feature_store"
        ],
        "description": "Publish features.\n\n:param source_table_name: str\n  The full three-part (catalog, schema, table) name of the source table.\n:param publish_spec: :class:`PublishSpec`\n  The specification for publishing the online table from the source table.\n\n:returns: :class:`PublishTableResponse`",
        "parameters": [
          {
            "name": "source_table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full three-part (catalog, schema, table) name of the source table."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "publish_spec": {
                    "type": "string",
                    "description": "The specification for publishing the online table from the source table."
                  }
                },
                "required": [
                  "publish_spec"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublishTableResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/automl/create-forecasting-experiment": {
      "post": {
        "operationId": "forecasting_create_experiment",
        "summary": "Creates a serverless forecasting experiment. Returns the experiment ID.",
        "tags": [
          "ml",
          "forecasting"
        ],
        "description": "Creates a serverless forecasting experiment. Returns the experiment ID.\n\n:param train_data_path: str\n  The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name,\n  used as training data for the forecasting model.\n:param target_column: str\n  The column in the input training table used as the prediction target for model training. The values\n  in this column are used as the ground truth for model training.\n:param time_column: str\n  The column in the input training table that represents each row's timestamp.\n:param forecast_granularity: str\n  The time interval between consecutive rows in the time series data. Possible values include: '1\n  second', '1 minute', '5 minutes', '10 minutes', '15 minutes', '30 minutes', 'Hourly', 'Daily',\n  'Weekly', 'Monthly', 'Quarterly', 'Yearly'.\n:param forecast_horizon: int\n  The number of time steps into the future to make predictions, calculated as a multiple of\n  forecast_granularity. This value represents how far ahead the model should forecast.\n:param custom_weights_column: str (optional)\n  The column in the training table used to customize weights for each time series.\n:param experiment_path: str (optional)\n  The path in the workspace to store the created experiment.\n:param future_feature_data_path: str (optional)\n  The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name,\n  used to store future feature data for predictions.\n:param holiday_regions: List[str] (optional)\n  The region code(s) to automatically add holiday features. Currently supports only one region.\n:param include_features: List[str] (optional)\n  Specifies the list of feature columns to include in model training. These columns must exist in the\n  training data and be of type string, numerical, or boolean. If not specified, no additional features\n  will be included. Note: Certain columns are automatically handled: - Automatically excluded:\n  split_column, target_column, custom_weights_column. - Automatically included: time_column.\n:param max_runtime: int (optional)\n  The maximum duration for the experiment in minutes. The experiment stops automatically if it exceeds\n  this limit.\n:param prediction_data_path: str (optional)\n  The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name,\n  used to store predictions.\n:param primary_metric: str (optional)\n  The evaluation metric used to optimize the forecasting model.\n:param register_to: str (optional)\n  The fully qualified path of a Unity Catalog model, formatted as catalog_name.schema_name.model_name,\n  used to store the best model.\n:param split_column: str (optional)\n  // The column in the training table used for custom data splits. Values must be 'train', 'validate',\n  or 'test'.\n:param timeseries_identifier_columns: List[str] (optional)\n  The column in the training table used to group the dataset for predicting individual time series.\n:param training_frameworks: List[str] (optional)\n  List of frameworks to include for model tuning. Possible values are 'Prophet', 'ARIMA', 'DeepAR'. An\n  empty list includes all supported frameworks.\n\n:returns:\n  Long-running operation waiter for :class:`ForecastingExperiment`.\n  See :method:wait_get_experiment_forecasting_succeeded for more details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "train_data_path": {
                    "type": "string",
                    "description": "The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name, used as training data for the forecasting model."
                  },
                  "target_column": {
                    "type": "string",
                    "description": "The column in the input training table used as the prediction target for model training. The values in this column are used as the ground truth for model training."
                  },
                  "time_column": {
                    "type": "string",
                    "description": "The column in the input training table that represents each row's timestamp."
                  },
                  "forecast_granularity": {
                    "type": "string",
                    "description": "The time interval between consecutive rows in the time series data. Possible values include: '1 second', '1 minute', '5 minutes', '10 minutes', '15 minutes', '30 minutes', 'Hourly', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'."
                  },
                  "forecast_horizon": {
                    "type": "integer",
                    "description": "The number of time steps into the future to make predictions, calculated as a multiple of forecast_granularity. This value represents how far ahead the model should forecast."
                  },
                  "custom_weights_column": {
                    "type": "string",
                    "description": "The column in the training table used to customize weights for each time series."
                  },
                  "experiment_path": {
                    "type": "string",
                    "description": "The path in the workspace to store the created experiment."
                  },
                  "future_feature_data_path": {
                    "type": "string",
                    "description": "The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name, used to store future feature data for predictions."
                  },
                  "holiday_regions": {
                    "type": "string",
                    "description": "The region code(s) to automatically add holiday features. Currently supports only one region."
                  },
                  "include_features": {
                    "type": "string",
                    "description": "Specifies the list of feature columns to include in model training. These columns must exist in the training data and be of type string, numerical, or boolean. If not specified, no additional features will be included. Note: Certain columns are automatically handled: - Automatically excluded: split_column, target_column, custom_weights_column. - Automatically included: time_column."
                  },
                  "max_runtime": {
                    "type": "string",
                    "description": "The maximum duration for the experiment in minutes. The experiment stops automatically if it exceeds this limit."
                  },
                  "prediction_data_path": {
                    "type": "string",
                    "description": "The fully qualified path of a Unity Catalog table, formatted as catalog_name.schema_name.table_name, used to store predictions."
                  },
                  "primary_metric": {
                    "type": "string",
                    "description": "The evaluation metric used to optimize the forecasting model."
                  },
                  "register_to": {
                    "type": "string",
                    "description": "The fully qualified path of a Unity Catalog model, formatted as catalog_name.schema_name.model_name, used to store the best model."
                  },
                  "split_column": {
                    "type": "string",
                    "description": "// The column in the training table used for custom data splits. Values must be 'train', 'validate', or 'test'."
                  },
                  "timeseries_identifier_columns": {
                    "type": "string",
                    "description": "The column in the training table used to group the dataset for predicting individual time series."
                  },
                  "training_frameworks": {
                    "type": "string",
                    "description": "List of frameworks to include for model tuning. Possible values are 'Prophet', 'ARIMA', 'DeepAR'. An empty list includes all supported frameworks."
                  }
                },
                "required": [
                  "train_data_path",
                  "target_column",
                  "time_column",
                  "forecast_granularity",
                  "forecast_horizon"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForecastingExperiment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/automl/get-forecasting-experiment/{experiment_id}": {
      "get": {
        "operationId": "forecasting_get_experiment",
        "summary": "Public RPC to get forecasting experiment",
        "tags": [
          "ml",
          "forecasting"
        ],
        "description": "Public RPC to get forecasting experiment\n\n:param experiment_id: str\n  The unique ID of a forecasting experiment\n\n:returns: :class:`ForecastingExperiment`",
        "parameters": [
          {
            "name": "experiment_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The unique ID of a forecasting experiment"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForecastingExperiment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/feature-tables/{table_name}/features/{feature_name}/tags": {
      "post": {
        "operationId": "materialized_features_create_feature_tag",
        "summary": "Creates a FeatureTag.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Creates a FeatureTag.\n\n:param table_name: str\n:param feature_name: str\n:param feature_tag: :class:`FeatureTag`\n\n:returns: :class:`FeatureTag`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param feature_name: str"
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "feature_tag": {
                    "type": "string",
                    "description": ":returns: :class:`FeatureTag`"
                  }
                },
                "required": [
                  "feature_tag"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureTag"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "materialized_features_list_feature_tags",
        "summary": "Lists FeatureTags.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Lists FeatureTags.\n\n:param table_name: str\n:param feature_name: str\n:param page_size: int (optional)\n  The maximum number of results to return.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`FeatureTag`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param feature_name: str"
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of results to return."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureTag"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/feature-tables/{table_name}/features/{feature_name}/tags/{key}": {
      "delete": {
        "operationId": "materialized_features_delete_feature_tag",
        "summary": "Deletes a FeatureTag.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Deletes a FeatureTag.\n\n:param table_name: str\n  The name of the feature table.\n:param feature_name: str\n  The name of the feature within the feature table.\n:param key: str\n  The key of the tag to delete.",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the feature table."
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the feature within the feature table."
          },
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key of the tag to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "materialized_features_get_feature_tag",
        "summary": "Gets a FeatureTag.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Gets a FeatureTag.\n\n:param table_name: str\n:param feature_name: str\n:param key: str\n\n:returns: :class:`FeatureTag`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param feature_name: str"
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`FeatureTag`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureTag"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "materialized_features_update_feature_tag",
        "summary": "Updates a FeatureTag.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Updates a FeatureTag.\n\n:param table_name: str\n:param feature_name: str\n:param key: str\n:param feature_tag: :class:`FeatureTag`\n:param update_mask: str (optional)\n  The list of fields to update.\n\n:returns: :class:`FeatureTag`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param feature_name: str"
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param feature_tag: :class:`FeatureTag`"
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The list of fields to update."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "feature_tag": {
                    "type": "string"
                  }
                },
                "required": [
                  "feature_tag"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureTag"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/feature-store/feature-tables/{table_name}/features/{feature_name}/lineage": {
      "get": {
        "operationId": "materialized_features_get_feature_lineage",
        "summary": "Get Feature Lineage.",
        "tags": [
          "ml",
          "materialized_features"
        ],
        "description": "Get Feature Lineage.\n\n:param table_name: str\n  The full name of the feature table in Unity Catalog.\n:param feature_name: str\n  The name of the feature.\n\n:returns: :class:`FeatureLineage`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full name of the feature table in Unity Catalog."
          },
          {
            "name": "feature_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the feature."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureLineage"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/transition-requests/approve": {
      "post": {
        "operationId": "model_registry_approve_transition_request",
        "summary": "Approves a model version stage transition request.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Approves a model version stage transition request.\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param stage: str\n  Target stage of the transition. Valid values are:\n\n  * `None`: The initial stage of a model version.\n\n  * `Staging`: Staging or pre-production stage.\n\n  * `Production`: Production stage.\n\n  * `Archived`: Archived stage.\n:param archive_existing_versions: bool\n  Specifies whether to archive all current model versions in the target stage.\n:param comment: str (optional)\n  User-provided comment on the action.\n\n:returns: :class:`ApproveTransitionRequestResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the model."
                  },
                  "stage": {
                    "type": "string",
                    "description": "Target stage of the transition. Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
                  },
                  "archive_existing_versions": {
                    "type": "boolean",
                    "description": "Specifies whether to archive all current model versions in the target stage."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "stage",
                  "archive_existing_versions"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApproveTransitionRequestResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/comments/create": {
      "post": {
        "operationId": "model_registry_create_comment",
        "summary": "Posts a comment on a model version. A comment can be submitted either by a user or programmatically to",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Posts a comment on a model version. A comment can be submitted either by a user or programmatically to\ndisplay relevant information about the model. For example, test results or deployment errors.\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param comment: str\n  User-provided comment on the action.\n\n:returns: :class:`CreateCommentResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the model."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "comment"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateCommentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/create": {
      "post": {
        "operationId": "model_registry_create_model",
        "summary": "Creates a new registered model with the name specified in the request body. Throws",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Creates a new registered model with the name specified in the request body. Throws\n`RESOURCE_ALREADY_EXISTS` if a registered model with the given name exists.\n\n:param name: str\n  Register models under this name\n:param description: str (optional)\n  Optional description for registered model.\n:param tags: List[:class:`ModelTag`] (optional)\n  Additional metadata for registered model.\n\n:returns: :class:`CreateModelResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Register models under this name"
                  },
                  "description": {
                    "type": "string",
                    "description": "Optional description for registered model."
                  },
                  "tags": {
                    "type": "string",
                    "description": "Additional metadata for registered model."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/create": {
      "post": {
        "operationId": "model_registry_create_model_version",
        "summary": "Creates a model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Creates a model version.\n\n:param name: str\n  Register model under this name\n:param source: str\n  URI indicating the location of the model artifacts.\n:param description: str (optional)\n  Optional description for model version.\n:param run_id: str (optional)\n  MLflow run ID for correlation, if `source` was generated by an experiment run in MLflow tracking\n  server\n:param run_link: str (optional)\n  MLflow run link - this is the exact link of the run that generated this model version, potentially\n  hosted at another instance of MLflow.\n:param tags: List[:class:`ModelVersionTag`] (optional)\n  Additional metadata for model version.\n\n:returns: :class:`CreateModelVersionResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Register model under this name"
                  },
                  "source": {
                    "type": "string",
                    "description": "URI indicating the location of the model artifacts."
                  },
                  "description": {
                    "type": "string",
                    "description": "Optional description for model version."
                  },
                  "run_id": {
                    "type": "string",
                    "description": "MLflow run ID for correlation, if `source` was generated by an experiment run in MLflow tracking server"
                  },
                  "run_link": {
                    "type": "string",
                    "description": "MLflow run link - this is the exact link of the run that generated this model version, potentially hosted at another instance of MLflow."
                  },
                  "tags": {
                    "type": "string",
                    "description": "Additional metadata for model version."
                  }
                },
                "required": [
                  "name",
                  "source"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateModelVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/transition-requests/create": {
      "post": {
        "operationId": "model_registry_create_transition_request",
        "summary": "Creates a model version stage transition request.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Creates a model version stage transition request.\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param stage: str\n  Target stage of the transition. Valid values are:\n\n  * `None`: The initial stage of a model version.\n\n  * `Staging`: Staging or pre-production stage.\n\n  * `Production`: Production stage.\n\n  * `Archived`: Archived stage.\n:param comment: str (optional)\n  User-provided comment on the action.\n\n:returns: :class:`CreateTransitionRequestResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the model."
                  },
                  "stage": {
                    "type": "string",
                    "description": "Target stage of the transition. Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "stage"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateTransitionRequestResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registry-webhooks/create": {
      "post": {
        "operationId": "model_registry_create_webhook",
        "summary": "**NOTE:** This endpoint is in Public Preview. Creates a registry webhook.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "**NOTE:** This endpoint is in Public Preview. Creates a registry webhook.\n\n:param events: List[:class:`RegistryWebhookEvent`]\n  Events that can trigger a registry webhook: * `MODEL_VERSION_CREATED`: A new model version was\n  created for the associated model.\n\n  * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed.\n\n  * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned.\n\n  * `COMMENT_CREATED`: A user wrote a comment on a registered model.\n\n  * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be\n  specified for a registry-wide webhook, which can be created by not specifying a model name in the\n  create request.\n\n  * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived.\n\n  * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to\n  staging.\n\n  * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to\n  production.\n\n  * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived.\n:param description: str (optional)\n  User-specified description for the webhook.\n:param http_url_spec: :class:`HttpUrlSpec` (optional)\n  External HTTPS URL called on event trigger (by using a POST request).\n:param job_spec: :class:`JobSpec` (optional)\n  ID of the job that the webhook runs.\n:param model_name: str (optional)\n  If model name is not specified, a registry-wide webhook is created that listens for the specified\n  events across all versions of all registered models.\n:param status: :class:`RegistryWebhookStatus` (optional)\n  Enable or disable triggering the webhook, or put the webhook into test mode. The default is\n  `ACTIVE`: * `ACTIVE`: Webhook is triggered when an associated event happens.\n\n  * `DISABLED`: Webhook is not triggered.\n\n  * `TEST_MODE`: Webhook can be triggered through the test endpoint, but is not triggered on a real\n  event.\n\n:returns: :class:`CreateWebhookResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "events": {
                    "type": "string",
                    "description": "Events that can trigger a registry webhook: * `MODEL_VERSION_CREATED`: A new model version was created for the associated model. * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed. * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned. * `COMMENT_CREATED`: A user wrote a comment on a registered model. * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be specified for a registry-wide webhook, which can be created by not specifying a model name in the create request. * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version. * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging. * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production. * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived. * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to staging. * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to production. * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived."
                  },
                  "description": {
                    "type": "string",
                    "description": "User-specified description for the webhook."
                  },
                  "http_url_spec": {
                    "type": "string",
                    "description": "External HTTPS URL called on event trigger (by using a POST request)."
                  },
                  "job_spec": {
                    "type": "string",
                    "description": "ID of the job that the webhook runs."
                  },
                  "model_name": {
                    "type": "string",
                    "description": "If model name is not specified, a registry-wide webhook is created that listens for the specified events across all versions of all registered models."
                  },
                  "status": {
                    "type": "string",
                    "description": "Enable or disable triggering the webhook, or put the webhook into test mode. The default is `ACTIVE`: * `ACTIVE`: Webhook is triggered when an associated event happens. * `DISABLED`: Webhook is not triggered. * `TEST_MODE`: Webhook can be triggered through the test endpoint, but is not triggered on a real event."
                  }
                },
                "required": [
                  "events"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateWebhookResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/comments/delete": {
      "delete": {
        "operationId": "model_registry_delete_comment",
        "summary": "Deletes a comment on a model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Deletes a comment on a model version.\n\n:param id: str\n  Unique identifier of an activity",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unique identifier of an activity"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/delete": {
      "delete": {
        "operationId": "model_registry_delete_model",
        "summary": "Deletes a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Deletes a registered model.\n\n:param name: str\n  Registered model unique name identifier.",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Registered model unique name identifier."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/delete-tag": {
      "delete": {
        "operationId": "model_registry_delete_model_tag",
        "summary": "Deletes the tag for a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Deletes the tag for a registered model.\n\n:param name: str\n  Name of the registered model that the tag was logged under.\n:param key: str\n  Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size\n  is 250 bytes.",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model that the tag was logged under."
          },
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size is 250 bytes."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/delete": {
      "delete": {
        "operationId": "model_registry_delete_model_version",
        "summary": "Deletes a model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Deletes a model version.\n\n:param name: str\n  Name of the registered model\n:param version: str\n  Model version number",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model"
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Model version number"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/delete-tag": {
      "delete": {
        "operationId": "model_registry_delete_model_version_tag",
        "summary": "Deletes a model version tag.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Deletes a model version tag.\n\n:param name: str\n  Name of the registered model that the tag was logged under.\n:param version: str\n  Model version number that the tag was logged under.\n:param key: str\n  Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size\n  is 250 bytes.",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model that the tag was logged under."
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Model version number that the tag was logged under."
          },
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the tag. The name must be an exact match; wild-card deletion is not supported. Maximum size is 250 bytes."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/transition-requests/delete": {
      "delete": {
        "operationId": "model_registry_delete_transition_request",
        "summary": "Cancels a model version stage transition request.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Cancels a model version stage transition request.\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param stage: str\n  Target stage of the transition request. Valid values are:\n\n  * `None`: The initial stage of a model version.\n\n  * `Staging`: Staging or pre-production stage.\n\n  * `Production`: Production stage.\n\n  * `Archived`: Archived stage.\n:param creator: str\n  Username of the user who created this request. Of the transition requests matching the specified\n  details, only the one transition created by this user will be deleted.\n:param comment: str (optional)\n  User-provided comment on the action.\n\n:returns: :class:`DeleteTransitionRequestResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the model."
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Version of the model."
          },
          {
            "name": "stage",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Target stage of the transition request. Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
          },
          {
            "name": "creator",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Username of the user who created this request. Of the transition requests matching the specified details, only the one transition created by this user will be deleted."
          },
          {
            "name": "comment",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "User-provided comment on the action."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteTransitionRequestResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registry-webhooks/delete": {
      "delete": {
        "operationId": "model_registry_delete_webhook",
        "summary": "**NOTE:** This endpoint is in Public Preview. Deletes a registry webhook.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "**NOTE:** This endpoint is in Public Preview. Deletes a registry webhook.\n\n:param id: str\n  Webhook ID required to delete a registry webhook.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Webhook ID required to delete a registry webhook."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/get-latest-versions": {
      "post": {
        "operationId": "model_registry_get_latest_versions",
        "summary": "Gets the latest version of a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Gets the latest version of a registered model.\n\n:param name: str\n  Registered model unique name identifier.\n:param stages: List[str] (optional)\n  List of stages.\n\n:returns: Iterator over :class:`ModelVersion`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Registered model unique name identifier."
                  },
                  "stages": {
                    "type": "string",
                    "description": "List of stages."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersion"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/databricks/registered-models/get": {
      "get": {
        "operationId": "model_registry_get_model",
        "summary": "Get the details of a model. This is a Databricks workspace version of the [MLflow endpoint] that also",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Get the details of a model. This is a Databricks workspace version of the [MLflow endpoint] that also\nreturns the model's Databricks workspace ID and the permission level of the requesting user on the\nmodel.\n\n[MLflow endpoint]: https://www.mlflow.org/docs/latest/rest-api.html#get-registeredmodel\n\n:param name: str\n  Registered model unique name identifier.\n\n:returns: :class:`GetModelResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Registered model unique name identifier."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/get": {
      "get": {
        "operationId": "model_registry_get_model_version",
        "summary": "Get a model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Get a model version.\n\n:param name: str\n  Name of the registered model\n:param version: str\n  Model version number\n\n:returns: :class:`GetModelVersionResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model"
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Model version number"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/get-download-uri": {
      "get": {
        "operationId": "model_registry_get_model_version_download_uri",
        "summary": "Gets a URI to download the model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Gets a URI to download the model version.\n\n:param name: str\n  Name of the registered model\n:param version: str\n  Model version number\n\n:returns: :class:`GetModelVersionDownloadUriResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model"
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Model version number"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelVersionDownloadUriResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/registered-models/{registered_model_id}/permissionLevels": {
      "get": {
        "operationId": "model_registry_get_permission_levels",
        "summary": "Gets the permission levels that a user can have on an object.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Gets the permission levels that a user can have on an object.\n\n:param registered_model_id: str\n  The registered model for which to get or manage permissions.\n\n:returns: :class:`GetRegisteredModelPermissionLevelsResponse`",
        "parameters": [
          {
            "name": "registered_model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The registered model for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetRegisteredModelPermissionLevelsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/registered-models/{registered_model_id}": {
      "get": {
        "operationId": "model_registry_get_permissions",
        "summary": "Gets the permissions of a registered model. Registered models can inherit permissions from their root",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Gets the permissions of a registered model. Registered models can inherit permissions from their root\nobject.\n\n:param registered_model_id: str\n  The registered model for which to get or manage permissions.\n\n:returns: :class:`RegisteredModelPermissions`",
        "parameters": [
          {
            "name": "registered_model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The registered model for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "model_registry_set_permissions",
        "summary": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct\npermissions if none are specified. Objects can inherit permissions from their root object.\n\n:param registered_model_id: str\n  The registered model for which to get or manage permissions.\n:param access_control_list: List[:class:`RegisteredModelAccessControlRequest`] (optional)\n\n:returns: :class:`RegisteredModelPermissions`",
        "parameters": [
          {
            "name": "registered_model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The registered model for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`RegisteredModelPermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "model_registry_update_permissions",
        "summary": "Updates the permissions on a registered model. Registered models can inherit permissions from their",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Updates the permissions on a registered model. Registered models can inherit permissions from their\nroot object.\n\n:param registered_model_id: str\n  The registered model for which to get or manage permissions.\n:param access_control_list: List[:class:`RegisteredModelAccessControlRequest`] (optional)\n\n:returns: :class:`RegisteredModelPermissions`",
        "parameters": [
          {
            "name": "registered_model_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The registered model for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`RegisteredModelPermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelPermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/list": {
      "get": {
        "operationId": "model_registry_list_models",
        "summary": "Lists all available registered models, up to the limit specified in __max_results__.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Lists all available registered models, up to the limit specified in __max_results__.\n\n:param max_results: int (optional)\n  Maximum number of registered models desired. Max threshold is 1000.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous query.\n\n:returns: Iterator over :class:`Model`",
        "parameters": [
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of registered models desired. Max threshold is 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/transition-requests/list": {
      "get": {
        "operationId": "model_registry_list_transition_requests",
        "summary": "Gets a list of all open stage transition requests for the model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Gets a list of all open stage transition requests for the model version.\n\n:param name: str\n  Name of the registered model.\n:param version: str\n  Version of the model.\n\n:returns: Iterator over :class:`Activity`",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the registered model."
          },
          {
            "name": "version",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Version of the model."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Activity"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registry-webhooks/list": {
      "get": {
        "operationId": "model_registry_list_webhooks",
        "summary": "**NOTE:** This endpoint is in Public Preview. Lists all registry webhooks.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "**NOTE:** This endpoint is in Public Preview. Lists all registry webhooks.\n\n:param events: List[:class:`RegistryWebhookEvent`] (optional)\n  Events that trigger the webhook. * `MODEL_VERSION_CREATED`: A new model version was created for the\n  associated model.\n\n  * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed.\n\n  * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned.\n\n  * `COMMENT_CREATED`: A user wrote a comment on a registered model.\n\n  * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be\n  specified for a registry-wide webhook, which can be created by not specifying a model name in the\n  create request.\n\n  * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived.\n\n  * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to\n  staging.\n\n  * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to\n  production.\n\n  * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived.\n\n  If `events` is specified, any webhook with one or more of the specified trigger events is included\n  in the output. If `events` is not specified, webhooks of all event types are included in the output.\n:param max_results: int (optional)\n:param model_name: str (optional)\n  Registered model name If not specified, all webhooks associated with the specified events are\n  listed, regardless of their associated model.\n:param page_token: str (optional)\n  Token indicating the page of artifact results to fetch\n\n:returns: Iterator over :class:`RegistryWebhook`",
        "parameters": [
          {
            "name": "events",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Events that trigger the webhook. * `MODEL_VERSION_CREATED`: A new model version was created for the associated model. * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed. * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned. * `COMMENT_CREATED`: A user wrote a comment on a registered model. * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be specified for a registry-wide webhook, which can be created by not specifying a model name in the create request. * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version. * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging. * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production. * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived. * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to staging. * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to production. * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived. If `events` is specified, any webhook with one or more of the specified trigger events is included in the output. If `events` is not specified, webhooks of all event types are included in the output."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": ":param model_name: str (optional) Registered model name If not specified, all webhooks associated with the specified events are listed, regardless of their associated model."
          },
          {
            "name": "model_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Token indicating the page of artifact results to fetch"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegistryWebhook"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/transition-requests/reject": {
      "post": {
        "operationId": "model_registry_reject_transition_request",
        "summary": "Rejects a model version stage transition request.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Rejects a model version stage transition request.\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param stage: str\n  Target stage of the transition. Valid values are:\n\n  * `None`: The initial stage of a model version.\n\n  * `Staging`: Staging or pre-production stage.\n\n  * `Production`: Production stage.\n\n  * `Archived`: Archived stage.\n:param comment: str (optional)\n  User-provided comment on the action.\n\n:returns: :class:`RejectTransitionRequestResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the model."
                  },
                  "stage": {
                    "type": "string",
                    "description": "Target stage of the transition. Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "stage"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RejectTransitionRequestResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/rename": {
      "post": {
        "operationId": "model_registry_rename_model",
        "summary": "Renames a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Renames a registered model.\n\n:param name: str\n  Registered model unique name identifier.\n:param new_name: str (optional)\n  If provided, updates the name for this `registered_model`.\n\n:returns: :class:`RenameModelResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Registered model unique name identifier."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "If provided, updates the name for this `registered_model`."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenameModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/search": {
      "get": {
        "operationId": "model_registry_search_model_versions",
        "summary": "Searches for specific model versions based on the supplied __filter__.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Searches for specific model versions based on the supplied __filter__.\n\n:param filter: str (optional)\n  String filter condition, like \"name='my-model-name'\". Must be a single boolean condition, with\n  string values wrapped in single quotes.\n:param max_results: int (optional)\n  Maximum number of models desired. Max threshold is 10K.\n:param order_by: List[str] (optional)\n  List of columns to be ordered by including model name, version, stage with an optional \"DESC\" or\n  \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are done by latest stage transition\n  timestamp, followed by name ASC, followed by version DESC.\n:param page_token: str (optional)\n  Pagination token to go to next page based on previous search query.\n\n:returns: Iterator over :class:`ModelVersion`",
        "parameters": [
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "String filter condition, like \"name='my-model-name'\". Must be a single boolean condition, with string values wrapped in single quotes."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of models desired. Max threshold is 10K."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "List of columns to be ordered by including model name, version, stage with an optional \"DESC\" or \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are done by latest stage transition timestamp, followed by name ASC, followed by version DESC."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to next page based on previous search query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersion"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/search": {
      "get": {
        "operationId": "model_registry_search_models",
        "summary": "Search for registered models based on the specified __filter__.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Search for registered models based on the specified __filter__.\n\n:param filter: str (optional)\n  String filter condition, like \"name LIKE 'my-model-name'\". Interpreted in the backend automatically\n  as \"name LIKE '%my-model-name%'\". Single boolean condition, with string values wrapped in single\n  quotes.\n:param max_results: int (optional)\n  Maximum number of models desired. Default is 100. Max threshold is 1000.\n:param order_by: List[str] (optional)\n  List of columns for ordering search results, which can include model name and last updated timestamp\n  with an optional \"DESC\" or \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are done by model\n  name ASC.\n:param page_token: str (optional)\n  Pagination token to go to the next page based on a previous search query.\n\n:returns: Iterator over :class:`Model`",
        "parameters": [
          {
            "name": "filter",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "String filter condition, like \"name LIKE 'my-model-name'\". Interpreted in the backend automatically as \"name LIKE '%my-model-name%'\". Single boolean condition, with string values wrapped in single quotes."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of models desired. Default is 100. Max threshold is 1000."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "List of columns for ordering search results, which can include model name and last updated timestamp with an optional \"DESC\" or \"ASC\" annotation, where \"ASC\" is the default. Tiebreaks are done by model name ASC."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Pagination token to go to the next page based on a previous search query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/set-tag": {
      "post": {
        "operationId": "model_registry_set_model_tag",
        "summary": "Sets a tag on a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Sets a tag on a registered model.\n\n:param name: str\n  Unique name of the model.\n:param key: str\n  Name of the tag. Maximum size depends on storage backend. If a tag with this name already exists,\n  its preexisting value will be replaced by the specified `value`. All storage backends are guaranteed\n  to support key values up to 250 bytes in size.\n:param value: str\n  String value of the tag being logged. Maximum size depends on storage backend. All storage backends\n  are guaranteed to support key values up to 5000 bytes in size.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique name of the model."
                  },
                  "key": {
                    "type": "string",
                    "description": "Name of the tag. Maximum size depends on storage backend. If a tag with this name already exists, its preexisting value will be replaced by the specified `value`. All storage backends are guaranteed to support key values up to 250 bytes in size."
                  },
                  "value": {
                    "type": "string",
                    "description": "String value of the tag being logged. Maximum size depends on storage backend. All storage backends are guaranteed to support key values up to 5000 bytes in size."
                  }
                },
                "required": [
                  "name",
                  "key",
                  "value"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/set-tag": {
      "post": {
        "operationId": "model_registry_set_model_version_tag",
        "summary": "Sets a model version tag.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Sets a model version tag.\n\n:param name: str\n  Unique name of the model.\n:param version: str\n  Model version number.\n:param key: str\n  Name of the tag. Maximum size depends on storage backend. If a tag with this name already exists,\n  its preexisting value will be replaced by the specified `value`. All storage backends are guaranteed\n  to support key values up to 250 bytes in size.\n:param value: str\n  String value of the tag being logged. Maximum size depends on storage backend. All storage backends\n  are guaranteed to support key values up to 5000 bytes in size.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Unique name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Model version number."
                  },
                  "key": {
                    "type": "string",
                    "description": "Name of the tag. Maximum size depends on storage backend. If a tag with this name already exists, its preexisting value will be replaced by the specified `value`. All storage backends are guaranteed to support key values up to 250 bytes in size."
                  },
                  "value": {
                    "type": "string",
                    "description": "String value of the tag being logged. Maximum size depends on storage backend. All storage backends are guaranteed to support key values up to 5000 bytes in size."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "key",
                  "value"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registry-webhooks/test": {
      "post": {
        "operationId": "model_registry_test_registry_webhook",
        "summary": "**NOTE:** This endpoint is in Public Preview. Tests a registry webhook.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "**NOTE:** This endpoint is in Public Preview. Tests a registry webhook.\n\n:param id: str\n  Webhook ID\n:param event: :class:`RegistryWebhookEvent` (optional)\n  If `event` is specified, the test trigger uses the specified event. If `event` is not specified, the\n  test trigger uses a randomly chosen event associated with the webhook.\n\n:returns: :class:`TestRegistryWebhookResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "Webhook ID"
                  },
                  "event": {
                    "type": "string",
                    "description": "If `event` is specified, the test trigger uses the specified event. If `event` is not specified, the test trigger uses a randomly chosen event associated with the webhook."
                  }
                },
                "required": [
                  "id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestRegistryWebhookResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/databricks/model-versions/transition-stage": {
      "post": {
        "operationId": "model_registry_transition_stage",
        "summary": "Transition a model version's stage. This is a Databricks workspace version of the [MLflow endpoint]",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Transition a model version's stage. This is a Databricks workspace version of the [MLflow endpoint]\nthat also accepts a comment associated with the transition to be recorded.\n\n[MLflow endpoint]: https://www.mlflow.org/docs/latest/rest-api.html#transition-modelversion-stage\n\n:param name: str\n  Name of the model.\n:param version: str\n  Version of the model.\n:param stage: str\n  Target stage of the transition. Valid values are:\n\n  * `None`: The initial stage of a model version.\n\n  * `Staging`: Staging or pre-production stage.\n\n  * `Production`: Production stage.\n\n  * `Archived`: Archived stage.\n:param archive_existing_versions: bool\n  Specifies whether to archive all current model versions in the target stage.\n:param comment: str (optional)\n  User-provided comment on the action.\n\n:returns: :class:`TransitionStageResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the model."
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the model."
                  },
                  "stage": {
                    "type": "string",
                    "description": "Target stage of the transition. Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
                  },
                  "archive_existing_versions": {
                    "type": "boolean",
                    "description": "Specifies whether to archive all current model versions in the target stage."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "name",
                  "version",
                  "stage",
                  "archive_existing_versions"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransitionStageResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/comments/update": {
      "patch": {
        "operationId": "model_registry_update_comment",
        "summary": "Post an edit to a comment on a model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Post an edit to a comment on a model version.\n\n:param id: str\n  Unique identifier of an activity\n:param comment: str\n  User-provided comment on the action.\n\n:returns: :class:`UpdateCommentResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "Unique identifier of an activity"
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided comment on the action."
                  }
                },
                "required": [
                  "id",
                  "comment"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateCommentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registered-models/update": {
      "patch": {
        "operationId": "model_registry_update_model",
        "summary": "Updates a registered model.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Updates a registered model.\n\n:param name: str\n  Registered model unique name identifier.\n:param description: str (optional)\n  If provided, updates the description for this `registered_model`.\n\n:returns: :class:`UpdateModelResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Registered model unique name identifier."
                  },
                  "description": {
                    "type": "string",
                    "description": "If provided, updates the description for this `registered_model`."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateModelResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/model-versions/update": {
      "patch": {
        "operationId": "model_registry_update_model_version",
        "summary": "Updates the model version.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "Updates the model version.\n\n:param name: str\n  Name of the registered model\n:param version: str\n  Model version number\n:param description: str (optional)\n  If provided, updates the description for this `registered_model`.\n\n:returns: :class:`UpdateModelVersionResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the registered model"
                  },
                  "version": {
                    "type": "string",
                    "description": "Model version number"
                  },
                  "description": {
                    "type": "string",
                    "description": "If provided, updates the description for this `registered_model`."
                  }
                },
                "required": [
                  "name",
                  "version"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateModelVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/mlflow/registry-webhooks/update": {
      "patch": {
        "operationId": "model_registry_update_webhook",
        "summary": "**NOTE:** This endpoint is in Public Preview. Updates a registry webhook.",
        "tags": [
          "ml",
          "model_registry"
        ],
        "description": "**NOTE:** This endpoint is in Public Preview. Updates a registry webhook.\n\n:param id: str\n  Webhook ID\n:param description: str (optional)\n  User-specified description for the webhook.\n:param events: List[:class:`RegistryWebhookEvent`] (optional)\n  Events that can trigger a registry webhook: * `MODEL_VERSION_CREATED`: A new model version was\n  created for the associated model.\n\n  * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed.\n\n  * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned.\n\n  * `COMMENT_CREATED`: A user wrote a comment on a registered model.\n\n  * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be\n  specified for a registry-wide webhook, which can be created by not specifying a model name in the\n  create request.\n\n  * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production.\n\n  * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived.\n\n  * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to\n  staging.\n\n  * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to\n  production.\n\n  * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived.\n:param http_url_spec: :class:`HttpUrlSpec` (optional)\n:param job_spec: :class:`JobSpec` (optional)\n:param status: :class:`RegistryWebhookStatus` (optional)\n\n:returns: :class:`UpdateWebhookResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "Webhook ID"
                  },
                  "description": {
                    "type": "string",
                    "description": "User-specified description for the webhook."
                  },
                  "events": {
                    "type": "string",
                    "description": "Events that can trigger a registry webhook: * `MODEL_VERSION_CREATED`: A new model version was created for the associated model. * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed. * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned. * `COMMENT_CREATED`: A user wrote a comment on a registered model. * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be specified for a registry-wide webhook, which can be created by not specifying a model name in the create request. * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version. * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging. * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production. * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived. * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to staging. * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to production. * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived."
                  },
                  "http_url_spec": {
                    "type": "string",
                    "description": ":param job_spec: :class:`JobSpec` (optional)"
                  },
                  "job_spec": {
                    "type": "string"
                  },
                  "status": {
                    "type": "string",
                    "description": ":returns: :class:`UpdateWebhookResponse`"
                  }
                },
                "required": [
                  "id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWebhookResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Activity": {
        "type": "object",
        "properties": {
          "activity_type": {
            "$ref": "#/components/schemas/ActivityType"
          },
          "comment": {
            "type": "string",
            "description": "User-provided comment associated with the activity, comment, or transition request."
          },
          "creation_timestamp": {
            "type": "integer",
            "description": "Creation time of the object, as a Unix timestamp in milliseconds."
          },
          "from_stage": {
            "type": "string",
            "description": "Source stage of the transition (if the activity is stage transition related). Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier for the object."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Time of the object at last update, as a Unix timestamp in milliseconds."
          },
          "system_comment": {
            "type": "string",
            "description": "Comment made by system, for example explaining an activity of type `SYSTEM_TRANSITION`. It usually describes a side effect, such as a version being archived as part of another version's stage transition, and may not be returned for some activity types."
          },
          "to_stage": {
            "type": "string",
            "description": "Target stage of the transition (if the activity is stage transition related). Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
          },
          "user_id": {
            "type": "string",
            "description": "The username of the user that created the object."
          }
        },
        "description": "For activities, this contains the activity recorded for the action. For comments, this contains\n    the comment details. For transition requests, this contains the transition request details."
      },
      "ApproveTransitionRequestResponse": {
        "type": "object",
        "properties": {
          "activity": {
            "$ref": "#/components/schemas/Activity"
          }
        }
      },
      "AuthConfig": {
        "type": "object",
        "properties": {
          "uc_service_credential_name": {
            "type": "string"
          }
        }
      },
      "BackfillSource": {
        "type": "object",
        "properties": {
          "delta_table_source": {
            "$ref": "#/components/schemas/DeltaTableSource"
          }
        }
      },
      "BatchCreateMaterializedFeaturesResponse": {
        "type": "object",
        "properties": {
          "materialized_features": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MaterializedFeature"
            }
          }
        }
      },
      "ColumnIdentifier": {
        "type": "object",
        "properties": {
          "variant_expr_path": {
            "type": "string"
          }
        },
        "required": [
          "variant_expr_path"
        ]
      },
      "CommentObject": {
        "type": "object",
        "properties": {
          "available_actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CommentActivityAction"
            },
            "description": "Array of actions on the activity allowed for the current viewer."
          },
          "comment": {
            "type": "string",
            "description": "User-provided comment associated with the activity, comment, or transition request."
          },
          "creation_timestamp": {
            "type": "integer",
            "description": "Creation time of the object, as a Unix timestamp in milliseconds."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier for the object."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Time of the object at last update, as a Unix timestamp in milliseconds."
          },
          "user_id": {
            "type": "string",
            "description": "The username of the user that created the object."
          }
        },
        "description": "For activities, this contains the activity recorded for the action. For comments, this contains\n    the comment details. For transition requests, this contains the transition request details."
      },
      "ContinuousWindow": {
        "type": "object",
        "properties": {
          "window_duration": {
            "type": "string"
          },
          "offset": {
            "type": "string",
            "description": "The offset of the continuous window (must be non-positive)."
          }
        },
        "required": [
          "window_duration"
        ]
      },
      "CreateCommentResponse": {
        "type": "object",
        "properties": {
          "comment": {
            "$ref": "#/components/schemas/CommentObject"
          }
        }
      },
      "CreateExperimentResponse": {
        "type": "object",
        "properties": {
          "experiment_id": {
            "type": "string"
          }
        }
      },
      "CreateForecastingExperimentResponse": {
        "type": "object",
        "properties": {
          "experiment_id": {
            "type": "string"
          }
        }
      },
      "CreateLoggedModelResponse": {
        "type": "object",
        "properties": {
          "model": {
            "$ref": "#/components/schemas/LoggedModel"
          }
        }
      },
      "CreateMaterializedFeatureRequest": {
        "type": "object",
        "properties": {
          "materialized_feature": {
            "$ref": "#/components/schemas/MaterializedFeature"
          }
        },
        "required": [
          "materialized_feature"
        ]
      },
      "CreateModelResponse": {
        "type": "object",
        "properties": {
          "registered_model": {
            "$ref": "#/components/schemas/Model"
          }
        }
      },
      "CreateModelVersionResponse": {
        "type": "object",
        "properties": {
          "model_version": {
            "$ref": "#/components/schemas/ModelVersion"
          }
        }
      },
      "CreateRunResponse": {
        "type": "object",
        "properties": {
          "run": {
            "$ref": "#/components/schemas/Run"
          }
        }
      },
      "CreateTransitionRequestResponse": {
        "type": "object",
        "properties": {
          "request": {
            "$ref": "#/components/schemas/TransitionRequest"
          }
        }
      },
      "CreateWebhookResponse": {
        "type": "object",
        "properties": {
          "webhook": {
            "$ref": "#/components/schemas/RegistryWebhook"
          }
        }
      },
      "DataSource": {
        "type": "object",
        "properties": {
          "delta_table_source": {
            "$ref": "#/components/schemas/DeltaTableSource"
          },
          "kafka_source": {
            "$ref": "#/components/schemas/KafkaSource"
          }
        }
      },
      "Dataset": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the dataset. E.g. \u201cmy.uc.table@2\u201d \u201cnyc-taxi-dataset\u201d, \u201cfantastic-elk-3\u201d"
          },
          "digest": {
            "type": "string",
            "description": "Dataset digest, e.g. an md5 hash of the dataset that uniquely identifies it within datasets of the same name."
          },
          "source_type": {
            "type": "string",
            "description": "The type of the dataset source, e.g. \u2018databricks-uc-table\u2019, \u2018DBFS\u2019, \u2018S3\u2019, ..."
          },
          "source": {
            "type": "string",
            "description": "Source information for the dataset. Note that the source may not exactly reproduce the dataset if it was transformed / modified before use with MLflow."
          },
          "profile": {
            "type": "string",
            "description": "The profile of the dataset. Summary statistics for the dataset, such as the number of rows in a table, the mean / std / mode of each column in a table, or the number of elements in an array."
          },
          "schema": {
            "type": "string",
            "description": "The schema of the dataset. E.g., MLflow ColSpec JSON for a dataframe, MLflow TensorSpec JSON for an ndarray, or another schema format."
          }
        },
        "required": [
          "name",
          "digest",
          "source_type",
          "source"
        ],
        "description": "Dataset. Represents a reference to data used for training, testing, or evaluation during the\n    model development process."
      },
      "DatasetInput": {
        "type": "object",
        "properties": {
          "dataset": {
            "$ref": "#/components/schemas/Dataset",
            "description": "The dataset being used as a Run input."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InputTag"
            },
            "description": "A list of tags for the dataset input, e.g. a \u201ccontext\u201d tag with value \u201ctraining\u201d"
          }
        },
        "required": [
          "dataset"
        ],
        "description": "DatasetInput. Represents a dataset and input tags."
      },
      "DeleteCommentResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteExperimentResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteLoggedModelResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteLoggedModelTagResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteModelResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteModelTagResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteModelVersionResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteModelVersionTagResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteRunResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteRunsResponse": {
        "type": "object",
        "properties": {
          "runs_deleted": {
            "type": "integer"
          }
        }
      },
      "DeleteTagResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteTransitionRequestResponse": {
        "type": "object",
        "properties": {
          "activity": {
            "$ref": "#/components/schemas/Activity"
          }
        }
      },
      "DeleteWebhookResponse": {
        "type": "object",
        "properties": {}
      },
      "DeltaTableSource": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string"
          },
          "entity_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The entity columns of the Delta table."
          },
          "timeseries_column": {
            "type": "string",
            "description": "The timeseries column of the Delta table."
          }
        },
        "required": [
          "full_name",
          "entity_columns",
          "timeseries_column"
        ]
      },
      "Experiment": {
        "type": "object",
        "properties": {
          "artifact_location": {
            "type": "string",
            "description": "Location where artifacts for the experiment are stored."
          },
          "creation_time": {
            "type": "integer",
            "description": "Creation time"
          },
          "experiment_id": {
            "type": "string",
            "description": "Unique identifier for the experiment."
          },
          "last_update_time": {
            "type": "integer",
            "description": "Last update time"
          },
          "lifecycle_stage": {
            "type": "string",
            "description": "Current life cycle stage of the experiment: \"active\" or \"deleted\". Deleted experiments are not returned by APIs."
          },
          "name": {
            "type": "string",
            "description": "Human readable name that identifies the experiment."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentTag"
            },
            "description": "Tags: Additional metadata key-value pairs."
          }
        },
        "description": "An experiment and its metadata."
      },
      "ExperimentAccessControlRequest": {
        "type": "object",
        "properties": {
          "group_name": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/ExperimentPermissionLevel"
          },
          "service_principal_name": {
            "type": "string",
            "description": "application ID of a service principal"
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "ExperimentAccessControlResponse": {
        "type": "object",
        "properties": {
          "all_permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentPermission"
            }
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the user or service principal."
          },
          "group_name": {
            "type": "string",
            "description": "name of the group"
          },
          "service_principal_name": {
            "type": "string",
            "description": "Name of the service principal."
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "ExperimentPermission": {
        "type": "object",
        "properties": {
          "inherited": {
            "type": "boolean"
          },
          "inherited_from_object": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "permission_level": {
            "$ref": "#/components/schemas/ExperimentPermissionLevel"
          }
        }
      },
      "ExperimentPermissions": {
        "type": "object",
        "properties": {
          "access_control_list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentAccessControlResponse"
            }
          },
          "object_id": {
            "type": "string"
          },
          "object_type": {
            "type": "string"
          }
        }
      },
      "ExperimentPermissionsDescription": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/ExperimentPermissionLevel"
          }
        }
      },
      "ExperimentTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The tag key."
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        },
        "description": "A tag for an experiment."
      },
      "Feature": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string"
          },
          "source": {
            "$ref": "#/components/schemas/DataSource",
            "description": "The data source of the feature."
          },
          "inputs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The input columns from which the feature is computed."
          },
          "function": {
            "$ref": "#/components/schemas/Function",
            "description": "The function by which the feature is computed."
          },
          "description": {
            "type": "string",
            "description": "The description of the feature."
          },
          "filter_condition": {
            "type": "string",
            "description": "The filter condition applied to the source data before aggregation."
          },
          "lineage_context": {
            "$ref": "#/components/schemas/LineageContext",
            "description": "WARNING: This field is primarily intended for internal use by Databricks systems and is automatically populated when features are created through Databricks notebooks or jobs. Users should not manually set this field as incorrect values may lead to inaccurate lineage tracking or unexpected behavior. This field will be set by feature-engineering client and should be left unset by SDK and terraform users."
          },
          "time_window": {
            "$ref": "#/components/schemas/TimeWindow",
            "description": "The time window in which the feature is computed."
          }
        },
        "required": [
          "full_name",
          "source",
          "inputs",
          "function"
        ]
      },
      "FeatureLineage": {
        "type": "object",
        "properties": {
          "feature_specs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeatureLineageFeatureSpec"
            }
          },
          "models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeatureLineageModel"
            },
            "description": "List of Unity Catalog models that were trained on this feature."
          },
          "online_features": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeatureLineageOnlineFeature"
            },
            "description": "List of online features that use this feature as source."
          }
        }
      },
      "FeatureLineageFeatureSpec": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "FeatureLineageModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "version": {
            "type": "integer",
            "description": "The version of the model."
          }
        }
      },
      "FeatureLineageOnlineFeature": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "table_name": {
            "type": "string",
            "description": "The full name of the online table in Unity Catalog."
          }
        }
      },
      "FeatureList": {
        "type": "object",
        "properties": {
          "features": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LinkedFeature"
            }
          }
        },
        "description": "Feature list wrap all the features for a model version"
      },
      "FeatureTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "description": "Represents a tag on a feature in a feature table."
      },
      "FileInfo": {
        "type": "object",
        "properties": {
          "file_size": {
            "type": "integer",
            "description": "The size in bytes of the file. Unset for directories."
          },
          "is_dir": {
            "type": "boolean",
            "description": "Whether the path is a directory."
          },
          "path": {
            "type": "string",
            "description": "The path relative to the root artifact directory run."
          }
        },
        "description": "Metadata of a single artifact file or directory."
      },
      "FinalizeLoggedModelResponse": {
        "type": "object",
        "properties": {
          "model": {
            "$ref": "#/components/schemas/LoggedModel"
          }
        }
      },
      "ForecastingExperiment": {
        "type": "object",
        "properties": {
          "experiment_id": {
            "type": "string",
            "description": "The unique ID for the forecasting experiment."
          },
          "experiment_page_url": {
            "type": "string",
            "description": "The URL to the forecasting experiment page."
          },
          "state": {
            "$ref": "#/components/schemas/ForecastingExperimentState",
            "description": "The current state of the forecasting experiment."
          }
        },
        "description": "Represents a forecasting experiment with its unique identifier, URL, and state."
      },
      "Function": {
        "type": "object",
        "properties": {
          "function_type": {
            "$ref": "#/components/schemas/FunctionFunctionType"
          },
          "extra_parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionExtraParameter"
            },
            "description": "Extra parameters for parameterized functions."
          }
        },
        "required": [
          "function_type"
        ]
      },
      "FunctionExtraParameter": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string",
            "description": "The value of the parameter."
          }
        },
        "required": [
          "key",
          "value"
        ]
      },
      "GetExperimentByNameResponse": {
        "type": "object",
        "properties": {
          "experiment": {
            "$ref": "#/components/schemas/Experiment"
          }
        }
      },
      "GetExperimentPermissionLevelsResponse": {
        "type": "object",
        "properties": {
          "permission_levels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentPermissionsDescription"
            }
          }
        }
      },
      "GetExperimentResponse": {
        "type": "object",
        "properties": {
          "experiment": {
            "$ref": "#/components/schemas/Experiment"
          }
        }
      },
      "GetLatestVersionsResponse": {
        "type": "object",
        "properties": {
          "model_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersion"
            }
          }
        }
      },
      "GetLoggedModelResponse": {
        "type": "object",
        "properties": {
          "model": {
            "$ref": "#/components/schemas/LoggedModel"
          }
        }
      },
      "GetMetricHistoryResponse": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Metric"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "A token that can be used to issue a query for the next page of metric history values. A missing token indicates that no additional metrics are available to fetch."
          }
        }
      },
      "GetModelResponse": {
        "type": "object",
        "properties": {
          "registered_model_databricks": {
            "$ref": "#/components/schemas/ModelDatabricks"
          }
        }
      },
      "GetModelVersionDownloadUriResponse": {
        "type": "object",
        "properties": {
          "artifact_uri": {
            "type": "string"
          }
        }
      },
      "GetModelVersionResponse": {
        "type": "object",
        "properties": {
          "model_version": {
            "$ref": "#/components/schemas/ModelVersion"
          }
        }
      },
      "GetRegisteredModelPermissionLevelsResponse": {
        "type": "object",
        "properties": {
          "permission_levels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelPermissionsDescription"
            }
          }
        }
      },
      "GetRunResponse": {
        "type": "object",
        "properties": {
          "run": {
            "$ref": "#/components/schemas/Run"
          }
        }
      },
      "HttpUrlSpec": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "authorization": {
            "type": "string",
            "description": "Value of the authorization header that should be sent in the request sent by the wehbook. It should be of the form `\"<auth type> <credentials>\"`. If set to an empty string, no authorization header will be included in the request."
          },
          "enable_ssl_verification": {
            "type": "boolean",
            "description": "Enable/disable SSL certificate validation. Default is true. For self-signed certificates, this field must be false AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host."
          },
          "secret": {
            "type": "string",
            "description": "Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as: { \"X-Databricks-Signature\": $encoded_payload }."
          }
        },
        "required": [
          "url"
        ]
      },
      "HttpUrlSpecWithoutSecret": {
        "type": "object",
        "properties": {
          "enable_ssl_verification": {
            "type": "boolean"
          },
          "url": {
            "type": "string",
            "description": "External HTTPS URL called on event trigger (by using a POST request)."
          }
        }
      },
      "InputTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The tag key."
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        },
        "required": [
          "key",
          "value"
        ],
        "description": "Tag for a dataset input."
      },
      "JobContext": {
        "type": "object",
        "properties": {
          "job_id": {
            "type": "integer"
          },
          "job_run_id": {
            "type": "integer",
            "description": "The job run ID where this API was invoked."
          }
        }
      },
      "JobSpec": {
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "access_token": {
            "type": "string",
            "description": "The personal access token used to authorize webhook's job runs."
          },
          "workspace_url": {
            "type": "string",
            "description": "URL of the workspace containing the job that this webhook runs. If not specified, the job\u2019s workspace URL is assumed to be the same as the workspace where the webhook is created."
          }
        },
        "required": [
          "job_id",
          "access_token"
        ]
      },
      "JobSpecWithoutSecret": {
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "workspace_url": {
            "type": "string",
            "description": "URL of the workspace containing the job that this webhook runs. If not specified, the job\u2019s workspace URL is assumed to be the same as the workspace where the webhook is created."
          }
        }
      },
      "KafkaConfig": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "bootstrap_servers": {
            "type": "string",
            "description": "A comma-separated list of host/port pairs pointing to Kafka cluster."
          },
          "subscription_mode": {
            "$ref": "#/components/schemas/SubscriptionMode",
            "description": "Options to configure which Kafka topics to pull data from."
          },
          "auth_config": {
            "$ref": "#/components/schemas/AuthConfig",
            "description": "Authentication configuration for connection to topics."
          },
          "backfill_source": {
            "$ref": "#/components/schemas/BackfillSource",
            "description": "A user-provided and managed source for backfilling data. Historical data is used when creating a training set from streaming features linked to this Kafka config. In the future, a separate table will be maintained by Databricks for forward filling data. The schema for this source must match exactly that of the key and value schemas specified for this Kafka config."
          },
          "extra_options": {
            "type": "object",
            "description": "Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)"
          },
          "key_schema": {
            "$ref": "#/components/schemas/SchemaConfig",
            "description": "Schema configuration for extracting message keys from topics. At least one of key_schema and value_schema must be provided."
          },
          "value_schema": {
            "$ref": "#/components/schemas/SchemaConfig",
            "description": "Schema configuration for extracting message values from topics. At least one of key_schema and value_schema must be provided."
          }
        },
        "required": [
          "name",
          "bootstrap_servers",
          "subscription_mode",
          "auth_config"
        ]
      },
      "KafkaSource": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "entity_column_identifiers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnIdentifier"
            },
            "description": "The entity column identifiers of the Kafka source."
          },
          "timeseries_column_identifier": {
            "$ref": "#/components/schemas/ColumnIdentifier",
            "description": "The timeseries column identifier of the Kafka source."
          }
        },
        "required": [
          "name",
          "entity_column_identifiers",
          "timeseries_column_identifier"
        ]
      },
      "LineageContext": {
        "type": "object",
        "properties": {
          "job_context": {
            "$ref": "#/components/schemas/JobContext",
            "description": "Job context information including job ID and run ID."
          },
          "notebook_id": {
            "type": "integer",
            "description": "The notebook ID where this API was invoked."
          }
        },
        "description": "Lineage context information for tracking where an API was invoked. This will allow us to track\n    lineage, which currently uses caller entity information for use across the Lineage Client and\n    Observability in Lumberjack."
      },
      "LinkedFeature": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string",
            "description": "Feature name"
          },
          "feature_table_id": {
            "type": "string",
            "description": "Feature table id"
          },
          "feature_table_name": {
            "type": "string",
            "description": "Feature table name"
          }
        },
        "description": "Feature for model version. ([ML-57150] Renamed from Feature to LinkedFeature)"
      },
      "ListArtifactsResponse": {
        "type": "object",
        "properties": {
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "The token that can be used to retrieve the next page of artifact results."
          },
          "root_uri": {
            "type": "string",
            "description": "The root artifact directory for the run."
          }
        }
      },
      "ListExperimentsResponse": {
        "type": "object",
        "properties": {
          "experiments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Experiment"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Token that can be used to retrieve the next page of experiments. Empty token means no more experiment is available for retrieval."
          }
        }
      },
      "ListFeatureTagsResponse": {
        "type": "object",
        "properties": {
          "feature_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeatureTag"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token to request the next page of results for this query."
          }
        },
        "description": "Response message for ListFeatureTag."
      },
      "ListFeaturesResponse": {
        "type": "object",
        "properties": {
          "features": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Feature"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token to request the next page of results for this query."
          }
        }
      },
      "ListKafkaConfigsResponse": {
        "type": "object",
        "properties": {
          "kafka_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KafkaConfig"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token to request the next page of results for this query."
          }
        },
        "required": [
          "kafka_configs"
        ]
      },
      "ListMaterializedFeaturesResponse": {
        "type": "object",
        "properties": {
          "materialized_features": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MaterializedFeature"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token to request the next page of results for this query."
          }
        }
      },
      "ListModelsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "registered_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model"
            }
          }
        }
      },
      "ListOnlineStoresResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "online_stores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OnlineStore"
            },
            "description": "List of online stores."
          }
        }
      },
      "ListRegistryWebhooks": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "webhooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegistryWebhook"
            },
            "description": "Array of registry webhooks."
          }
        }
      },
      "ListTransitionRequestsResponse": {
        "type": "object",
        "properties": {
          "requests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Activity"
            }
          }
        }
      },
      "LogBatchResponse": {
        "type": "object",
        "properties": {}
      },
      "LogInputsResponse": {
        "type": "object",
        "properties": {}
      },
      "LogLoggedModelParamsRequestResponse": {
        "type": "object",
        "properties": {}
      },
      "LogMetricResponse": {
        "type": "object",
        "properties": {}
      },
      "LogModelResponse": {
        "type": "object",
        "properties": {}
      },
      "LogOutputsResponse": {
        "type": "object",
        "properties": {}
      },
      "LogParamResponse": {
        "type": "object",
        "properties": {}
      },
      "LoggedModel": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/LoggedModelData",
            "description": "The params and metrics attached to the logged model."
          },
          "info": {
            "$ref": "#/components/schemas/LoggedModelInfo",
            "description": "The logged model attributes such as model ID, status, tags, etc."
          }
        },
        "description": "A logged model message includes logged model attributes, tags, registration info, params, and\n    linked run metrics."
      },
      "LoggedModelData": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Metric"
            },
            "description": "Performance metrics linked to the model."
          },
          "params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoggedModelParameter"
            },
            "description": "Immutable string key-value pairs of the model."
          }
        },
        "description": "A LoggedModelData message includes logged model params and linked metrics."
      },
      "LoggedModelInfo": {
        "type": "object",
        "properties": {
          "artifact_uri": {
            "type": "string",
            "description": "The URI of the directory where model artifacts are stored."
          },
          "creation_timestamp_ms": {
            "type": "integer",
            "description": "The timestamp when the model was created in milliseconds since the UNIX epoch."
          },
          "creator_id": {
            "type": "integer",
            "description": "The ID of the user or principal that created the model."
          },
          "experiment_id": {
            "type": "string",
            "description": "The ID of the experiment that owns the model."
          },
          "last_updated_timestamp_ms": {
            "type": "integer",
            "description": "The timestamp when the model was last updated in milliseconds since the UNIX epoch."
          },
          "model_id": {
            "type": "string",
            "description": "The unique identifier for the logged model."
          },
          "model_type": {
            "type": "string",
            "description": "The type of model, such as ``\"Agent\"``, ``\"Classifier\"``, ``\"LLM\"``."
          },
          "name": {
            "type": "string",
            "description": "The name of the model."
          },
          "source_run_id": {
            "type": "string",
            "description": "The ID of the run that created the model."
          },
          "status": {
            "$ref": "#/components/schemas/LoggedModelStatus",
            "description": "The status of whether or not the model is ready for use."
          },
          "status_message": {
            "type": "string",
            "description": "Details on the current model status."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoggedModelTag"
            },
            "description": "Mutable string key-value pairs set on the model."
          }
        },
        "description": "A LoggedModelInfo includes logged model attributes, tags, and registration info."
      },
      "LoggedModelParameter": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The key identifying this param."
          },
          "value": {
            "type": "string",
            "description": "The value of this param."
          }
        },
        "description": "Parameter associated with a LoggedModel."
      },
      "LoggedModelTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The tag key."
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        },
        "description": "Tag for a LoggedModel."
      },
      "MaterializedFeature": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string",
            "description": "The full name of the feature in Unity Catalog."
          },
          "cron_schedule": {
            "type": "string",
            "description": "The quartz cron expression that defines the schedule of the materialization pipeline. The schedule is evaluated in the UTC timezone."
          },
          "last_materialization_time": {
            "type": "string",
            "description": "The timestamp when the pipeline last ran and updated the materialized feature values. If the pipeline has not run yet, this field will be null."
          },
          "materialized_feature_id": {
            "type": "string",
            "description": "Unique identifier for the materialized feature."
          },
          "offline_store_config": {
            "$ref": "#/components/schemas/OfflineStoreConfig"
          },
          "online_store_config": {
            "$ref": "#/components/schemas/OnlineStoreConfig"
          },
          "pipeline_schedule_state": {
            "$ref": "#/components/schemas/MaterializedFeaturePipelineScheduleState",
            "description": "The schedule state of the materialization pipeline."
          },
          "table_name": {
            "type": "string",
            "description": "The fully qualified Unity Catalog path to the table containing the materialized feature (Delta table or Lakebase table). Output only."
          }
        },
        "required": [
          "feature_name"
        ],
        "description": "A materialized feature represents a feature that is continuously computed and stored."
      },
      "Metric": {
        "type": "object",
        "properties": {
          "dataset_digest": {
            "type": "string",
            "description": "The dataset digest of the dataset associated with the metric, e.g. an md5 hash of the dataset that uniquely identifies it within datasets of the same name."
          },
          "dataset_name": {
            "type": "string",
            "description": "The name of the dataset associated with the metric. E.g. \u201cmy.uc.table@2\u201d \u201cnyc-taxi-dataset\u201d, \u201cfantastic-elk-3\u201d"
          },
          "key": {
            "type": "string",
            "description": "The key identifying the metric."
          },
          "model_id": {
            "type": "string",
            "description": "The ID of the logged model or registered model version associated with the metric, if applicable."
          },
          "run_id": {
            "type": "string",
            "description": "The ID of the run containing the metric."
          },
          "step": {
            "type": "integer",
            "description": "The step at which the metric was logged."
          },
          "timestamp": {
            "type": "integer",
            "description": "The timestamp at which the metric was recorded."
          },
          "value": {
            "type": "number",
            "description": "The value of the metric."
          }
        },
        "description": "Metric associated with a run, represented as a key-value pair."
      },
      "Model": {
        "type": "object",
        "properties": {
          "creation_timestamp": {
            "type": "integer"
          },
          "description": {
            "type": "string",
            "description": "Description of this `registered_model`."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Timestamp recorded when metadata for this `registered_model` was last updated."
          },
          "latest_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersion"
            },
            "description": "Collection of latest model versions for each stage. Only contains models with current `READY` status."
          },
          "name": {
            "type": "string",
            "description": "Unique name for the model."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelTag"
            },
            "description": "Tags: Additional metadata key-value pairs for this `registered_model`."
          },
          "user_id": {
            "type": "string",
            "description": "User that created this `registered_model`"
          }
        }
      },
      "ModelDatabricks": {
        "type": "object",
        "properties": {
          "creation_timestamp": {
            "type": "integer"
          },
          "description": {
            "type": "string",
            "description": "User-specified description for the object."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier for the object."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Last update time of the object, as a Unix timestamp in milliseconds."
          },
          "latest_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersion"
            },
            "description": "Array of model versions, each the latest version for its stage."
          },
          "name": {
            "type": "string",
            "description": "Name of the model."
          },
          "permission_level": {
            "$ref": "#/components/schemas/PermissionLevel",
            "description": "Permission level granted for the requesting user on this registered model"
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelTag"
            },
            "description": "Array of tags associated with the model."
          },
          "user_id": {
            "type": "string",
            "description": "The username of the user that created the object."
          }
        }
      },
      "ModelInput": {
        "type": "object",
        "properties": {
          "model_id": {
            "type": "string",
            "description": "The unique identifier of the model."
          }
        },
        "required": [
          "model_id"
        ],
        "description": "Represents a LoggedModel or Registered Model Version input to a Run."
      },
      "ModelOutput": {
        "type": "object",
        "properties": {
          "model_id": {
            "type": "string",
            "description": "The unique identifier of the model."
          },
          "step": {
            "type": "integer",
            "description": "The step at which the model was produced."
          }
        },
        "required": [
          "model_id",
          "step"
        ],
        "description": "Represents a LoggedModel output of a Run."
      },
      "ModelTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The tag key."
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        },
        "description": "Tag for a registered model"
      },
      "ModelVersion": {
        "type": "object",
        "properties": {
          "creation_timestamp": {
            "type": "integer"
          },
          "current_stage": {
            "type": "string",
            "description": "Current stage for this `model_version`."
          },
          "description": {
            "type": "string",
            "description": "Description of this `model_version`."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Timestamp recorded when metadata for this `model_version` was last updated."
          },
          "name": {
            "type": "string",
            "description": "Unique name of the model"
          },
          "run_id": {
            "type": "string",
            "description": "MLflow run ID used when creating `model_version`, if `source` was generated by an experiment run stored in MLflow tracking server."
          },
          "run_link": {
            "type": "string",
            "description": "Run Link: Direct link to the run that generated this version"
          },
          "source": {
            "type": "string",
            "description": "URI indicating the location of the source model artifacts, used when creating `model_version`"
          },
          "status": {
            "$ref": "#/components/schemas/ModelVersionStatus",
            "description": "Current status of `model_version`"
          },
          "status_message": {
            "type": "string",
            "description": "Details on current `status`, if it is pending or failed."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersionTag"
            },
            "description": "Tags: Additional metadata key-value pairs for this `model_version`."
          },
          "user_id": {
            "type": "string",
            "description": "User that created this `model_version`."
          },
          "version": {
            "type": "string",
            "description": "Model's version number."
          }
        }
      },
      "ModelVersionDatabricks": {
        "type": "object",
        "properties": {
          "creation_timestamp": {
            "type": "integer"
          },
          "current_stage": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "description": "User-specified description for the object."
          },
          "email_subscription_status": {
            "$ref": "#/components/schemas/RegistryEmailSubscriptionType",
            "description": "Email Subscription Status: This is the subscription status of the user to the model version Users get subscribed by interacting with the model version."
          },
          "feature_list": {
            "$ref": "#/components/schemas/FeatureList",
            "description": "Feature lineage of `model_version`."
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Time of the object at last update, as a Unix timestamp in milliseconds."
          },
          "name": {
            "type": "string",
            "description": "Name of the model."
          },
          "open_requests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Activity"
            },
            "description": "Open requests for this `model_versions`. Gap in sequence number is intentional and is done in order to match field sequence numbers of `ModelVersion` proto message"
          },
          "permission_level": {
            "$ref": "#/components/schemas/PermissionLevel"
          },
          "run_id": {
            "type": "string",
            "description": "Unique identifier for the MLflow tracking run associated with the source model artifacts."
          },
          "run_link": {
            "type": "string",
            "description": "URL of the run associated with the model artifacts. This field is set at model version creation time only for model versions whose source run is from a tracking server that is different from the registry server."
          },
          "source": {
            "type": "string",
            "description": "URI that indicates the location of the source model artifacts. This is used when creating the model version."
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "status_message": {
            "type": "string",
            "description": "Details on the current status, for example why registration failed."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersionTag"
            },
            "description": "Array of tags that are associated with the model version."
          },
          "user_id": {
            "type": "string",
            "description": "The username of the user that created the object."
          },
          "version": {
            "type": "string",
            "description": "Version of the model."
          }
        }
      },
      "ModelVersionTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        }
      },
      "OfflineStoreConfig": {
        "type": "object",
        "properties": {
          "catalog_name": {
            "type": "string",
            "description": "The Unity Catalog catalog name."
          },
          "schema_name": {
            "type": "string",
            "description": "The Unity Catalog schema name."
          },
          "table_name_prefix": {
            "type": "string",
            "description": "Prefix for Unity Catalog table name. The materialized feature will be stored in a table with this prefix and a generated postfix."
          }
        },
        "required": [
          "catalog_name",
          "schema_name",
          "table_name_prefix"
        ],
        "description": "Configuration for offline store destination."
      },
      "OnlineStore": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the online store. This is the unique identifier for the online store."
          },
          "capacity": {
            "type": "string",
            "description": "The capacity of the online store. Valid values are \"CU_1\", \"CU_2\", \"CU_4\", \"CU_8\"."
          },
          "creation_time": {
            "type": "string",
            "description": "The timestamp when the online store was created."
          },
          "creator": {
            "type": "string",
            "description": "The email of the creator of the online store."
          },
          "read_replica_count": {
            "type": "integer",
            "description": "The number of read replicas for the online store. Defaults to 0."
          },
          "state": {
            "$ref": "#/components/schemas/OnlineStoreState",
            "description": "The current state of the online store."
          },
          "usage_policy_id": {
            "type": "string",
            "description": "The usage policy applied to the online store to track billing."
          }
        },
        "required": [
          "name",
          "capacity"
        ],
        "description": "An OnlineStore is a logical database instance that stores and serves features online."
      },
      "OnlineStoreConfig": {
        "type": "object",
        "properties": {
          "catalog_name": {
            "type": "string",
            "description": "The Unity Catalog catalog name. This name is also used as the Lakebase logical database name."
          },
          "schema_name": {
            "type": "string",
            "description": "The Unity Catalog schema name."
          },
          "table_name_prefix": {
            "type": "string",
            "description": "Prefix for Unity Catalog table name. The materialized feature will be stored in a Lakebase table with this prefix and a generated postfix."
          },
          "online_store_name": {
            "type": "string",
            "description": "The name of the target online store."
          }
        },
        "required": [
          "catalog_name",
          "schema_name",
          "table_name_prefix",
          "online_store_name"
        ],
        "description": "Configuration for online store destination."
      },
      "Param": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Key identifying this param."
          },
          "value": {
            "type": "string",
            "description": "Value associated with this param."
          }
        },
        "description": "Param associated with a run."
      },
      "PublishSpec": {
        "type": "object",
        "properties": {
          "online_store": {
            "type": "string"
          },
          "online_table_name": {
            "type": "string",
            "description": "The full three-part (catalog, schema, table) name of the online table."
          },
          "publish_mode": {
            "$ref": "#/components/schemas/PublishSpecPublishMode",
            "description": "The publish mode of the pipeline that syncs the online table with the source table."
          }
        },
        "required": [
          "online_store",
          "online_table_name",
          "publish_mode"
        ]
      },
      "PublishTableResponse": {
        "type": "object",
        "properties": {
          "online_table_name": {
            "type": "string"
          },
          "pipeline_id": {
            "type": "string",
            "description": "The ID of the pipeline that syncs the online table with the source table."
          }
        }
      },
      "RegisteredModelAccessControlRequest": {
        "type": "object",
        "properties": {
          "group_name": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/RegisteredModelPermissionLevel"
          },
          "service_principal_name": {
            "type": "string",
            "description": "application ID of a service principal"
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "RegisteredModelAccessControlResponse": {
        "type": "object",
        "properties": {
          "all_permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelPermission"
            }
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the user or service principal."
          },
          "group_name": {
            "type": "string",
            "description": "name of the group"
          },
          "service_principal_name": {
            "type": "string",
            "description": "Name of the service principal."
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "RegisteredModelPermission": {
        "type": "object",
        "properties": {
          "inherited": {
            "type": "boolean"
          },
          "inherited_from_object": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "permission_level": {
            "$ref": "#/components/schemas/RegisteredModelPermissionLevel"
          }
        }
      },
      "RegisteredModelPermissions": {
        "type": "object",
        "properties": {
          "access_control_list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelAccessControlResponse"
            }
          },
          "object_id": {
            "type": "string"
          },
          "object_type": {
            "type": "string"
          }
        }
      },
      "RegisteredModelPermissionsDescription": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/RegisteredModelPermissionLevel"
          }
        }
      },
      "RegistryWebhook": {
        "type": "object",
        "properties": {
          "creation_timestamp": {
            "type": "integer"
          },
          "description": {
            "type": "string",
            "description": "User-specified description for the webhook."
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegistryWebhookEvent"
            },
            "description": "Events that can trigger a registry webhook: * `MODEL_VERSION_CREATED`: A new model version was created for the associated model. * `MODEL_VERSION_TRANSITIONED_STAGE`: A model version\u2019s stage was changed. * `TRANSITION_REQUEST_CREATED`: A user requested a model version\u2019s stage be transitioned. * `COMMENT_CREATED`: A user wrote a comment on a registered model. * `REGISTERED_MODEL_CREATED`: A new registered model was created. This event type can only be specified for a registry-wide webhook, which can be created by not specifying a model name in the create request. * `MODEL_VERSION_TAG_SET`: A user set a tag on the model version. * `MODEL_VERSION_TRANSITIONED_TO_STAGING`: A model version was transitioned to staging. * `MODEL_VERSION_TRANSITIONED_TO_PRODUCTION`: A model version was transitioned to production. * `MODEL_VERSION_TRANSITIONED_TO_ARCHIVED`: A model version was archived. * `TRANSITION_REQUEST_TO_STAGING_CREATED`: A user requested a model version be transitioned to staging. * `TRANSITION_REQUEST_TO_PRODUCTION_CREATED`: A user requested a model version be transitioned to production. * `TRANSITION_REQUEST_TO_ARCHIVED_CREATED`: A user requested a model version be archived."
          },
          "http_url_spec": {
            "$ref": "#/components/schemas/HttpUrlSpecWithoutSecret"
          },
          "id": {
            "type": "string",
            "description": "Webhook ID"
          },
          "job_spec": {
            "$ref": "#/components/schemas/JobSpecWithoutSecret"
          },
          "last_updated_timestamp": {
            "type": "integer",
            "description": "Time of the object at last update, as a Unix timestamp in milliseconds."
          },
          "model_name": {
            "type": "string",
            "description": "Name of the model whose events would trigger this webhook."
          },
          "status": {
            "$ref": "#/components/schemas/RegistryWebhookStatus"
          }
        }
      },
      "RejectTransitionRequestResponse": {
        "type": "object",
        "properties": {
          "activity": {
            "$ref": "#/components/schemas/Activity"
          }
        }
      },
      "RenameModelResponse": {
        "type": "object",
        "properties": {
          "registered_model": {
            "$ref": "#/components/schemas/Model"
          }
        }
      },
      "RestoreExperimentResponse": {
        "type": "object",
        "properties": {}
      },
      "RestoreRunResponse": {
        "type": "object",
        "properties": {}
      },
      "RestoreRunsResponse": {
        "type": "object",
        "properties": {
          "runs_restored": {
            "type": "integer"
          }
        }
      },
      "Run": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunData",
            "description": "Run data."
          },
          "info": {
            "$ref": "#/components/schemas/RunInfo",
            "description": "Run metadata."
          },
          "inputs": {
            "$ref": "#/components/schemas/RunInputs",
            "description": "Run inputs."
          }
        },
        "description": "A single run."
      },
      "RunData": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Metric"
            },
            "description": "Run metrics."
          },
          "params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Param"
            },
            "description": "Run parameters."
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RunTag"
            },
            "description": "Additional metadata key-value pairs."
          }
        },
        "description": "Run data (metrics, params, and tags)."
      },
      "RunInfo": {
        "type": "object",
        "properties": {
          "artifact_uri": {
            "type": "string",
            "description": "URI of the directory where artifacts should be uploaded. This can be a local path (starting with \"/\"), or a distributed file system (DFS) path, like ``s3://bucket/directory`` or ``dbfs:/my/directory``. If not set, the local ``./mlruns`` directory is chosen."
          },
          "end_time": {
            "type": "integer",
            "description": "Unix timestamp of when the run ended in milliseconds."
          },
          "experiment_id": {
            "type": "string",
            "description": "The experiment ID."
          },
          "lifecycle_stage": {
            "type": "string",
            "description": "Current life cycle stage of the experiment : OneOf(\"active\", \"deleted\")"
          },
          "run_id": {
            "type": "string",
            "description": "Unique identifier for the run."
          },
          "run_name": {
            "type": "string",
            "description": "The name of the run."
          },
          "run_uuid": {
            "type": "string",
            "description": "[Deprecated, use run_id instead] Unique identifier for the run. This field will be removed in a future MLflow version."
          },
          "start_time": {
            "type": "integer",
            "description": "Unix timestamp of when the run started in milliseconds."
          },
          "status": {
            "$ref": "#/components/schemas/RunInfoStatus",
            "description": "Current status of the run."
          },
          "user_id": {
            "type": "string",
            "description": "User who initiated the run. This field is deprecated as of MLflow 1.0, and will be removed in a future MLflow release. Use 'mlflow.user' tag instead."
          }
        },
        "description": "Metadata of a single run."
      },
      "RunInputs": {
        "type": "object",
        "properties": {
          "dataset_inputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DatasetInput"
            },
            "description": "Run metrics."
          },
          "model_inputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelInput"
            },
            "description": "Model inputs to the Run."
          }
        },
        "description": "Run inputs."
      },
      "RunTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The tag key."
          },
          "value": {
            "type": "string",
            "description": "The tag value."
          }
        },
        "description": "Tag for a run."
      },
      "SchemaConfig": {
        "type": "object",
        "properties": {
          "json_schema": {
            "type": "string"
          }
        }
      },
      "SearchExperimentsResponse": {
        "type": "object",
        "properties": {
          "experiments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Experiment"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Token that can be used to retrieve the next page of experiments. An empty token means that no more experiments are available for retrieval."
          }
        }
      },
      "SearchLoggedModelsDataset": {
        "type": "object",
        "properties": {
          "dataset_name": {
            "type": "string"
          },
          "dataset_digest": {
            "type": "string",
            "description": "The digest of the dataset."
          }
        },
        "required": [
          "dataset_name"
        ]
      },
      "SearchLoggedModelsOrderBy": {
        "type": "object",
        "properties": {
          "field_name": {
            "type": "string"
          },
          "ascending": {
            "type": "boolean",
            "description": "Whether the search results order is ascending or not."
          },
          "dataset_digest": {
            "type": "string",
            "description": "If ``field_name`` refers to a metric, this field specifies the digest of the dataset associated with the metric. Only metrics associated with the specified dataset name and digest will be considered for ordering. This field may only be set if ``dataset_name`` is also set."
          },
          "dataset_name": {
            "type": "string",
            "description": "If ``field_name`` refers to a metric, this field specifies the name of the dataset associated with the metric. Only metrics associated with the specified dataset name will be considered for ordering. This field may only be set if ``field_name`` refers to a metric."
          }
        },
        "required": [
          "field_name"
        ]
      },
      "SearchLoggedModelsResponse": {
        "type": "object",
        "properties": {
          "models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoggedModel"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "The token that can be used to retrieve the next page of logged models."
          }
        }
      },
      "SearchModelVersionsResponse": {
        "type": "object",
        "properties": {
          "model_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersion"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token to request next page of models for the same search query."
          }
        }
      },
      "SearchModelsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "registered_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model"
            },
            "description": "Registered Models that match the search criteria."
          }
        }
      },
      "SearchRunsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "runs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Run"
            },
            "description": "Runs that match the search criteria."
          }
        }
      },
      "SetExperimentTagResponse": {
        "type": "object",
        "properties": {}
      },
      "SetLoggedModelTagsResponse": {
        "type": "object",
        "properties": {}
      },
      "SetModelTagResponse": {
        "type": "object",
        "properties": {}
      },
      "SetModelVersionTagResponse": {
        "type": "object",
        "properties": {}
      },
      "SetTagResponse": {
        "type": "object",
        "properties": {}
      },
      "SlidingWindow": {
        "type": "object",
        "properties": {
          "window_duration": {
            "type": "string"
          },
          "slide_duration": {
            "type": "string",
            "description": "The slide duration (interval by which windows advance, must be positive and less than duration)."
          }
        },
        "required": [
          "window_duration",
          "slide_duration"
        ]
      },
      "SubscriptionMode": {
        "type": "object",
        "properties": {
          "assign": {
            "type": "string"
          },
          "subscribe": {
            "type": "string",
            "description": "A comma-separated list of Kafka topics to read from. For example, 'topicA,topicB,topicC'."
          },
          "subscribe_pattern": {
            "type": "string",
            "description": "A regular expression matching topics to subscribe to. For example, 'topic.*' will subscribe to all topics starting with 'topic'."
          }
        }
      },
      "TestRegistryWebhookResponse": {
        "type": "object",
        "properties": {
          "body": {
            "type": "string"
          },
          "status_code": {
            "type": "integer",
            "description": "Status code returned by the webhook URL"
          }
        }
      },
      "TimeWindow": {
        "type": "object",
        "properties": {
          "continuous": {
            "$ref": "#/components/schemas/ContinuousWindow"
          },
          "sliding": {
            "$ref": "#/components/schemas/SlidingWindow"
          },
          "tumbling": {
            "$ref": "#/components/schemas/TumblingWindow"
          }
        }
      },
      "TransitionRequest": {
        "type": "object",
        "properties": {
          "available_actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityAction"
            },
            "description": "Array of actions on the activity allowed for the current viewer."
          },
          "comment": {
            "type": "string",
            "description": "User-provided comment associated with the activity, comment, or transition request."
          },
          "creation_timestamp": {
            "type": "integer",
            "description": "Creation time of the object, as a Unix timestamp in milliseconds."
          },
          "to_stage": {
            "type": "string",
            "description": "Target stage of the transition (if the activity is stage transition related). Valid values are: * `None`: The initial stage of a model version. * `Staging`: Staging or pre-production stage. * `Production`: Production stage. * `Archived`: Archived stage."
          },
          "user_id": {
            "type": "string",
            "description": "The username of the user that created the object."
          }
        },
        "description": "For activities, this contains the activity recorded for the action. For comments, this contains\n    the comment details. For transition requests, this contains the transition request details."
      },
      "TransitionStageResponse": {
        "type": "object",
        "properties": {
          "model_version_databricks": {
            "$ref": "#/components/schemas/ModelVersionDatabricks"
          }
        }
      },
      "TumblingWindow": {
        "type": "object",
        "properties": {
          "window_duration": {
            "type": "string"
          }
        },
        "required": [
          "window_duration"
        ]
      },
      "UpdateCommentResponse": {
        "type": "object",
        "properties": {
          "comment": {
            "$ref": "#/components/schemas/CommentObject"
          }
        }
      },
      "UpdateExperimentResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateModelResponse": {
        "type": "object",
        "properties": {
          "registered_model": {
            "$ref": "#/components/schemas/Model"
          }
        }
      },
      "UpdateModelVersionResponse": {
        "type": "object",
        "properties": {
          "model_version": {
            "$ref": "#/components/schemas/ModelVersion"
          }
        }
      },
      "UpdateRunResponse": {
        "type": "object",
        "properties": {
          "run_info": {
            "$ref": "#/components/schemas/RunInfo"
          }
        }
      },
      "UpdateWebhookResponse": {
        "type": "object",
        "properties": {
          "webhook": {
            "$ref": "#/components/schemas/RegistryWebhook"
          }
        }
      },
      "ActivityAction": {
        "type": "string",
        "enum": [
          "APPROVE_TRANSITION_REQUEST",
          "CANCEL_TRANSITION_REQUEST",
          "DELETE_COMMENT",
          "EDIT_COMMENT",
          "REJECT_TRANSITION_REQUEST"
        ],
        "description": "An action that a user (with sufficient permissions) could take on an activity or comment.\n\nFor activities, valid values are: * `APPROVE_TRANSITION_REQUEST`: Approve a transition request\n\n* `REJECT_TRANSITION_REQUEST`: Reject a transition request\n\n* `CANCEL_TRANSITION_REQUEST`: Cancel (delete) a transition request\n\nFor comments, valid values are: * `EDIT_COMMENT`: Edit the comment\n\n* `DELETE_COMMENT`: Delete the comment"
      },
      "ActivityType": {
        "type": "string",
        "enum": [
          "APPLIED_TRANSITION",
          "APPROVED_REQUEST",
          "CANCELLED_REQUEST",
          "NEW_COMMENT",
          "REJECTED_REQUEST",
          "REQUESTED_TRANSITION",
          "SYSTEM_TRANSITION"
        ],
        "description": "Type of activity. Valid values are: * `APPLIED_TRANSITION`: User applied the corresponding stage\ntransition.\n\n* `REQUESTED_TRANSITION`: User requested the corresponding stage transition.\n\n* `CANCELLED_REQUEST`: User cancelled an existing transition request.\n\n* `APPROVED_REQUEST`: User approved the corresponding stage transition.\n\n* `REJECTED_REQUEST`: User rejected the coressponding stage transition.\n\n* `SYSTEM_TRANSITION`: For events performed as a side effect, such as archiving existing model\nversions in a stage."
      },
      "CommentActivityAction": {
        "type": "string",
        "enum": [
          "APPROVE_TRANSITION_REQUEST",
          "CANCEL_TRANSITION_REQUEST",
          "DELETE_COMMENT",
          "EDIT_COMMENT",
          "REJECT_TRANSITION_REQUEST"
        ],
        "description": "An action that a user (with sufficient permissions) could take on an activity or comment.\n\nFor activities, valid values are: * `APPROVE_TRANSITION_REQUEST`: Approve a transition request\n\n* `REJECT_TRANSITION_REQUEST`: Reject a transition request\n\n* `CANCEL_TRANSITION_REQUEST`: Cancel (delete) a transition request\n\nFor comments, valid values are: * `EDIT_COMMENT`: Edit the comment\n\n* `DELETE_COMMENT`: Delete the comment"
      },
      "ExperimentPermissionLevel": {
        "type": "string",
        "enum": [
          "CAN_EDIT",
          "CAN_MANAGE",
          "CAN_READ"
        ],
        "description": "Permission level"
      },
      "ForecastingExperimentState": {
        "type": "string",
        "enum": [
          "CANCELLED",
          "FAILED",
          "PENDING",
          "RUNNING",
          "SUCCEEDED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionFunctionType": {
        "type": "string",
        "enum": [
          "APPROX_COUNT_DISTINCT",
          "APPROX_PERCENTILE",
          "AVG",
          "COUNT",
          "FIRST",
          "LAST",
          "MAX",
          "MIN",
          "STDDEV_POP",
          "STDDEV_SAMP",
          "SUM",
          "VAR_POP",
          "VAR_SAMP"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "LoggedModelStatus": {
        "type": "string",
        "enum": [
          "LOGGED_MODEL_PENDING",
          "LOGGED_MODEL_READY",
          "LOGGED_MODEL_UPLOAD_FAILED"
        ],
        "description": "A LoggedModelStatus enum value represents the status of a logged model."
      },
      "MaterializedFeaturePipelineScheduleState": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "PAUSED",
          "SNAPSHOT"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ModelVersionStatus": {
        "type": "string",
        "enum": [
          "FAILED_REGISTRATION",
          "PENDING_REGISTRATION",
          "READY"
        ],
        "description": "The status of the model version. Valid values are: * `PENDING_REGISTRATION`: Request to register\na new model version is pending as server performs background tasks.\n\n* `FAILED_REGISTRATION`: Request to register a new model version has failed.\n\n* `READY`: Model version is ready for use."
      },
      "OnlineStoreState": {
        "type": "string",
        "enum": [
          "AVAILABLE",
          "DELETING",
          "FAILING_OVER",
          "STARTING",
          "STOPPED",
          "UPDATING"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PermissionLevel": {
        "type": "string",
        "enum": [
          "CAN_CREATE_REGISTERED_MODEL",
          "CAN_EDIT",
          "CAN_MANAGE",
          "CAN_MANAGE_PRODUCTION_VERSIONS",
          "CAN_MANAGE_STAGING_VERSIONS",
          "CAN_READ"
        ],
        "description": "Permission level of the requesting user on the object. For what is allowed at each level, see\n[MLflow Model permissions](..)."
      },
      "PublishSpecPublishMode": {
        "type": "string",
        "enum": [
          "CONTINUOUS",
          "SNAPSHOT",
          "TRIGGERED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "RegisteredModelPermissionLevel": {
        "type": "string",
        "enum": [
          "CAN_EDIT",
          "CAN_MANAGE",
          "CAN_MANAGE_PRODUCTION_VERSIONS",
          "CAN_MANAGE_STAGING_VERSIONS",
          "CAN_READ"
        ],
        "description": "Permission level"
      },
      "RegistryEmailSubscriptionType": {
        "type": "string",
        "enum": [
          "ALL_EVENTS",
          "DEFAULT",
          "SUBSCRIBED",
          "UNSUBSCRIBED"
        ],
        "description": ".. note:: Experimental: This entity may change or be removed in a future release without\nwarning. Email subscription types for registry notifications: - `ALL_EVENTS`: Subscribed to all\nevents. - `DEFAULT`: Default subscription type. - `SUBSCRIBED`: Subscribed to notifications. -\n`UNSUBSCRIBED`: Not subscribed to notifications."
      },
      "RegistryWebhookEvent": {
        "type": "string",
        "enum": [
          "COMMENT_CREATED",
          "MODEL_VERSION_CREATED",
          "MODEL_VERSION_TAG_SET",
          "MODEL_VERSION_TRANSITIONED_STAGE",
          "MODEL_VERSION_TRANSITIONED_TO_ARCHIVED",
          "MODEL_VERSION_TRANSITIONED_TO_PRODUCTION",
          "MODEL_VERSION_TRANSITIONED_TO_STAGING",
          "REGISTERED_MODEL_CREATED",
          "TRANSITION_REQUEST_CREATED",
          "TRANSITION_REQUEST_TO_ARCHIVED_CREATED",
          "TRANSITION_REQUEST_TO_PRODUCTION_CREATED",
          "TRANSITION_REQUEST_TO_STAGING_CREATED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "RegistryWebhookStatus": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "DISABLED",
          "TEST_MODE"
        ],
        "description": "Enable or disable triggering the webhook, or put the webhook into test mode. The default is\n`ACTIVE`: * `ACTIVE`: Webhook is triggered when an associated event happens.\n\n* `DISABLED`: Webhook is not triggered.\n\n* `TEST_MODE`: Webhook can be triggered through the test endpoint, but is not triggered on a\nreal event."
      },
      "RunInfoStatus": {
        "type": "string",
        "enum": [
          "FAILED",
          "FINISHED",
          "KILLED",
          "RUNNING",
          "SCHEDULED"
        ],
        "description": "Status of a run."
      },
      "Status": {
        "type": "string",
        "enum": [
          "FAILED_REGISTRATION",
          "PENDING_REGISTRATION",
          "READY"
        ],
        "description": "The status of the model version. Valid values are: * `PENDING_REGISTRATION`: Request to register\na new model version is pending as server performs background tasks.\n\n* `FAILED_REGISTRATION`: Request to register a new model version has failed.\n\n* `READY`: Model version is ready for use."
      },
      "UpdateRunStatus": {
        "type": "string",
        "enum": [
          "FAILED",
          "FINISHED",
          "KILLED",
          "RUNNING",
          "SCHEDULED"
        ],
        "description": "Status of a run."
      },
      "ViewType": {
        "type": "string",
        "enum": [
          "ACTIVE_ONLY",
          "ALL",
          "DELETED_ONLY"
        ],
        "description": "Qualifier for the view type."
      }
    }
  }
}