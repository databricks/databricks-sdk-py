{
  "openapi": "3.0.0",
  "info": {
    "title": "Databricks Catalog API (workspace)",
    "description": "OpenAPI specification for the Databricks catalog service (workspace-level APIs), generated from the Databricks Python SDK.",
    "version": "0.1.0"
  },
  "servers": [
    {
      "url": "https://{workspace}.cloud.databricks.com",
      "description": "Databricks workspace",
      "variables": {
        "workspace": {
          "default": "your-workspace",
          "description": "Your Databricks workspace name"
        }
      }
    }
  ],
  "paths": {
    "/api/2.1/unity-catalog/artifact-allowlists/{artifact_type.value}": {
      "get": {
        "operationId": "artifact_allowlists_get",
        "summary": "Get the artifact allowlist of a certain artifact type. The caller must be a metastore admin or have",
        "tags": [
          "catalog",
          "artifact_allowlists"
        ],
        "description": "Get the artifact allowlist of a certain artifact type. The caller must be a metastore admin or have\nthe **MANAGE ALLOWLIST** privilege on the metastore.\n\n:param artifact_type: :class:`ArtifactType`\n  The artifact type of the allowlist.\n\n:returns: :class:`ArtifactAllowlistInfo`",
        "parameters": [
          {
            "name": "artifact_type.value",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "artifact_type",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The artifact type of the allowlist."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactAllowlistInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "artifact_allowlists_update",
        "summary": "Set the artifact allowlist of a certain artifact type. The whole artifact allowlist is replaced with",
        "tags": [
          "catalog",
          "artifact_allowlists"
        ],
        "description": "Set the artifact allowlist of a certain artifact type. The whole artifact allowlist is replaced with\nthe new allowlist. The caller must be a metastore admin or have the **MANAGE ALLOWLIST** privilege on\nthe metastore.\n\n:param artifact_type: :class:`ArtifactType`\n  The artifact type of the allowlist.\n:param artifact_matchers: List[:class:`ArtifactMatcher`]\n  A list of allowed artifact match patterns.\n:param created_at: int (optional)\n  Time at which this artifact allowlist was set, in epoch milliseconds.\n:param created_by: str (optional)\n  Username of the user who set the artifact allowlist.\n:param metastore_id: str (optional)\n  Unique identifier of parent metastore.\n\n:returns: :class:`ArtifactAllowlistInfo`",
        "parameters": [
          {
            "name": "artifact_type.value",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "artifact_type": {
                    "type": "string",
                    "description": "The artifact type of the allowlist."
                  },
                  "artifact_matchers": {
                    "type": "string",
                    "description": "A list of allowed artifact match patterns."
                  },
                  "created_at": {
                    "type": "string",
                    "description": "Time at which this artifact allowlist was set, in epoch milliseconds."
                  },
                  "created_by": {
                    "type": "string",
                    "description": "Username of the user who set the artifact allowlist."
                  },
                  "metastore_id": {
                    "type": "string",
                    "description": "Unique identifier of parent metastore."
                  }
                },
                "required": [
                  "artifact_type",
                  "artifact_matchers"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactAllowlistInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/catalogs": {
      "post": {
        "operationId": "catalogs_create",
        "summary": "Creates a new catalog instance in the parent metastore if the caller is a metastore admin or has the",
        "tags": [
          "catalog",
          "catalogs"
        ],
        "description": "Creates a new catalog instance in the parent metastore if the caller is a metastore admin or has the\n**CREATE_CATALOG** privilege.\n\n:param name: str\n  Name of catalog.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param connection_name: str (optional)\n  The name of the connection to an external data source.\n:param options: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n:param provider_name: str (optional)\n  The name of delta sharing provider.\n\n  A Delta Sharing catalog is a catalog that is based on a Delta share on a remote sharing server.\n:param share_name: str (optional)\n  The name of the share under the share provider.\n:param storage_root: str (optional)\n  Storage root URL for managed tables within catalog.\n\n:returns: :class:`CatalogInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of catalog."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "connection_name": {
                    "type": "string",
                    "description": "The name of the connection to an external data source."
                  },
                  "options": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "provider_name": {
                    "type": "string",
                    "description": "The name of delta sharing provider. A Delta Sharing catalog is a catalog that is based on a Delta share on a remote sharing server."
                  },
                  "share_name": {
                    "type": "string",
                    "description": "The name of the share under the share provider."
                  },
                  "storage_root": {
                    "type": "string",
                    "description": "Storage root URL for managed tables within catalog."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "catalogs_list",
        "summary": "Gets an array of catalogs in the metastore. If the caller is the metastore admin, all catalogs will be",
        "tags": [
          "catalog",
          "catalogs"
        ],
        "description": "Gets an array of catalogs in the metastore. If the caller is the metastore admin, all catalogs will be\nretrieved. Otherwise, only catalogs owned by the caller (or for which the caller has the\n**USE_CATALOG** privilege) will be retrieved. There is no guarantee of a specific ordering of the\nelements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param include_browse: bool (optional)\n  Whether to include catalogs in the response for which the principal can only access selective\n  metadata for\n:param include_unbound: bool (optional)\n  Whether to include catalogs not bound to the workspace. Effective only if the user has permission to\n  update the catalog\u2013workspace binding.\n:param max_results: int (optional)\n  Maximum number of catalogs to return. - when set to 0, the page length is set to a server configured\n  value (recommended); - when set to a value greater than 0, the page length is the minimum of this\n  value and a server configured value; - when set to a value less than 0, an invalid parameter error\n  is returned; - If not set, all valid catalogs are returned (not recommended). - Note: The number of\n  returned catalogs might be less than the specified max_results size, even zero. The only definitive\n  indication that no further catalogs can be fetched is when the next_page_token is unset from the\n  response.\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`CatalogInfo`",
        "parameters": [
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include catalogs in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "include_unbound",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include catalogs not bound to the workspace. Effective only if the user has permission to update the catalog\u2013workspace binding."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of catalogs to return. - when set to 0, the page length is set to a server configured value (recommended); - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to a value less than 0, an invalid parameter error is returned; - If not set, all valid catalogs are returned (not recommended). - Note: The number of returned catalogs might be less than the specified max_results size, even zero. The only definitive indication that no further catalogs can be fetched is when the next_page_token is unset from the response."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/catalogs/{name}": {
      "delete": {
        "operationId": "catalogs_delete",
        "summary": "Deletes the catalog that matches the supplied name. The caller must be a metastore admin or the owner",
        "tags": [
          "catalog",
          "catalogs"
        ],
        "description": "Deletes the catalog that matches the supplied name. The caller must be a metastore admin or the owner\nof the catalog.\n\n:param name: str\n  The name of the catalog.\n:param force: bool (optional)\n  Force deletion even if the catalog is not empty.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the catalog."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force deletion even if the catalog is not empty."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "catalogs_get",
        "summary": "Gets the specified catalog in a metastore. The caller must be a metastore admin, the owner of the",
        "tags": [
          "catalog",
          "catalogs"
        ],
        "description": "Gets the specified catalog in a metastore. The caller must be a metastore admin, the owner of the\ncatalog, or a user that has the **USE_CATALOG** privilege set for their account.\n\n:param name: str\n  The name of the catalog.\n:param include_browse: bool (optional)\n  Whether to include catalogs in the response for which the principal can only access selective\n  metadata for\n\n:returns: :class:`CatalogInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the catalog."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include catalogs in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "catalogs_update",
        "summary": "Updates the catalog that matches the supplied name. The caller must be either the owner of the",
        "tags": [
          "catalog",
          "catalogs"
        ],
        "description": "Updates the catalog that matches the supplied name. The caller must be either the owner of the\ncatalog, or a metastore admin (when changing the owner field of the catalog).\n\n:param name: str\n  The name of the catalog.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param enable_predictive_optimization: :class:`EnablePredictiveOptimization` (optional)\n  Whether predictive optimization should be enabled for this object and objects under it.\n:param isolation_mode: :class:`CatalogIsolationMode` (optional)\n  Whether the current securable is accessible from all workspaces or a specific set of workspaces.\n:param new_name: str (optional)\n  New name for the catalog.\n:param options: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n:param owner: str (optional)\n  Username of current owner of catalog.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n\n:returns: :class:`CatalogInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the catalog."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "enable_predictive_optimization": {
                    "type": "string",
                    "description": "Whether predictive optimization should be enabled for this object and objects under it."
                  },
                  "isolation_mode": {
                    "type": "string",
                    "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the catalog."
                  },
                  "options": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of catalog."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/connections": {
      "post": {
        "operationId": "connections_create",
        "summary": "Creates a new connection",
        "tags": [
          "catalog",
          "connections"
        ],
        "description": "Creates a new connection\n\nCreates a new connection to an external data source. It allows users to specify connection details and\nconfigurations for interaction with the external server.\n\n:param name: str\n  Name of the connection.\n:param connection_type: :class:`ConnectionType`\n  The type of connection.\n:param options: Dict[str,str]\n  A map of key-value properties attached to the securable.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n:param read_only: bool (optional)\n  If the connection is read only.\n\n:returns: :class:`ConnectionInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the connection."
                  },
                  "connection_type": {
                    "type": "string",
                    "description": "The type of connection."
                  },
                  "options": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "If the connection is read only."
                  }
                },
                "required": [
                  "name",
                  "connection_type",
                  "options"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "connections_list",
        "summary": "List all connections.",
        "tags": [
          "catalog",
          "connections"
        ],
        "description": "List all connections.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param max_results: int (optional)\n  Maximum number of connections to return. - If not set, all connections are returned (not\n  recommended). - when set to a value greater than 0, the page length is the minimum of this value and\n  a server configured value; - when set to 0, the page length is set to a server configured value\n  (recommended); - when set to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`ConnectionInfo`",
        "parameters": [
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of connections to return. - If not set, all connections are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/connections/{name}": {
      "delete": {
        "operationId": "connections_delete",
        "summary": "Deletes the connection that matches the supplied name.",
        "tags": [
          "catalog",
          "connections"
        ],
        "description": "Deletes the connection that matches the supplied name.\n\n:param name: str\n  The name of the connection to be deleted.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the connection to be deleted."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "connections_get",
        "summary": "Gets a connection from it's name.",
        "tags": [
          "catalog",
          "connections"
        ],
        "description": "Gets a connection from it's name.\n\n:param name: str\n  Name of the connection.\n\n:returns: :class:`ConnectionInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the connection."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "connections_update",
        "summary": "Updates the connection that matches the supplied name.",
        "tags": [
          "catalog",
          "connections"
        ],
        "description": "Updates the connection that matches the supplied name.\n\n:param name: str\n  Name of the connection.\n:param options: Dict[str,str]\n  A map of key-value properties attached to the securable.\n:param new_name: str (optional)\n  New name for the connection.\n:param owner: str (optional)\n  Username of current owner of the connection.\n\n:returns: :class:`ConnectionInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the connection."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "options": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the connection."
                  },
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of the connection."
                  }
                },
                "required": [
                  "options"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/entity-tag-assignments": {
      "post": {
        "operationId": "entity_tag_assignments_create",
        "summary": "Creates a tag assignment for an Unity Catalog entity.",
        "tags": [
          "catalog",
          "entity_tag_assignments"
        ],
        "description": "Creates a tag assignment for an Unity Catalog entity.\n\nTo add tags to Unity Catalog entities, you must own the entity or have the following privileges: -\n**APPLY TAG** on the entity - **USE SCHEMA** on the entity's parent schema - **USE CATALOG** on the\nentity's parent catalog\n\nTo add a governed tag to Unity Catalog entities, you must also have the **ASSIGN** or **MANAGE**\npermission on the tag policy. See [Manage tag policy permissions].\n\n[Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions\n\n:param tag_assignment: :class:`EntityTagAssignment`\n\n:returns: :class:`EntityTagAssignment`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tag_assignment": {
                    "type": "string",
                    "description": ":returns: :class:`EntityTagAssignment`"
                  }
                },
                "required": [
                  "tag_assignment"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityTagAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/entity-tag-assignments/{entity_type}/{entity_name}/tags/{tag_key}": {
      "delete": {
        "operationId": "entity_tag_assignments_delete",
        "summary": "Deletes a tag assignment for an Unity Catalog entity by its key.",
        "tags": [
          "catalog",
          "entity_tag_assignments"
        ],
        "description": "Deletes a tag assignment for an Unity Catalog entity by its key.\n\nTo delete tags from Unity Catalog entities, you must own the entity or have the following privileges:\n- **APPLY TAG** on the entity - **USE_SCHEMA** on the entity's parent schema - **USE_CATALOG** on the\nentity's parent catalog\n\nTo delete a governed tag from Unity Catalog entities, you must also have the **ASSIGN** or **MANAGE**\npermission on the tag policy. See [Manage tag policy permissions].\n\n[Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions\n\n:param entity_type: str\n  The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables,\n  columns, volumes.\n:param entity_name: str\n  The fully qualified name of the entity to which the tag is assigned\n:param tag_key: str\n  Required. The key of the tag to delete",
        "parameters": [
          {
            "name": "entity_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          {
            "name": "entity_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          {
            "name": "tag_key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The key of the tag to delete"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "entity_tag_assignments_get",
        "summary": "Gets a tag assignment for an Unity Catalog entity by tag key.",
        "tags": [
          "catalog",
          "entity_tag_assignments"
        ],
        "description": "Gets a tag assignment for an Unity Catalog entity by tag key.\n\n:param entity_type: str\n  The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables,\n  columns, volumes.\n:param entity_name: str\n  The fully qualified name of the entity to which the tag is assigned\n:param tag_key: str\n  Required. The key of the tag\n\n:returns: :class:`EntityTagAssignment`",
        "parameters": [
          {
            "name": "entity_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          {
            "name": "entity_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          {
            "name": "tag_key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The key of the tag"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityTagAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "entity_tag_assignments_update",
        "summary": "Updates an existing tag assignment for an Unity Catalog entity.",
        "tags": [
          "catalog",
          "entity_tag_assignments"
        ],
        "description": "Updates an existing tag assignment for an Unity Catalog entity.\n\nTo update tags to Unity Catalog entities, you must own the entity or have the following privileges: -\n**APPLY TAG** on the entity - **USE SCHEMA** on the entity's parent schema - **USE CATALOG** on the\nentity's parent catalog\n\nTo update a governed tag to Unity Catalog entities, you must also have the **ASSIGN** or **MANAGE**\npermission on the tag policy. See [Manage tag policy permissions].\n\n[Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions\n\n:param entity_type: str\n  The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables,\n  columns, volumes.\n:param entity_name: str\n  The fully qualified name of the entity to which the tag is assigned\n:param tag_key: str\n  The key of the tag\n:param tag_assignment: :class:`EntityTagAssignment`\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n\n:returns: :class:`EntityTagAssignment`",
        "parameters": [
          {
            "name": "entity_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          {
            "name": "entity_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          {
            "name": "tag_key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key of the tag"
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tag_assignment": {
                    "type": "string",
                    "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
                  }
                },
                "required": [
                  "tag_assignment"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityTagAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/entity-tag-assignments/{entity_type}/{entity_name}/tags": {
      "get": {
        "operationId": "entity_tag_assignments_list",
        "summary": "List tag assignments for an Unity Catalog entity",
        "tags": [
          "catalog",
          "entity_tag_assignments"
        ],
        "description": "List tag assignments for an Unity Catalog entity\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param entity_type: str\n  The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables,\n  columns, volumes.\n:param entity_name: str\n  The fully qualified name of the entity to which the tag is assigned\n:param max_results: int (optional)\n  Optional. Maximum number of tag assignments to return in a single page\n:param page_token: str (optional)\n  Optional. Pagination token to retrieve the next page of results\n\n:returns: Iterator over :class:`EntityTagAssignment`",
        "parameters": [
          {
            "name": "entity_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          {
            "name": "entity_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. Maximum number of tag assignments to return in a single page"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. Pagination token to retrieve the next page of results"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityTagAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/lineage-tracking/external-lineage": {
      "post": {
        "operationId": "external_lineage_create_external_lineage_relationship",
        "summary": "Creates an external lineage relationship between a Databricks or external metadata object and another",
        "tags": [
          "catalog",
          "external_lineage"
        ],
        "description": "Creates an external lineage relationship between a Databricks or external metadata object and another\nexternal metadata object.\n\n:param external_lineage_relationship: :class:`CreateRequestExternalLineage`\n\n:returns: :class:`ExternalLineageRelationship`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "external_lineage_relationship": {
                    "type": "string",
                    "description": ":returns: :class:`ExternalLineageRelationship`"
                  }
                },
                "required": [
                  "external_lineage_relationship"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLineageRelationship"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "external_lineage_delete_external_lineage_relationship",
        "summary": "Deletes an external lineage relationship between a Databricks or external metadata object and another",
        "tags": [
          "catalog",
          "external_lineage"
        ],
        "description": "Deletes an external lineage relationship between a Databricks or external metadata object and another\nexternal metadata object.\n\n:param external_lineage_relationship: :class:`DeleteRequestExternalLineage`",
        "parameters": [
          {
            "name": "external_lineage_relationship",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":class:`DeleteRequestExternalLineage`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "external_lineage_list_external_lineage_relationships",
        "summary": "Lists external lineage relationships of a Databricks object or external metadata given a supplied",
        "tags": [
          "catalog",
          "external_lineage"
        ],
        "description": "Lists external lineage relationships of a Databricks object or external metadata given a supplied\ndirection.\n\n:param object_info: :class:`ExternalLineageObject`\n  The object to query external lineage relationships for. Since this field is a query parameter,\n  please flatten the nested fields. For example, if the object is a table, the query parameter should\n  look like: `object_info.table.name=main.sales.customers`\n:param lineage_direction: :class:`LineageDirection`\n  The lineage direction to filter on.\n:param page_size: int (optional)\n  Specifies the maximum number of external lineage relationships to return in a single response. The\n  value must be less than or equal to 1000.\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`ExternalLineageInfo`",
        "parameters": [
          {
            "name": "object_info",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The object to query external lineage relationships for. Since this field is a query parameter, please flatten the nested fields. For example, if the object is a table, the query parameter should look like: `object_info.table.name=main.sales.customers`"
          },
          {
            "name": "lineage_direction",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The lineage direction to filter on."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Specifies the maximum number of external lineage relationships to return in a single response. The value must be less than or equal to 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLineageInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "external_lineage_update_external_lineage_relationship",
        "summary": "Updates an external lineage relationship between a Databricks or external metadata object and another",
        "tags": [
          "catalog",
          "external_lineage"
        ],
        "description": "Updates an external lineage relationship between a Databricks or external metadata object and another\nexternal metadata object.\n\n:param external_lineage_relationship: :class:`UpdateRequestExternalLineage`\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n\n:returns: :class:`ExternalLineageRelationship`",
        "parameters": [
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "external_lineage_relationship": {
                    "type": "string",
                    "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
                  }
                },
                "required": [
                  "external_lineage_relationship"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLineageRelationship"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/external-locations": {
      "post": {
        "operationId": "external_locations_create",
        "summary": "Creates a new external location entry in the metastore. The caller must be a metastore admin or have",
        "tags": [
          "catalog",
          "external_locations"
        ],
        "description": "Creates a new external location entry in the metastore. The caller must be a metastore admin or have\nthe **CREATE_EXTERNAL_LOCATION** privilege on both the metastore and the associated storage\ncredential.\n\n:param name: str\n  Name of the external location.\n:param url: str\n  Path URL of the external location.\n:param credential_name: str\n  Name of the storage credential used with this location.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param enable_file_events: bool (optional)\n  Whether to enable file events on this external location. Default to `true`. Set to `false` to\n  disable file events.\n:param encryption_details: :class:`EncryptionDetails` (optional)\n:param fallback: bool (optional)\n  Indicates whether fallback mode is enabled for this external location. When fallback mode is\n  enabled, the access to the location falls back to cluster credentials if UC credentials are not\n  sufficient.\n:param file_event_queue: :class:`FileEventQueue` (optional)\n  File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly\n  one of the documented properties.\n:param read_only: bool (optional)\n  Indicates whether the external location is read-only.\n:param skip_validation: bool (optional)\n  Skips validation of the storage credential associated with the external location.\n\n:returns: :class:`ExternalLocationInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the external location."
                  },
                  "url": {
                    "type": "string",
                    "description": "Path URL of the external location."
                  },
                  "credential_name": {
                    "type": "string",
                    "description": "Name of the storage credential used with this location."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "enable_file_events": {
                    "type": "string",
                    "description": "Whether to enable file events on this external location. Default to `true`. Set to `false` to disable file events."
                  },
                  "encryption_details": {
                    "type": "string",
                    "description": ":param fallback: bool (optional) Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled, the access to the location falls back to cluster credentials if UC credentials are not sufficient."
                  },
                  "fallback": {
                    "type": "string"
                  },
                  "file_event_queue": {
                    "type": "string",
                    "description": "File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly one of the documented properties."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "Indicates whether the external location is read-only."
                  },
                  "skip_validation": {
                    "type": "string",
                    "description": "Skips validation of the storage credential associated with the external location."
                  }
                },
                "required": [
                  "name",
                  "url",
                  "credential_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLocationInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "external_locations_list",
        "summary": "Gets an array of external locations (__ExternalLocationInfo__ objects) from the metastore. The caller",
        "tags": [
          "catalog",
          "external_locations"
        ],
        "description": "Gets an array of external locations (__ExternalLocationInfo__ objects) from the metastore. The caller\nmust be a metastore admin, the owner of the external location, or a user that has some privilege on\nthe external location. There is no guarantee of a specific ordering of the elements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param include_browse: bool (optional)\n  Whether to include external locations in the response for which the principal can only access\n  selective metadata for\n:param include_unbound: bool (optional)\n  Whether to include external locations not bound to the workspace. Effective only if the user has\n  permission to update the location\u2013workspace binding.\n:param max_results: int (optional)\n  Maximum number of external locations to return. If not set, all the external locations are returned\n  (not recommended). - when set to a value greater than 0, the page length is the minimum of this\n  value and a server configured value; - when set to 0, the page length is set to a server configured\n  value (recommended); - when set to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`ExternalLocationInfo`",
        "parameters": [
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include external locations in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "include_unbound",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include external locations not bound to the workspace. Effective only if the user has permission to update the location\u2013workspace binding."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of external locations to return. If not set, all the external locations are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLocationInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/external-locations/{name}": {
      "delete": {
        "operationId": "external_locations_delete",
        "summary": "Deletes the specified external location from the metastore. The caller must be the owner of the",
        "tags": [
          "catalog",
          "external_locations"
        ],
        "description": "Deletes the specified external location from the metastore. The caller must be the owner of the\nexternal location.\n\n:param name: str\n  Name of the external location.\n:param force: bool (optional)\n  Force deletion even if there are dependent external tables or mounts.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the external location."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force deletion even if there are dependent external tables or mounts."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "external_locations_get",
        "summary": "Gets an external location from the metastore. The caller must be either a metastore admin, the owner",
        "tags": [
          "catalog",
          "external_locations"
        ],
        "description": "Gets an external location from the metastore. The caller must be either a metastore admin, the owner\nof the external location, or a user that has some privilege on the external location.\n\n:param name: str\n  Name of the external location.\n:param include_browse: bool (optional)\n  Whether to include external locations in the response for which the principal can only access\n  selective metadata for\n\n:returns: :class:`ExternalLocationInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the external location."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include external locations in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLocationInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "external_locations_update",
        "summary": "Updates an external location in the metastore. The caller must be the owner of the external location,",
        "tags": [
          "catalog",
          "external_locations"
        ],
        "description": "Updates an external location in the metastore. The caller must be the owner of the external location,\nor be a metastore admin. In the second case, the admin can only update the name of the external\nlocation.\n\n:param name: str\n  Name of the external location.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param credential_name: str (optional)\n  Name of the storage credential used with this location.\n:param enable_file_events: bool (optional)\n  Whether to enable file events on this external location. Default to `true`. Set to `false` to\n  disable file events.\n:param encryption_details: :class:`EncryptionDetails` (optional)\n:param fallback: bool (optional)\n  Indicates whether fallback mode is enabled for this external location. When fallback mode is\n  enabled, the access to the location falls back to cluster credentials if UC credentials are not\n  sufficient.\n:param file_event_queue: :class:`FileEventQueue` (optional)\n  File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly\n  one of the documented properties.\n:param force: bool (optional)\n  Force update even if changing url invalidates dependent external tables or mounts.\n:param isolation_mode: :class:`IsolationMode` (optional)\n:param new_name: str (optional)\n  New name for the external location.\n:param owner: str (optional)\n  The owner of the external location.\n:param read_only: bool (optional)\n  Indicates whether the external location is read-only.\n:param skip_validation: bool (optional)\n  Skips validation of the storage credential associated with the external location.\n:param url: str (optional)\n  Path URL of the external location.\n\n:returns: :class:`ExternalLocationInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the external location."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "credential_name": {
                    "type": "string",
                    "description": "Name of the storage credential used with this location."
                  },
                  "enable_file_events": {
                    "type": "string",
                    "description": "Whether to enable file events on this external location. Default to `true`. Set to `false` to disable file events."
                  },
                  "encryption_details": {
                    "type": "string",
                    "description": ":param fallback: bool (optional) Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled, the access to the location falls back to cluster credentials if UC credentials are not sufficient."
                  },
                  "fallback": {
                    "type": "string"
                  },
                  "file_event_queue": {
                    "type": "string",
                    "description": "File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly one of the documented properties."
                  },
                  "force": {
                    "type": "string",
                    "description": "Force update even if changing url invalidates dependent external tables or mounts."
                  },
                  "isolation_mode": {
                    "type": "string",
                    "description": ":param new_name: str (optional) New name for the external location."
                  },
                  "new_name": {
                    "type": "string"
                  },
                  "owner": {
                    "type": "string",
                    "description": "The owner of the external location."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "Indicates whether the external location is read-only."
                  },
                  "skip_validation": {
                    "type": "string",
                    "description": "Skips validation of the storage credential associated with the external location."
                  },
                  "url": {
                    "type": "string",
                    "description": "Path URL of the external location."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalLocationInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/lineage-tracking/external-metadata": {
      "post": {
        "operationId": "external_metadata_create_external_metadata",
        "summary": "Creates a new external metadata object in the parent metastore if the caller is a metastore admin or",
        "tags": [
          "catalog",
          "external_metadata"
        ],
        "description": "Creates a new external metadata object in the parent metastore if the caller is a metastore admin or\nhas the **CREATE_EXTERNAL_METADATA** privilege. Grants **BROWSE** to all account users upon creation\nby default.\n\n:param external_metadata: :class:`ExternalMetadata`\n\n:returns: :class:`ExternalMetadata`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "external_metadata": {
                    "type": "string",
                    "description": ":returns: :class:`ExternalMetadata`"
                  }
                },
                "required": [
                  "external_metadata"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalMetadata"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "external_metadata_list_external_metadata",
        "summary": "Gets an array of external metadata objects in the metastore. If the caller is the metastore admin, all",
        "tags": [
          "catalog",
          "external_metadata"
        ],
        "description": "Gets an array of external metadata objects in the metastore. If the caller is the metastore admin, all\nexternal metadata objects will be retrieved. Otherwise, only external metadata objects that the caller\nhas **BROWSE** on will be retrieved. There is no guarantee of a specific ordering of the elements in\nthe array.\n\n:param page_size: int (optional)\n  Specifies the maximum number of external metadata objects to return in a single response. The value\n  must be less than or equal to 1000.\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`ExternalMetadata`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Specifies the maximum number of external metadata objects to return in a single response. The value must be less than or equal to 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalMetadata"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/lineage-tracking/external-metadata/{name}": {
      "delete": {
        "operationId": "external_metadata_delete_external_metadata",
        "summary": "Deletes the external metadata object that matches the supplied name. The caller must be a metastore",
        "tags": [
          "catalog",
          "external_metadata"
        ],
        "description": "Deletes the external metadata object that matches the supplied name. The caller must be a metastore\nadmin, the owner of the external metadata object, or a user that has the **MANAGE** privilege.\n\n:param name: str",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "external_metadata_get_external_metadata",
        "summary": "Gets the specified external metadata object in a metastore. The caller must be a metastore admin, the",
        "tags": [
          "catalog",
          "external_metadata"
        ],
        "description": "Gets the specified external metadata object in a metastore. The caller must be a metastore admin, the\nowner of the external metadata object, or a user that has the **BROWSE** privilege.\n\n:param name: str\n\n:returns: :class:`ExternalMetadata`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`ExternalMetadata`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalMetadata"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "external_metadata_update_external_metadata",
        "summary": "Updates the external metadata object that matches the supplied name. The caller can only update either",
        "tags": [
          "catalog",
          "external_metadata"
        ],
        "description": "Updates the external metadata object that matches the supplied name. The caller can only update either\nthe owner or other metadata fields in one request. The caller must be a metastore admin, the owner of\nthe external metadata object, or a user that has the **MODIFY** privilege. If the caller is updating\nthe owner, they must also have the **MANAGE** privilege.\n\n:param name: str\n  Name of the external metadata object.\n:param external_metadata: :class:`ExternalMetadata`\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n\n:returns: :class:`ExternalMetadata`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the external metadata object."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "external_metadata": {
                    "type": "string",
                    "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
                  }
                },
                "required": [
                  "external_metadata"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalMetadata"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/functions": {
      "post": {
        "operationId": "functions_create",
        "summary": "**WARNING: This API is experimental and will change in future versions**",
        "tags": [
          "catalog",
          "functions"
        ],
        "description": "**WARNING: This API is experimental and will change in future versions**\n\nCreates a new function\n\nThe user must have the following permissions in order for the function to be created: -\n**USE_CATALOG** on the function's parent catalog - **USE_SCHEMA** and **CREATE_FUNCTION** on the\nfunction's parent schema\n\n:param function_info: :class:`CreateFunction`\n  Partial __FunctionInfo__ specifying the function to be created.\n\n:returns: :class:`FunctionInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "function_info": {
                    "type": "string",
                    "description": "Partial __FunctionInfo__ specifying the function to be created."
                  }
                },
                "required": [
                  "function_info"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "functions_list",
        "summary": "List functions within the specified parent catalog and schema. If the user is a metastore admin, all",
        "tags": [
          "catalog",
          "functions"
        ],
        "description": "List functions within the specified parent catalog and schema. If the user is a metastore admin, all\nfunctions are returned in the output list. Otherwise, the user must have the **USE_CATALOG** privilege\non the catalog and the **USE_SCHEMA** privilege on the schema, and the output list contains only\nfunctions for which either the user has the **EXECUTE** privilege or the user is the owner. There is\nno guarantee of a specific ordering of the elements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param catalog_name: str\n  Name of parent catalog for functions of interest.\n:param schema_name: str\n  Parent schema of functions.\n:param include_browse: bool (optional)\n  Whether to include functions in the response for which the principal can only access selective\n  metadata for\n:param max_results: int (optional)\n  Maximum number of functions to return. If not set, all the functions are returned (not recommended).\n  - when set to a value greater than 0, the page length is the minimum of this value and a server\n  configured value; - when set to 0, the page length is set to a server configured value\n  (recommended); - when set to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`FunctionInfo`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of parent catalog for functions of interest."
          },
          {
            "name": "schema_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Parent schema of functions."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include functions in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of functions to return. If not set, all the functions are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/functions/{name}": {
      "delete": {
        "operationId": "functions_delete",
        "summary": "Deletes the function that matches the supplied name. For the deletion to succeed, the user must",
        "tags": [
          "catalog",
          "functions"
        ],
        "description": "Deletes the function that matches the supplied name. For the deletion to succeed, the user must\nsatisfy one of the following conditions: - Is the owner of the function's parent catalog - Is the\nowner of the function's parent schema and have the **USE_CATALOG** privilege on its parent catalog -\nIs the owner of the function itself and have both the **USE_CATALOG** privilege on its parent catalog\nand the **USE_SCHEMA** privilege on its parent schema\n\n:param name: str\n  The fully-qualified name of the function (of the form\n  __catalog_name__.__schema_name__.__function__name__) .\n:param force: bool (optional)\n  Force deletion even if the function is notempty.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__) ."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force deletion even if the function is notempty."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "functions_get",
        "summary": "Gets a function from within a parent catalog and schema. For the fetch to succeed, the user must",
        "tags": [
          "catalog",
          "functions"
        ],
        "description": "Gets a function from within a parent catalog and schema. For the fetch to succeed, the user must\nsatisfy one of the following requirements: - Is a metastore admin - Is an owner of the function's\nparent catalog - Have the **USE_CATALOG** privilege on the function's parent catalog and be the owner\nof the function - Have the **USE_CATALOG** privilege on the function's parent catalog, the\n**USE_SCHEMA** privilege on the function's parent schema, and the **EXECUTE** privilege on the\nfunction itself\n\n:param name: str\n  The fully-qualified name of the function (of the form\n  __catalog_name__.__schema_name__.__function__name__).\n:param include_browse: bool (optional)\n  Whether to include functions in the response for which the principal can only access selective\n  metadata for\n\n:returns: :class:`FunctionInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__)."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include functions in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "functions_update",
        "summary": "Updates the function that matches the supplied name. Only the owner of the function can be updated. If",
        "tags": [
          "catalog",
          "functions"
        ],
        "description": "Updates the function that matches the supplied name. Only the owner of the function can be updated. If\nthe user is not a metastore admin, the user must be a member of the group that is the new function\nowner. - Is a metastore admin - Is the owner of the function's parent catalog - Is the owner of the\nfunction's parent schema and has the **USE_CATALOG** privilege on its parent catalog - Is the owner of\nthe function itself and has the **USE_CATALOG** privilege on its parent catalog as well as the\n**USE_SCHEMA** privilege on the function's parent schema.\n\n:param name: str\n  The fully-qualified name of the function (of the form\n  __catalog_name__.__schema_name__.__function__name__).\n:param owner: str (optional)\n  Username of current owner of the function.\n\n:returns: :class:`FunctionInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The fully-qualified name of the function (of the form __catalog_name__.__schema_name__.__function__name__)."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of the function."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/permissions/{securable_type}/{full_name}": {
      "get": {
        "operationId": "grants_get",
        "summary": "Gets the permissions for a securable. Does not include inherited permissions.",
        "tags": [
          "catalog",
          "grants"
        ],
        "description": "Gets the permissions for a securable. Does not include inherited permissions.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param securable_type: str\n  Type of securable.\n:param full_name: str\n  Full name of securable.\n:param max_results: int (optional)\n  Specifies the maximum number of privileges to return (page length). Every PrivilegeAssignment\n  present in a single page response is guaranteed to contain all the privileges granted on the\n  requested Securable for the respective principal.\n\n  If not set, all the permissions are returned. If set to - lesser than 0: invalid parameter error -\n  0: page length is set to a server configured value - lesser than 150 but greater than 0: invalid\n  parameter error (this is to ensure that server is able to return at least one complete\n  PrivilegeAssignment in a single page response) - greater than (or equal to) 150: page length is the\n  minimum of this value and a server configured value\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n:param principal: str (optional)\n  If provided, only the permissions for the specified principal (user or group) are returned.\n\n:returns: :class:`GetPermissionsResponse`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Type of securable."
          },
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of securable."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Specifies the maximum number of privileges to return (page length). Every PrivilegeAssignment present in a single page response is guaranteed to contain all the privileges granted on the requested Securable for the respective principal. If not set, all the permissions are returned. If set to - lesser than 0: invalid parameter error - 0: page length is set to a server configured value - lesser than 150 but greater than 0: invalid parameter error (this is to ensure that server is able to return at least one complete PrivilegeAssignment in a single page response) - greater than (or equal to) 150: page length is the minimum of this value and a server configured value"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          },
          {
            "name": "principal",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "If provided, only the permissions for the specified principal (user or group) are returned."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetPermissionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "grants_update",
        "summary": "Updates the permissions for a securable.",
        "tags": [
          "catalog",
          "grants"
        ],
        "description": "Updates the permissions for a securable.\n\n:param securable_type: str\n  Type of securable.\n:param full_name: str\n  Full name of securable.\n:param changes: List[:class:`PermissionsChange`] (optional)\n  Array of permissions change objects.\n\n:returns: :class:`UpdatePermissionsResponse`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Type of securable."
          },
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of securable."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "changes": {
                    "type": "string",
                    "description": "Array of permissions change objects."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdatePermissionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/effective-permissions/{securable_type}/{full_name}": {
      "get": {
        "operationId": "grants_get_effective",
        "summary": "Gets the effective permissions for a securable. Includes inherited permissions from any parent",
        "tags": [
          "catalog",
          "grants"
        ],
        "description": "Gets the effective permissions for a securable. Includes inherited permissions from any parent\nsecurables.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param securable_type: str\n  Type of securable.\n:param full_name: str\n  Full name of securable.\n:param max_results: int (optional)\n  Specifies the maximum number of privileges to return (page length). Every\n  EffectivePrivilegeAssignment present in a single page response is guaranteed to contain all the\n  effective privileges granted on (or inherited by) the requested Securable for the respective\n  principal.\n\n  If not set, all the effective permissions are returned. If set to - lesser than 0: invalid parameter\n  error - 0: page length is set to a server configured value - lesser than 150 but greater than 0:\n  invalid parameter error (this is to ensure that server is able to return at least one complete\n  EffectivePrivilegeAssignment in a single page response) - greater than (or equal to) 150: page\n  length is the minimum of this value and a server configured value\n:param page_token: str (optional)\n  Opaque token for the next page of results (pagination).\n:param principal: str (optional)\n  If provided, only the effective permissions for the specified principal (user or group) are\n  returned.\n\n:returns: :class:`EffectivePermissionsList`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Type of securable."
          },
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of securable."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Specifies the maximum number of privileges to return (page length). Every EffectivePrivilegeAssignment present in a single page response is guaranteed to contain all the effective privileges granted on (or inherited by) the requested Securable for the respective principal. If not set, all the effective permissions are returned. If set to - lesser than 0: invalid parameter error - 0: page length is set to a server configured value - lesser than 150 but greater than 0: invalid parameter error (this is to ensure that server is able to return at least one complete EffectivePrivilegeAssignment in a single page response) - greater than (or equal to) 150: page length is the minimum of this value and a server configured value"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token for the next page of results (pagination)."
          },
          {
            "name": "principal",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "If provided, only the effective permissions for the specified principal (user or group) are returned."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EffectivePermissionsList"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/workspaces/{workspace_id}/metastore": {
      "put": {
        "operationId": "metastores_assign",
        "summary": "Creates a new metastore assignment. If an assignment for the same __workspace_id__ exists, it will be",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Creates a new metastore assignment. If an assignment for the same __workspace_id__ exists, it will be\noverwritten by the new __metastore_id__ and __default_catalog_name__. The caller must be an account\nadmin.\n\n:param workspace_id: int\n  A workspace ID.\n:param metastore_id: str\n  The unique ID of the metastore.\n:param default_catalog_name: str\n  The name of the default catalog in the metastore. This field is deprecated. Please use \"Default\n  Namespace API\" to configure the default catalog for a Databricks workspace.",
        "parameters": [
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "A workspace ID."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metastore_id": {
                    "type": "string",
                    "description": "The unique ID of the metastore."
                  },
                  "default_catalog_name": {
                    "type": "string",
                    "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
                  }
                },
                "required": [
                  "metastore_id",
                  "default_catalog_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "metastores_unassign",
        "summary": "Deletes a metastore assignment. The caller must be an account administrator.",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Deletes a metastore assignment. The caller must be an account administrator.\n\n:param workspace_id: int\n  A workspace ID.\n:param metastore_id: str\n  Query for the ID of the metastore to delete.",
        "parameters": [
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "A workspace ID."
          },
          {
            "name": "metastore_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Query for the ID of the metastore to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "metastores_update_assignment",
        "summary": "Updates a metastore assignment. This operation can be used to update __metastore_id__ or",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Updates a metastore assignment. This operation can be used to update __metastore_id__ or\n__default_catalog_name__ for a specified Workspace, if the Workspace is already assigned a metastore.\nThe caller must be an account admin to update __metastore_id__; otherwise, the caller can be a\nWorkspace admin.\n\n:param workspace_id: int\n  A workspace ID.\n:param default_catalog_name: str (optional)\n  The name of the default catalog in the metastore. This field is deprecated. Please use \"Default\n  Namespace API\" to configure the default catalog for a Databricks workspace.\n:param metastore_id: str (optional)\n  The unique ID of the metastore.",
        "parameters": [
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "A workspace ID."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "default_catalog_name": {
                    "type": "string",
                    "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
                  },
                  "metastore_id": {
                    "type": "string",
                    "description": "The unique ID of the metastore."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/metastores": {
      "post": {
        "operationId": "metastores_create",
        "summary": "Creates a new metastore based on a provided name and optional storage root path. By default (if the",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Creates a new metastore based on a provided name and optional storage root path. By default (if the\n__owner__ field is not set), the owner of the new metastore is the user calling the\n__createMetastore__ API. If the __owner__ field is set to the empty string (**\"\"**), the ownership is\nassigned to the System User instead.\n\n:param name: str\n  The user-specified name of the metastore.\n:param external_access_enabled: bool (optional)\n  Whether to allow non-DBR clients to directly access entities under the metastore.\n:param region: str (optional)\n  Cloud region which the metastore serves (e.g., `us-west-2`, `westus`).\n:param storage_root: str (optional)\n  The storage root URL for metastore\n\n:returns: :class:`MetastoreInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The user-specified name of the metastore."
                  },
                  "external_access_enabled": {
                    "type": "string",
                    "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
                  },
                  "region": {
                    "type": "string",
                    "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
                  },
                  "storage_root": {
                    "type": "string",
                    "description": "The storage root URL for metastore"
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetastoreInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "metastores_list",
        "summary": "Gets an array of the available metastores (as __MetastoreInfo__ objects). The caller must be an admin",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Gets an array of the available metastores (as __MetastoreInfo__ objects). The caller must be an admin\nto retrieve this info. There is no guarantee of a specific ordering of the elements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param max_results: int (optional)\n  Maximum number of metastores to return. - when set to a value greater than 0, the page length is the\n  minimum of this value and a server configured value; - when set to 0, the page length is set to a\n  server configured value (recommended); - when set to a value less than 0, an invalid parameter error\n  is returned; - If not set, all the metastores are returned (not recommended). - Note: The number of\n  returned metastores might be less than the specified max_results size, even zero. The only\n  definitive indication that no further metastores can be fetched is when the next_page_token is unset\n  from the response.\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`MetastoreInfo`",
        "parameters": [
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of metastores to return. - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned; - If not set, all the metastores are returned (not recommended). - Note: The number of returned metastores might be less than the specified max_results size, even zero. The only definitive indication that no further metastores can be fetched is when the next_page_token is unset from the response."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetastoreInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/current-metastore-assignment": {
      "get": {
        "operationId": "metastores_current",
        "summary": "Gets the metastore assignment for the workspace being accessed.",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Gets the metastore assignment for the workspace being accessed.\n\n\n:returns: :class:`MetastoreAssignment`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetastoreAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/metastores/{id}": {
      "delete": {
        "operationId": "metastores_delete",
        "summary": "Deletes a metastore. The caller must be a metastore admin.",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Deletes a metastore. The caller must be a metastore admin.\n\n:param id: str\n  Unique ID of the metastore.\n:param force: bool (optional)\n  Force deletion even if the metastore is not empty. Default is false.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unique ID of the metastore."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force deletion even if the metastore is not empty. Default is false."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "metastores_get",
        "summary": "Gets a metastore that matches the supplied ID. The caller must be a metastore admin to retrieve this",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Gets a metastore that matches the supplied ID. The caller must be a metastore admin to retrieve this\ninfo.\n\n:param id: str\n  Unique ID of the metastore.\n\n:returns: :class:`MetastoreInfo`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unique ID of the metastore."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetastoreInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "metastores_update",
        "summary": "Updates information for a specific metastore. The caller must be a metastore admin. If the __owner__",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Updates information for a specific metastore. The caller must be a metastore admin. If the __owner__\nfield is set to the empty string (**\"\"**), the ownership is updated to the System User.\n\n:param id: str\n  Unique ID of the metastore.\n:param delta_sharing_organization_name: str (optional)\n  The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta\n  Sharing as the official name.\n:param delta_sharing_recipient_token_lifetime_in_seconds: int (optional)\n  The lifetime of delta sharing recipient token in seconds.\n:param delta_sharing_scope: :class:`DeltaSharingScopeEnum` (optional)\n  The scope of Delta Sharing enabled for the metastore.\n:param external_access_enabled: bool (optional)\n  Whether to allow non-DBR clients to directly access entities under the metastore.\n:param new_name: str (optional)\n  New name for the metastore.\n:param owner: str (optional)\n  The owner of the metastore.\n:param privilege_model_version: str (optional)\n  Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`).\n:param storage_root_credential_id: str (optional)\n  UUID of storage credential to access the metastore storage_root.\n\n:returns: :class:`MetastoreInfo`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unique ID of the metastore."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "delta_sharing_organization_name": {
                    "type": "string",
                    "description": "The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta Sharing as the official name."
                  },
                  "delta_sharing_recipient_token_lifetime_in_seconds": {
                    "type": "string",
                    "description": "The lifetime of delta sharing recipient token in seconds."
                  },
                  "delta_sharing_scope": {
                    "type": "string",
                    "description": "The scope of Delta Sharing enabled for the metastore."
                  },
                  "external_access_enabled": {
                    "type": "string",
                    "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the metastore."
                  },
                  "owner": {
                    "type": "string",
                    "description": "The owner of the metastore."
                  },
                  "privilege_model_version": {
                    "type": "string",
                    "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
                  },
                  "storage_root_credential_id": {
                    "type": "string",
                    "description": "UUID of storage credential to access the metastore storage_root."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetastoreInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/metastore_summary": {
      "get": {
        "operationId": "metastores_summary",
        "summary": "Gets information about a metastore. This summary includes the storage credential, the cloud vendor,",
        "tags": [
          "catalog",
          "metastores"
        ],
        "description": "Gets information about a metastore. This summary includes the storage credential, the cloud vendor,\nthe cloud region, and the global metastore ID.\n\n\n:returns: :class:`GetMetastoreSummaryResponse`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetMetastoreSummaryResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/models/{full_name}/versions/{version}": {
      "delete": {
        "operationId": "model_versions_delete",
        "summary": "Deletes a model version from the specified registered model. Any aliases assigned to the model version",
        "tags": [
          "catalog",
          "model_versions"
        ],
        "description": "Deletes a model version from the specified registered model. Any aliases assigned to the model version\nwill also be deleted.\n\nThe caller must be a metastore admin or an owner of the parent registered model. For the latter case,\nthe caller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the model version\n:param version: int\n  The integer version number of the model version",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the model version"
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "The integer version number of the model version"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "model_versions_get",
        "summary": "Get a model version.",
        "tags": [
          "catalog",
          "model_versions"
        ],
        "description": "Get a model version.\n\nThe caller must be a metastore admin or an owner of (or have the **EXECUTE** privilege on) the parent\nregistered model. For the latter case, the caller must also be the owner or have the **USE_CATALOG**\nprivilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the model version\n:param version: int\n  The integer version number of the model version\n:param include_aliases: bool (optional)\n  Whether to include aliases associated with the model version in the response\n:param include_browse: bool (optional)\n  Whether to include model versions in the response for which the principal can only access selective\n  metadata for\n\n:returns: :class:`ModelVersionInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the model version"
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "The integer version number of the model version"
          },
          {
            "name": "include_aliases",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include aliases associated with the model version in the response"
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include model versions in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "model_versions_update",
        "summary": "Updates the specified model version.",
        "tags": [
          "catalog",
          "model_versions"
        ],
        "description": "Updates the specified model version.\n\nThe caller must be a metastore admin or an owner of the parent registered model. For the latter case,\nthe caller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\nCurrently only the comment of the model version can be updated.\n\n:param full_name: str\n  The three-level (fully qualified) name of the model version\n:param version: int\n  The integer version number of the model version\n:param aliases: List[:class:`RegisteredModelAlias`] (optional)\n  List of aliases associated with the model version\n:param catalog_name: str (optional)\n  The name of the catalog containing the model version\n:param comment: str (optional)\n  The comment attached to the model version\n:param created_at: int (optional)\n:param created_by: str (optional)\n  The identifier of the user who created the model version\n:param id: str (optional)\n  The unique identifier of the model version\n:param metastore_id: str (optional)\n  The unique identifier of the metastore containing the model version\n:param model_name: str (optional)\n  The name of the parent registered model of the model version, relative to parent schema\n:param model_version_dependencies: :class:`DependencyList` (optional)\n  Model version dependencies, for feature-store packaged models\n:param run_id: str (optional)\n  MLflow run ID used when creating the model version, if ``source`` was generated by an experiment run\n  stored in an MLflow tracking server\n:param run_workspace_id: int (optional)\n  ID of the Databricks workspace containing the MLflow run that generated this model version, if\n  applicable\n:param schema_name: str (optional)\n  The name of the schema containing the model version, relative to parent catalog\n:param source: str (optional)\n  URI indicating the location of the source artifacts (files) for the model version\n:param status: :class:`ModelVersionInfoStatus` (optional)\n  Current status of the model version. Newly created model versions start in PENDING_REGISTRATION\n  status, then move to READY status once the model version files are uploaded and the model version is\n  finalized. Only model versions in READY status can be loaded for inference or served.\n:param storage_location: str (optional)\n  The storage location on the cloud under which model version data files are stored\n:param updated_at: int (optional)\n:param updated_by: str (optional)\n  The identifier of the user who updated the model version last time\n\n:returns: :class:`ModelVersionInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the model version"
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "The integer version number of the model version"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aliases": {
                    "type": "string",
                    "description": "List of aliases associated with the model version"
                  },
                  "catalog_name": {
                    "type": "string",
                    "description": "The name of the catalog containing the model version"
                  },
                  "comment": {
                    "type": "string",
                    "description": "The comment attached to the model version"
                  },
                  "created_at": {
                    "type": "string",
                    "description": ":param created_by: str (optional) The identifier of the user who created the model version"
                  },
                  "created_by": {
                    "type": "string"
                  },
                  "id": {
                    "type": "string",
                    "description": "The unique identifier of the model version"
                  },
                  "metastore_id": {
                    "type": "string",
                    "description": "The unique identifier of the metastore containing the model version"
                  },
                  "model_name": {
                    "type": "string",
                    "description": "The name of the parent registered model of the model version, relative to parent schema"
                  },
                  "model_version_dependencies": {
                    "type": "string",
                    "description": "Model version dependencies, for feature-store packaged models"
                  },
                  "run_id": {
                    "type": "string",
                    "description": "MLflow run ID used when creating the model version, if ``source`` was generated by an experiment run stored in an MLflow tracking server"
                  },
                  "run_workspace_id": {
                    "type": "string",
                    "description": "ID of the Databricks workspace containing the MLflow run that generated this model version, if applicable"
                  },
                  "schema_name": {
                    "type": "string",
                    "description": "The name of the schema containing the model version, relative to parent catalog"
                  },
                  "source": {
                    "type": "string",
                    "description": "URI indicating the location of the source artifacts (files) for the model version"
                  },
                  "status": {
                    "type": "string",
                    "description": "Current status of the model version. Newly created model versions start in PENDING_REGISTRATION status, then move to READY status once the model version files are uploaded and the model version is finalized. Only model versions in READY status can be loaded for inference or served."
                  },
                  "storage_location": {
                    "type": "string",
                    "description": "The storage location on the cloud under which model version data files are stored"
                  },
                  "updated_at": {
                    "type": "string",
                    "description": ":param updated_by: str (optional) The identifier of the user who updated the model version last time"
                  },
                  "updated_by": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/models/{full_name}/aliases/{alias}": {
      "get": {
        "operationId": "model_versions_get_by_alias",
        "summary": "Get a model version by alias.",
        "tags": [
          "catalog",
          "model_versions"
        ],
        "description": "Get a model version by alias.\n\nThe caller must be a metastore admin or an owner of (or have the **EXECUTE** privilege on) the\nregistered model. For the latter case, the caller must also be the owner or have the **USE_CATALOG**\nprivilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model\n:param alias: str\n  The name of the alias\n:param include_aliases: bool (optional)\n  Whether to include aliases associated with the model version in the response\n\n:returns: :class:`ModelVersionInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          },
          {
            "name": "alias",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the alias"
          },
          {
            "name": "include_aliases",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include aliases associated with the model version in the response"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "registered_models_delete_alias",
        "summary": "Deletes a registered model alias.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Deletes a registered model alias.\n\nThe caller must be a metastore admin or an owner of the registered model. For the latter case, the\ncaller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model\n:param alias: str\n  The name of the alias",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          },
          {
            "name": "alias",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the alias"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "registered_models_set_alias",
        "summary": "Set an alias on the specified registered model.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Set an alias on the specified registered model.\n\nThe caller must be a metastore admin or an owner of the registered model. For the latter case, the\ncaller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model\n:param alias: str\n  The name of the alias\n:param version_num: int\n  The version number of the model version to which the alias points\n\n:returns: :class:`RegisteredModelAlias`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          },
          {
            "name": "alias",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the alias"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "version_num": {
                    "type": "integer",
                    "description": "The version number of the model version to which the alias points"
                  }
                },
                "required": [
                  "version_num"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelAlias"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/models/{full_name}/versions": {
      "get": {
        "operationId": "model_versions_list",
        "summary": "List model versions. You can list model versions under a particular schema, or list all model versions",
        "tags": [
          "catalog",
          "model_versions"
        ],
        "description": "List model versions. You can list model versions under a particular schema, or list all model versions\nin the current metastore.\n\nThe returned models are filtered based on the privileges of the calling user. For example, the\nmetastore admin is able to list all the model versions. A regular user needs to be the owner or have\nthe **EXECUTE** privilege on the parent registered model to recieve the model versions in the\nresponse. For the latter case, the caller must also be the owner or have the **USE_CATALOG** privilege\non the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\nThere is no guarantee of a specific ordering of the elements in the response. The elements in the\nresponse will not contain any aliases or tags.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param full_name: str\n  The full three-level name of the registered model under which to list model versions\n:param include_browse: bool (optional)\n  Whether to include model versions in the response for which the principal can only access selective\n  metadata for\n:param max_results: int (optional)\n  Maximum number of model versions to return. If not set, the page length is set to a server\n  configured value (100, as of 1/3/2024). - when set to a value greater than 0, the page length is the\n  minimum of this value and a server configured value(1000, as of 1/3/2024); - when set to 0, the page\n  length is set to a server configured value (100, as of 1/3/2024) (recommended); - when set to a\n  value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`ModelVersionInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full three-level name of the registered model under which to list model versions"
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include model versions in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of model versions to return. If not set, the page length is set to a server configured value (100, as of 1/3/2024). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value(1000, as of 1/3/2024); - when set to 0, the page length is set to a server configured value (100, as of 1/3/2024) (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelVersionInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/online-tables": {
      "post": {
        "operationId": "online_tables_create",
        "summary": "Create a new Online Table.",
        "tags": [
          "catalog",
          "online_tables"
        ],
        "description": "Create a new Online Table.\n\n:param table: :class:`OnlineTable`\n  Specification of the online table to be created.\n\n:returns:\n  Long-running operation waiter for :class:`OnlineTable`.\n  See :method:wait_get_online_table_active for more details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "table": {
                    "type": "string",
                    "description": "Specification of the online table to be created."
                  }
                },
                "required": [
                  "table"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineTable"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/online-tables/{name}": {
      "delete": {
        "operationId": "online_tables_delete",
        "summary": "Delete an online table. Warning: This will delete all the data in the online table. If the source",
        "tags": [
          "catalog",
          "online_tables"
        ],
        "description": "Delete an online table. Warning: This will delete all the data in the online table. If the source\nDelta table was deleted or modified since this Online Table was created, this will lose the data\nforever!\n\n:param name: str\n  Full three-part (catalog, schema, table) name of the table.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full three-part (catalog, schema, table) name of the table."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "online_tables_get",
        "summary": "Get information about an existing online table and its status.",
        "tags": [
          "catalog",
          "online_tables"
        ],
        "description": "Get information about an existing online table and its status.\n\n:param name: str\n  Full three-part (catalog, schema, table) name of the table.\n\n:returns: :class:`OnlineTable`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full three-part (catalog, schema, table) name of the table."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OnlineTable"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/policies": {
      "post": {
        "operationId": "policies_create_policy",
        "summary": "Creates a new policy on a securable. The new policy applies to the securable and all its descendants.",
        "tags": [
          "catalog",
          "policies"
        ],
        "description": "Creates a new policy on a securable. The new policy applies to the securable and all its descendants.\n\n:param policy_info: :class:`PolicyInfo`\n  Required. The policy to create.\n\n:returns: :class:`PolicyInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy_info": {
                    "type": "string",
                    "description": "Required. The policy to create."
                  }
                },
                "required": [
                  "policy_info"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolicyInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/policies/{on_securable_type}/{on_securable_fullname}/{name}": {
      "delete": {
        "operationId": "policies_delete_policy",
        "summary": "Delete an ABAC policy defined on a securable.",
        "tags": [
          "catalog",
          "policies"
        ],
        "description": "Delete an ABAC policy defined on a securable.\n\n:param on_securable_type: str\n  Required. The type of the securable to delete the policy from.\n:param on_securable_fullname: str\n  Required. The fully qualified name of the securable to delete the policy from.\n:param name: str\n  Required. The name of the policy to delete\n\n:returns: :class:`DeletePolicyResponse`",
        "parameters": [
          {
            "name": "on_securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The type of the securable to delete the policy from."
          },
          {
            "name": "on_securable_fullname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The fully qualified name of the securable to delete the policy from."
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The name of the policy to delete"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeletePolicyResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "policies_get_policy",
        "summary": "Get the policy definition on a securable",
        "tags": [
          "catalog",
          "policies"
        ],
        "description": "Get the policy definition on a securable\n\n:param on_securable_type: str\n  Required. The type of the securable to retrieve the policy for.\n:param on_securable_fullname: str\n  Required. The fully qualified name of securable to retrieve policy for.\n:param name: str\n  Required. The name of the policy to retrieve.\n\n:returns: :class:`PolicyInfo`",
        "parameters": [
          {
            "name": "on_securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The type of the securable to retrieve the policy for."
          },
          {
            "name": "on_securable_fullname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The fully qualified name of securable to retrieve policy for."
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The name of the policy to retrieve."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolicyInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "policies_update_policy",
        "summary": "Update an ABAC policy on a securable.",
        "tags": [
          "catalog",
          "policies"
        ],
        "description": "Update an ABAC policy on a securable.\n\n:param on_securable_type: str\n  Required. The type of the securable to update the policy for.\n:param on_securable_fullname: str\n  Required. The fully qualified name of the securable to update the policy for.\n:param name: str\n  Required. The name of the policy to update.\n:param policy_info: :class:`PolicyInfo`\n  Optional fields to update. This is the request body for updating a policy. Use `update_mask` field\n  to specify which fields in the request is to be updated. - If `update_mask` is empty or \"*\", all\n  specified fields will be updated. - If `update_mask` is specified, only the fields specified in the\n  `update_mask` will be updated. If a field is specified in `update_mask` and not set in the request,\n  the field will be cleared. Users can use the update mask to explicitly unset optional fields such as\n  `exception_principals` and `when_condition`.\n:param update_mask: str (optional)\n  Optional. The update mask field for specifying user intentions on which fields to update in the\n  request.\n\n:returns: :class:`PolicyInfo`",
        "parameters": [
          {
            "name": "on_securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The type of the securable to update the policy for."
          },
          {
            "name": "on_securable_fullname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The fully qualified name of the securable to update the policy for."
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The name of the policy to update."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. The update mask field for specifying user intentions on which fields to update in the request."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy_info": {
                    "type": "string",
                    "description": "Optional fields to update. This is the request body for updating a policy. Use `update_mask` field to specify which fields in the request is to be updated. - If `update_mask` is empty or \"*\", all specified fields will be updated. - If `update_mask` is specified, only the fields specified in the `update_mask` will be updated. If a field is specified in `update_mask` and not set in the request, the field will be cleared. Users can use the update mask to explicitly unset optional fields such as `exception_principals` and `when_condition`."
                  }
                },
                "required": [
                  "policy_info"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolicyInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/policies/{on_securable_type}/{on_securable_fullname}": {
      "get": {
        "operationId": "policies_list_policies",
        "summary": "List all policies defined on a securable. Optionally, the list can include inherited policies defined",
        "tags": [
          "catalog",
          "policies"
        ],
        "description": "List all policies defined on a securable. Optionally, the list can include inherited policies defined\non the securable's parent schema or catalog.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param on_securable_type: str\n  Required. The type of the securable to list policies for.\n:param on_securable_fullname: str\n  Required. The fully qualified name of securable to list policies for.\n:param include_inherited: bool (optional)\n  Optional. Whether to include policies defined on parent securables. By default, the inherited\n  policies are not included.\n:param max_results: int (optional)\n  Optional. Maximum number of policies to return on a single page (page length). - When not set or set\n  to 0, the page length is set to a server configured value (recommended); - When set to a value\n  greater than 0, the page length is the minimum of this value and a server configured value;\n:param page_token: str (optional)\n  Optional. Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`PolicyInfo`",
        "parameters": [
          {
            "name": "on_securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The type of the securable to list policies for."
          },
          {
            "name": "on_securable_fullname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The fully qualified name of securable to list policies for."
          },
          {
            "name": "include_inherited",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. Whether to include policies defined on parent securables. By default, the inherited policies are not included."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. Maximum number of policies to return on a single page (page length). - When not set or set to 0, the page length is set to a server configured value (recommended); - When set to a value greater than 0, the page length is the minimum of this value and a server configured value;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Optional. Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolicyInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{table_name}/monitor/refreshes/{refresh_id}/cancel": {
      "post": {
        "operationId": "quality_monitors_cancel_refresh",
        "summary": "[DEPRECATED] Cancels an already-initiated refresh job. Use Data Quality Monitors API instead",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Cancels an already-initiated refresh job. Use Data Quality Monitors API instead\n(/api/data-quality/v1/monitors).\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are\n  disallowed.\n:param refresh_id: int",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are disallowed."
          },
          {
            "name": "refresh_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "int"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{table_name}/monitor": {
      "post": {
        "operationId": "quality_monitors_create",
        "summary": "[DEPRECATED] Creates a new monitor for the specified table. Use Data Quality Monitors API instead",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Creates a new monitor for the specified table. Use Data Quality Monitors API instead\n(/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog, have **USE_SCHEMA** on the\ntable's parent schema, and have **SELECT** access on the table 2. have **USE_CATALOG** on the table's\nparent catalog, be an owner of the table's parent schema, and have **SELECT** access on the table. 3.\nhave the following permissions: - **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on\nthe table's parent schema - be an owner of the table.\n\nWorkspace assets, such as the dashboard, will be created in the workspace where this call was made.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. This field corresponds to the\n  {full_table_name_arg} arg in the endpoint path.\n:param output_schema_name: str\n  [Create:REQ Update:REQ] Schema where output tables are created. Needs to be in 2-level format\n  {catalog}.{schema}\n:param assets_dir: str\n  [Create:REQ Update:IGN] Field for specifying the absolute path to a custom directory to store\n  data-monitoring assets. Normally prepopulated to a default user location via UI and Python APIs.\n:param baseline_table_name: str (optional)\n  [Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in\n  the monitored `table_name`. The baseline table and the monitored table shall have the same schema.\n:param custom_metrics: List[:class:`MonitorMetric`] (optional)\n  [Create:OPT Update:OPT] Custom metrics.\n:param data_classification_config: :class:`MonitorDataClassificationConfig` (optional)\n  [Create:OPT Update:OPT] Data classification related config.\n:param inference_log: :class:`MonitorInferenceLog` (optional)\n:param latest_monitor_failure_msg: str (optional)\n  [Create:ERR Update:IGN] The latest error message for a monitor failure.\n:param notifications: :class:`MonitorNotifications` (optional)\n  [Create:OPT Update:OPT] Field for specifying notification settings.\n:param schedule: :class:`MonitorCronSchedule` (optional)\n  [Create:OPT Update:OPT] The monitor schedule.\n:param skip_builtin_dashboard: bool (optional)\n  Whether to skip creating a default dashboard summarizing data quality metrics.\n:param slicing_exprs: List[str] (optional)\n  [Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The\n  data is grouped by each expression independently, resulting in a separate slice for each predicate\n  and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the\n  following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in\n  `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate\n  slices.\n:param snapshot: :class:`MonitorSnapshot` (optional)\n  Configuration for monitoring snapshot tables.\n:param time_series: :class:`MonitorTimeSeries` (optional)\n  Configuration for monitoring time series tables.\n:param warehouse_id: str (optional)\n  Optional argument to specify the warehouse for dashboard creation. If not specified, the first\n  running warehouse will be used.\n\n:returns: :class:`MonitorInfo`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. This field corresponds to the {full_table_name_arg} arg in the endpoint path."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "output_schema_name": {
                    "type": "string",
                    "description": "[Create:REQ Update:REQ] Schema where output tables are created. Needs to be in 2-level format {catalog}.{schema}"
                  },
                  "assets_dir": {
                    "type": "string",
                    "description": "[Create:REQ Update:IGN] Field for specifying the absolute path to a custom directory to store data-monitoring assets. Normally prepopulated to a default user location via UI and Python APIs."
                  },
                  "baseline_table_name": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in the monitored `table_name`. The baseline table and the monitored table shall have the same schema."
                  },
                  "custom_metrics": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Custom metrics."
                  },
                  "data_classification_config": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Data classification related config."
                  },
                  "inference_log": {
                    "type": "string",
                    "description": ":param latest_monitor_failure_msg: str (optional) [Create:ERR Update:IGN] The latest error message for a monitor failure."
                  },
                  "latest_monitor_failure_msg": {
                    "type": "string"
                  },
                  "notifications": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Field for specifying notification settings."
                  },
                  "schedule": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] The monitor schedule."
                  },
                  "skip_builtin_dashboard": {
                    "type": "string",
                    "description": "Whether to skip creating a default dashboard summarizing data quality metrics."
                  },
                  "slicing_exprs": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The data is grouped by each expression independently, resulting in a separate slice for each predicate and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate slices."
                  },
                  "snapshot": {
                    "type": "string",
                    "description": "Configuration for monitoring snapshot tables."
                  },
                  "time_series": {
                    "type": "string",
                    "description": "Configuration for monitoring time series tables."
                  },
                  "warehouse_id": {
                    "type": "string",
                    "description": "Optional argument to specify the warehouse for dashboard creation. If not specified, the first running warehouse will be used."
                  }
                },
                "required": [
                  "output_schema_name",
                  "assets_dir"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "quality_monitors_delete",
        "summary": "[DEPRECATED] Deletes a monitor for the specified table. Use Data Quality Monitors API instead",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Deletes a monitor for the specified table. Use Data Quality Monitors API instead\n(/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an\nowner of the table.\n\nAdditionally, the call must be made from the workspace where the monitor was created.\n\nNote that the metric tables and dashboard will not be deleted as part of this call; those assets must\nbe manually cleaned up (if desired).\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. This field corresponds to the\n  {full_table_name_arg} arg in the endpoint path.\n\n:returns: :class:`DeleteMonitorResponse`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. This field corresponds to the {full_table_name_arg} arg in the endpoint path."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteMonitorResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "quality_monitors_get",
        "summary": "[DEPRECATED] Gets a monitor for the specified table. Use Data Quality Monitors API instead",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Gets a monitor for the specified table. Use Data Quality Monitors API instead\n(/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema. 3. have the following\npermissions: - **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent\nschema - **SELECT** privilege on the table.\n\nThe returned information includes configuration values, as well as information on assets created by\nthe monitor. Some information (e.g., dashboard) may be filtered out if the caller is in a different\nworkspace than where the monitor was created.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. This field corresponds to the\n  {full_table_name_arg} arg in the endpoint path.\n\n:returns: :class:`MonitorInfo`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. This field corresponds to the {full_table_name_arg} arg in the endpoint path."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "quality_monitors_update",
        "summary": "[DEPRECATED] Updates a monitor for the specified table. Use Data Quality Monitors API instead",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Updates a monitor for the specified table. Use Data Quality Monitors API instead\n(/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an\nowner of the table.\n\nAdditionally, the call must be made from the workspace where the monitor was created, and the caller\nmust be the original creator of the monitor.\n\nCertain configuration fields, such as output asset identifiers, cannot be updated.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. This field corresponds to the\n  {full_table_name_arg} arg in the endpoint path.\n:param output_schema_name: str\n  [Create:REQ Update:REQ] Schema where output tables are created. Needs to be in 2-level format\n  {catalog}.{schema}\n:param baseline_table_name: str (optional)\n  [Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in\n  the monitored `table_name`. The baseline table and the monitored table shall have the same schema.\n:param custom_metrics: List[:class:`MonitorMetric`] (optional)\n  [Create:OPT Update:OPT] Custom metrics.\n:param dashboard_id: str (optional)\n  [Create:ERR Update:OPT] Id of dashboard that visualizes the computed metrics. This can be empty if\n  the monitor is in PENDING state.\n:param data_classification_config: :class:`MonitorDataClassificationConfig` (optional)\n  [Create:OPT Update:OPT] Data classification related config.\n:param inference_log: :class:`MonitorInferenceLog` (optional)\n:param latest_monitor_failure_msg: str (optional)\n  [Create:ERR Update:IGN] The latest error message for a monitor failure.\n:param notifications: :class:`MonitorNotifications` (optional)\n  [Create:OPT Update:OPT] Field for specifying notification settings.\n:param schedule: :class:`MonitorCronSchedule` (optional)\n  [Create:OPT Update:OPT] The monitor schedule.\n:param slicing_exprs: List[str] (optional)\n  [Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The\n  data is grouped by each expression independently, resulting in a separate slice for each predicate\n  and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the\n  following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in\n  `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate\n  slices.\n:param snapshot: :class:`MonitorSnapshot` (optional)\n  Configuration for monitoring snapshot tables.\n:param time_series: :class:`MonitorTimeSeries` (optional)\n  Configuration for monitoring time series tables.\n\n:returns: :class:`MonitorInfo`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. This field corresponds to the {full_table_name_arg} arg in the endpoint path."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "output_schema_name": {
                    "type": "string",
                    "description": "[Create:REQ Update:REQ] Schema where output tables are created. Needs to be in 2-level format {catalog}.{schema}"
                  },
                  "baseline_table_name": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in the monitored `table_name`. The baseline table and the monitored table shall have the same schema."
                  },
                  "custom_metrics": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Custom metrics."
                  },
                  "dashboard_id": {
                    "type": "string",
                    "description": "[Create:ERR Update:OPT] Id of dashboard that visualizes the computed metrics. This can be empty if the monitor is in PENDING state."
                  },
                  "data_classification_config": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Data classification related config."
                  },
                  "inference_log": {
                    "type": "string",
                    "description": ":param latest_monitor_failure_msg: str (optional) [Create:ERR Update:IGN] The latest error message for a monitor failure."
                  },
                  "latest_monitor_failure_msg": {
                    "type": "string"
                  },
                  "notifications": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] Field for specifying notification settings."
                  },
                  "schedule": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] The monitor schedule."
                  },
                  "slicing_exprs": {
                    "type": "string",
                    "description": "[Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The data is grouped by each expression independently, resulting in a separate slice for each predicate and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate slices."
                  },
                  "snapshot": {
                    "type": "string",
                    "description": "Configuration for monitoring snapshot tables."
                  },
                  "time_series": {
                    "type": "string",
                    "description": "Configuration for monitoring time series tables."
                  }
                },
                "required": [
                  "output_schema_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{table_name}/monitor/refreshes/{refresh_id}": {
      "get": {
        "operationId": "quality_monitors_get_refresh",
        "summary": "[DEPRECATED] Gets info about a specific monitor refresh using the given refresh ID. Use Data Quality",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Gets info about a specific monitor refresh using the given refresh ID. Use Data Quality\nMonitors API instead (/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema -\n**SELECT** privilege on the table.\n\nAdditionally, the call must be made from the workspace where the monitor was created.\n\n:param table_name: str\n  Full name of the table.\n:param refresh_id: int\n  ID of the refresh.\n\n:returns: :class:`MonitorRefreshInfo`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table."
          },
          {
            "name": "refresh_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "ID of the refresh."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorRefreshInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{table_name}/monitor/refreshes": {
      "get": {
        "operationId": "quality_monitors_list_refreshes",
        "summary": "[DEPRECATED] Gets an array containing the history of the most recent refreshes (up to 25) for this",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Gets an array containing the history of the most recent refreshes (up to 25) for this\ntable. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema -\n**SELECT** privilege on the table.\n\nAdditionally, the call must be made from the workspace where the monitor was created.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are\n  disallowed.\n\n:returns: :class:`MonitorRefreshListResponse`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are disallowed."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorRefreshListResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "quality_monitors_run_refresh",
        "summary": "[DEPRECATED] Queues a metric refresh on the monitor for the specified table. Use Data Quality Monitors",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Queues a metric refresh on the monitor for the specified table. Use Data Quality Monitors\nAPI instead (/api/data-quality/v1/monitors). The refresh will execute in the background.\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an\nowner of the table\n\nAdditionally, the call must be made from the workspace where the monitor was created.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are\n  disallowed.\n\n:returns: :class:`MonitorRefreshInfo`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. table_name is case insensitive and spaces are disallowed."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MonitorRefreshInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/quality-monitoring/tables/{table_name}/monitor/dashboard": {
      "post": {
        "operationId": "quality_monitors_regenerate_dashboard",
        "summary": "[DEPRECATED] Regenerates the monitoring dashboard for the specified table. Use Data Quality Monitors",
        "tags": [
          "catalog",
          "quality_monitors"
        ],
        "description": "[DEPRECATED] Regenerates the monitoring dashboard for the specified table. Use Data Quality Monitors\nAPI instead (/api/data-quality/v1/monitors).\n\nThe caller must either: 1. be an owner of the table's parent catalog 2. have **USE_CATALOG** on the\ntable's parent catalog and be an owner of the table's parent schema 3. have the following permissions:\n- **USE_CATALOG** on the table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an\nowner of the table\n\nThe call must be made from the workspace where the monitor was created. The dashboard will be\nregenerated in the assets directory that was specified when the monitor was created.\n\n:param table_name: str\n  UC table name in format `catalog.schema.table_name`. This field corresponds to the\n  {full_table_name_arg} arg in the endpoint path.\n:param warehouse_id: str (optional)\n  Optional argument to specify the warehouse for dashboard regeneration. If not specified, the first\n  running warehouse will be used.\n\n:returns: :class:`RegenerateDashboardResponse`",
        "parameters": [
          {
            "name": "table_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UC table name in format `catalog.schema.table_name`. This field corresponds to the {full_table_name_arg} arg in the endpoint path."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "warehouse_id": {
                    "type": "string",
                    "description": "Optional argument to specify the warehouse for dashboard regeneration. If not specified, the first running warehouse will be used."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegenerateDashboardResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/models": {
      "post": {
        "operationId": "registered_models_create",
        "summary": "Creates a new registered model in Unity Catalog.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Creates a new registered model in Unity Catalog.\n\nFile storage for model versions in the registered model will be located in the default location which\nis specified by the parent schema, or the parent catalog, or the Metastore.\n\nFor registered model creation to succeed, the user must satisfy the following conditions: - The caller\nmust be a metastore admin, or be the owner of the parent catalog and schema, or have the\n**USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n- The caller must have the **CREATE MODEL** or **CREATE FUNCTION** privilege on the parent schema.\n\n:param aliases: List[:class:`RegisteredModelAlias`] (optional)\n  List of aliases associated with the registered model\n:param browse_only: bool (optional)\n  Indicates whether the principal is limited to retrieving metadata for the associated object through\n  the BROWSE privilege when include_browse is enabled in the request.\n:param catalog_name: str (optional)\n  The name of the catalog where the schema and the registered model reside\n:param comment: str (optional)\n  The comment attached to the registered model\n:param created_at: int (optional)\n  Creation timestamp of the registered model in milliseconds since the Unix epoch\n:param created_by: str (optional)\n  The identifier of the user who created the registered model\n:param full_name: str (optional)\n  The three-level (fully qualified) name of the registered model\n:param metastore_id: str (optional)\n  The unique identifier of the metastore\n:param name: str (optional)\n  The name of the registered model\n:param owner: str (optional)\n  The identifier of the user who owns the registered model\n:param schema_name: str (optional)\n  The name of the schema where the registered model resides\n:param storage_location: str (optional)\n  The storage location on the cloud under which model version data files are stored\n:param updated_at: int (optional)\n  Last-update timestamp of the registered model in milliseconds since the Unix epoch\n:param updated_by: str (optional)\n  The identifier of the user who updated the registered model last time\n\n:returns: :class:`RegisteredModelInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aliases": {
                    "type": "string",
                    "description": "List of aliases associated with the registered model"
                  },
                  "browse_only": {
                    "type": "string",
                    "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
                  },
                  "catalog_name": {
                    "type": "string",
                    "description": "The name of the catalog where the schema and the registered model reside"
                  },
                  "comment": {
                    "type": "string",
                    "description": "The comment attached to the registered model"
                  },
                  "created_at": {
                    "type": "string",
                    "description": "Creation timestamp of the registered model in milliseconds since the Unix epoch"
                  },
                  "created_by": {
                    "type": "string",
                    "description": "The identifier of the user who created the registered model"
                  },
                  "full_name": {
                    "type": "string",
                    "description": "The three-level (fully qualified) name of the registered model"
                  },
                  "metastore_id": {
                    "type": "string",
                    "description": "The unique identifier of the metastore"
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the registered model"
                  },
                  "owner": {
                    "type": "string",
                    "description": "The identifier of the user who owns the registered model"
                  },
                  "schema_name": {
                    "type": "string",
                    "description": "The name of the schema where the registered model resides"
                  },
                  "storage_location": {
                    "type": "string",
                    "description": "The storage location on the cloud under which model version data files are stored"
                  },
                  "updated_at": {
                    "type": "string",
                    "description": "Last-update timestamp of the registered model in milliseconds since the Unix epoch"
                  },
                  "updated_by": {
                    "type": "string",
                    "description": "The identifier of the user who updated the registered model last time"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "registered_models_list",
        "summary": "List registered models. You can list registered models under a particular schema, or list all",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "List registered models. You can list registered models under a particular schema, or list all\nregistered models in the current metastore.\n\nThe returned models are filtered based on the privileges of the calling user. For example, the\nmetastore admin is able to list all the registered models. A regular user needs to be the owner or\nhave the **EXECUTE** privilege on the registered model to recieve the registered models in the\nresponse. For the latter case, the caller must also be the owner or have the **USE_CATALOG** privilege\non the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\nThere is no guarantee of a specific ordering of the elements in the response.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param catalog_name: str (optional)\n  The identifier of the catalog under which to list registered models. If specified, schema_name must\n  be specified.\n:param include_browse: bool (optional)\n  Whether to include registered models in the response for which the principal can only access\n  selective metadata for\n:param max_results: int (optional)\n  Max number of registered models to return.\n\n  If both catalog and schema are specified: - when max_results is not specified, the page length is\n  set to a server configured value (10000, as of 4/2/2024). - when set to a value greater than 0, the\n  page length is the minimum of this value and a server configured value (10000, as of 4/2/2024); -\n  when set to 0, the page length is set to a server configured value (10000, as of 4/2/2024); - when\n  set to a value less than 0, an invalid parameter error is returned;\n\n  If neither schema nor catalog is specified: - when max_results is not specified, the page length is\n  set to a server configured value (100, as of 4/2/2024). - when set to a value greater than 0, the\n  page length is the minimum of this value and a server configured value (1000, as of 4/2/2024); -\n  when set to 0, the page length is set to a server configured value (100, as of 4/2/2024); - when set\n  to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque token to send for the next page of results (pagination).\n:param schema_name: str (optional)\n  The identifier of the schema under which to list registered models. If specified, catalog_name must\n  be specified.\n\n:returns: Iterator over :class:`RegisteredModelInfo`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of the catalog under which to list registered models. If specified, schema_name must be specified."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include registered models in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Max number of registered models to return. If both catalog and schema are specified: - when max_results is not specified, the page length is set to a server configured value (10000, as of 4/2/2024). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value (10000, as of 4/2/2024); - when set to 0, the page length is set to a server configured value (10000, as of 4/2/2024); - when set to a value less than 0, an invalid parameter error is returned; If neither schema nor catalog is specified: - when max_results is not specified, the page length is set to a server configured value (100, as of 4/2/2024). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value (1000, as of 4/2/2024); - when set to 0, the page length is set to a server configured value (100, as of 4/2/2024); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token to send for the next page of results (pagination)."
          },
          {
            "name": "schema_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of the schema under which to list registered models. If specified, catalog_name must be specified."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/models/{full_name}": {
      "delete": {
        "operationId": "registered_models_delete",
        "summary": "Deletes a registered model and all its model versions from the specified parent catalog and schema.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Deletes a registered model and all its model versions from the specified parent catalog and schema.\n\nThe caller must be a metastore admin or an owner of the registered model. For the latter case, the\ncaller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "registered_models_get",
        "summary": "Get a registered model.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Get a registered model.\n\nThe caller must be a metastore admin or an owner of (or have the **EXECUTE** privilege on) the\nregistered model. For the latter case, the caller must also be the owner or have the **USE_CATALOG**\nprivilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model\n:param include_aliases: bool (optional)\n  Whether to include registered model aliases in the response\n:param include_browse: bool (optional)\n  Whether to include registered models in the response for which the principal can only access\n  selective metadata for\n\n:returns: :class:`RegisteredModelInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          },
          {
            "name": "include_aliases",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include registered model aliases in the response"
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include registered models in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "registered_models_update",
        "summary": "Updates the specified registered model.",
        "tags": [
          "catalog",
          "registered_models"
        ],
        "description": "Updates the specified registered model.\n\nThe caller must be a metastore admin or an owner of the registered model. For the latter case, the\ncaller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\nCurrently only the name, the owner or the comment of the registered model can be updated.\n\n:param full_name: str\n  The three-level (fully qualified) name of the registered model\n:param aliases: List[:class:`RegisteredModelAlias`] (optional)\n  List of aliases associated with the registered model\n:param browse_only: bool (optional)\n  Indicates whether the principal is limited to retrieving metadata for the associated object through\n  the BROWSE privilege when include_browse is enabled in the request.\n:param catalog_name: str (optional)\n  The name of the catalog where the schema and the registered model reside\n:param comment: str (optional)\n  The comment attached to the registered model\n:param created_at: int (optional)\n  Creation timestamp of the registered model in milliseconds since the Unix epoch\n:param created_by: str (optional)\n  The identifier of the user who created the registered model\n:param metastore_id: str (optional)\n  The unique identifier of the metastore\n:param name: str (optional)\n  The name of the registered model\n:param new_name: str (optional)\n  New name for the registered model.\n:param owner: str (optional)\n  The identifier of the user who owns the registered model\n:param schema_name: str (optional)\n  The name of the schema where the registered model resides\n:param storage_location: str (optional)\n  The storage location on the cloud under which model version data files are stored\n:param updated_at: int (optional)\n  Last-update timestamp of the registered model in milliseconds since the Unix epoch\n:param updated_by: str (optional)\n  The identifier of the user who updated the registered model last time\n\n:returns: :class:`RegisteredModelInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the registered model"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aliases": {
                    "type": "string",
                    "description": "List of aliases associated with the registered model"
                  },
                  "browse_only": {
                    "type": "string",
                    "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
                  },
                  "catalog_name": {
                    "type": "string",
                    "description": "The name of the catalog where the schema and the registered model reside"
                  },
                  "comment": {
                    "type": "string",
                    "description": "The comment attached to the registered model"
                  },
                  "created_at": {
                    "type": "string",
                    "description": "Creation timestamp of the registered model in milliseconds since the Unix epoch"
                  },
                  "created_by": {
                    "type": "string",
                    "description": "The identifier of the user who created the registered model"
                  },
                  "metastore_id": {
                    "type": "string",
                    "description": "The unique identifier of the metastore"
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the registered model"
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the registered model."
                  },
                  "owner": {
                    "type": "string",
                    "description": "The identifier of the user who owns the registered model"
                  },
                  "schema_name": {
                    "type": "string",
                    "description": "The name of the schema where the registered model resides"
                  },
                  "storage_location": {
                    "type": "string",
                    "description": "The storage location on the cloud under which model version data files are stored"
                  },
                  "updated_at": {
                    "type": "string",
                    "description": "Last-update timestamp of the registered model in milliseconds since the Unix epoch"
                  },
                  "updated_by": {
                    "type": "string",
                    "description": "The identifier of the user who updated the registered model last time"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisteredModelInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/resource-quotas/{parent_securable_type}/{parent_full_name}/{quota_name}": {
      "get": {
        "operationId": "resource_quotas_get_quota",
        "summary": "The GetQuota API returns usage information for a single resource quota, defined as a child-parent",
        "tags": [
          "catalog",
          "resource_quotas"
        ],
        "description": "The GetQuota API returns usage information for a single resource quota, defined as a child-parent\npair. This API also refreshes the quota count if it is out of date. Refreshes are triggered\nasynchronously. The updated count might not be returned in the first call.\n\n:param parent_securable_type: str\n  Securable type of the quota parent.\n:param parent_full_name: str\n  Full name of the parent resource. Provide the metastore ID if the parent is a metastore.\n:param quota_name: str\n  Name of the quota. Follows the pattern of the quota type, with \"-quota\" added as a suffix.\n\n:returns: :class:`GetQuotaResponse`",
        "parameters": [
          {
            "name": "parent_securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Securable type of the quota parent."
          },
          {
            "name": "parent_full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the parent resource. Provide the metastore ID if the parent is a metastore."
          },
          {
            "name": "quota_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the quota. Follows the pattern of the quota type, with \"-quota\" added as a suffix."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetQuotaResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/resource-quotas/all-resource-quotas": {
      "get": {
        "operationId": "resource_quotas_list_quotas",
        "summary": "ListQuotas returns all quota values under the metastore. There are no SLAs on the freshness of the",
        "tags": [
          "catalog",
          "resource_quotas"
        ],
        "description": "ListQuotas returns all quota values under the metastore. There are no SLAs on the freshness of the\ncounts returned. This API does not trigger a refresh of quota counts.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param max_results: int (optional)\n  The number of quotas to return.\n:param page_token: str (optional)\n  Opaque token for the next page of results.\n\n:returns: Iterator over :class:`QuotaInfo`",
        "parameters": [
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The number of quotas to return."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token for the next page of results."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuotaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/3.0/rfa/requests": {
      "post": {
        "operationId": "rfa_batch_create_access_requests",
        "summary": "Creates access requests for Unity Catalog permissions for a specified principal on a securable object.",
        "tags": [
          "catalog",
          "rfa"
        ],
        "description": "Creates access requests for Unity Catalog permissions for a specified principal on a securable object.\nThis Batch API can take in multiple principals, securable objects, and permissions as the input and\nreturns the access request destinations for each. Principals must be unique across the API call.\n\nThe supported securable types are: \"metastore\", \"catalog\", \"schema\", \"table\", \"external_location\",\n\"connection\", \"credential\", \"function\", \"registered_model\", and \"volume\".\n\n:param requests: List[:class:`CreateAccessRequest`] (optional)\n  A list of individual access requests, where each request corresponds to a set of permissions being\n  requested on a list of securables for a specified principal.\n\n  At most 30 requests per API call.\n\n:returns: :class:`BatchCreateAccessRequestsResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "requests": {
                    "type": "string",
                    "description": "A list of individual access requests, where each request corresponds to a set of permissions being requested on a list of securables for a specified principal. At most 30 requests per API call."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchCreateAccessRequestsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/3.0/rfa/destinations/{securable_type}/{full_name}": {
      "get": {
        "operationId": "rfa_get_access_request_destinations",
        "summary": "Gets an array of access request destinations for the specified securable. Any caller can see URL",
        "tags": [
          "catalog",
          "rfa"
        ],
        "description": "Gets an array of access request destinations for the specified securable. Any caller can see URL\ndestinations or the destinations on the metastore. Otherwise, only those with **BROWSE** permissions\non the securable can see destinations.\n\nThe supported securable types are: \"metastore\", \"catalog\", \"schema\", \"table\", \"external_location\",\n\"connection\", \"credential\", \"function\", \"registered_model\", and \"volume\".\n\n:param securable_type: str\n  The type of the securable.\n:param full_name: str\n  The full name of the securable.\n\n:returns: :class:`AccessRequestDestinations`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the securable."
          },
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The full name of the securable."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccessRequestDestinations"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/3.0/rfa/destinations": {
      "patch": {
        "operationId": "rfa_update_access_request_destinations",
        "summary": "Updates the access request destinations for the given securable. The caller must be a metastore admin,",
        "tags": [
          "catalog",
          "rfa"
        ],
        "description": "Updates the access request destinations for the given securable. The caller must be a metastore admin,\nthe owner of the securable, or a user that has the **MANAGE** privilege on the securable in order to\nassign destinations. Destinations cannot be updated for securables underneath schemas (tables,\nvolumes, functions, and models). For these securable types, destinations are inherited from the parent\nsecurable. A maximum of 5 emails and 5 external notification destinations (Slack, Microsoft Teams, and\nGeneric Webhook destinations) can be assigned to a securable. If a URL destination is assigned, no\nother destinations can be set.\n\nThe supported securable types are: \"metastore\", \"catalog\", \"schema\", \"table\", \"external_location\",\n\"connection\", \"credential\", \"function\", \"registered_model\", and \"volume\".\n\n:param access_request_destinations: :class:`AccessRequestDestinations`\n  The access request destinations to assign to the securable. For each destination, a\n  **destination_id** and **destination_type** must be defined.\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n\n:returns: :class:`AccessRequestDestinations`",
        "parameters": [
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_request_destinations": {
                    "type": "string",
                    "description": "The access request destinations to assign to the securable. For each destination, a **destination_id** and **destination_type** must be defined."
                  }
                },
                "required": [
                  "access_request_destinations"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccessRequestDestinations"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/schemas": {
      "post": {
        "operationId": "schemas_create",
        "summary": "Creates a new schema for catalog in the Metastore. The caller must be a metastore admin, or have the",
        "tags": [
          "catalog",
          "schemas"
        ],
        "description": "Creates a new schema for catalog in the Metastore. The caller must be a metastore admin, or have the\n**CREATE_SCHEMA** privilege in the parent catalog.\n\n:param name: str\n  Name of schema, relative to parent catalog.\n:param catalog_name: str\n  Name of parent catalog.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n:param storage_root: str (optional)\n  Storage root URL for managed tables within schema.\n\n:returns: :class:`SchemaInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of schema, relative to parent catalog."
                  },
                  "catalog_name": {
                    "type": "string",
                    "description": "Name of parent catalog."
                  },
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  },
                  "storage_root": {
                    "type": "string",
                    "description": "Storage root URL for managed tables within schema."
                  }
                },
                "required": [
                  "name",
                  "catalog_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "schemas_list",
        "summary": "Gets an array of schemas for a catalog in the metastore. If the caller is the metastore admin or the",
        "tags": [
          "catalog",
          "schemas"
        ],
        "description": "Gets an array of schemas for a catalog in the metastore. If the caller is the metastore admin or the\nowner of the parent catalog, all schemas for the catalog will be retrieved. Otherwise, only schemas\nowned by the caller (or for which the caller has the **USE_SCHEMA** privilege) will be retrieved.\nThere is no guarantee of a specific ordering of the elements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param catalog_name: str\n  Parent catalog for schemas of interest.\n:param include_browse: bool (optional)\n  Whether to include schemas in the response for which the principal can only access selective\n  metadata for\n:param max_results: int (optional)\n  Maximum number of schemas to return. If not set, all the schemas are returned (not recommended). -\n  when set to a value greater than 0, the page length is the minimum of this value and a server\n  configured value; - when set to 0, the page length is set to a server configured value\n  (recommended); - when set to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`SchemaInfo`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Parent catalog for schemas of interest."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include schemas in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of schemas to return. If not set, all the schemas are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/schemas/{full_name}": {
      "delete": {
        "operationId": "schemas_delete",
        "summary": "Deletes the specified schema from the parent catalog. The caller must be the owner of the schema or an",
        "tags": [
          "catalog",
          "schemas"
        ],
        "description": "Deletes the specified schema from the parent catalog. The caller must be the owner of the schema or an\nowner of the parent catalog.\n\n:param full_name: str\n  Full name of the schema.\n:param force: bool (optional)\n  Force deletion even if the schema is not empty.",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the schema."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force deletion even if the schema is not empty."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "schemas_get",
        "summary": "Gets the specified schema within the metastore. The caller must be a metastore admin, the owner of the",
        "tags": [
          "catalog",
          "schemas"
        ],
        "description": "Gets the specified schema within the metastore. The caller must be a metastore admin, the owner of the\nschema, or a user that has the **USE_SCHEMA** privilege on the schema.\n\n:param full_name: str\n  Full name of the schema.\n:param include_browse: bool (optional)\n  Whether to include schemas in the response for which the principal can only access selective\n  metadata for\n\n:returns: :class:`SchemaInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the schema."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include schemas in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "schemas_update",
        "summary": "Updates a schema for a catalog. The caller must be the owner of the schema or a metastore admin. If",
        "tags": [
          "catalog",
          "schemas"
        ],
        "description": "Updates a schema for a catalog. The caller must be the owner of the schema or a metastore admin. If\nthe caller is a metastore admin, only the __owner__ field can be changed in the update. If the\n__name__ field must be updated, the caller must be a metastore admin or have the **CREATE_SCHEMA**\nprivilege on the parent catalog.\n\n:param full_name: str\n  Full name of the schema.\n:param comment: str (optional)\n  User-provided free-form text description.\n:param enable_predictive_optimization: :class:`EnablePredictiveOptimization` (optional)\n  Whether predictive optimization should be enabled for this object and objects under it.\n:param new_name: str (optional)\n  New name for the schema.\n:param owner: str (optional)\n  Username of current owner of schema.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n\n:returns: :class:`SchemaInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the schema."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "comment": {
                    "type": "string",
                    "description": "User-provided free-form text description."
                  },
                  "enable_predictive_optimization": {
                    "type": "string",
                    "description": "Whether predictive optimization should be enabled for this object and objects under it."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the schema."
                  },
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of schema."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/storage-credentials": {
      "post": {
        "operationId": "storage_credentials_create",
        "summary": "Creates a new storage credential.",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Creates a new storage credential.\n\nThe caller must be a metastore admin or have the **CREATE_STORAGE_CREDENTIAL** privilege on the\nmetastore.\n\n:param name: str\n  The credential name. The name must be unique among storage and service credentials within the\n  metastore.\n:param aws_iam_role: :class:`AwsIamRoleRequest` (optional)\n  The AWS IAM role configuration.\n:param azure_managed_identity: :class:`AzureManagedIdentityRequest` (optional)\n  The Azure managed identity configuration.\n:param azure_service_principal: :class:`AzureServicePrincipal` (optional)\n  The Azure service principal configuration.\n:param cloudflare_api_token: :class:`CloudflareApiToken` (optional)\n  The Cloudflare API token configuration.\n:param comment: str (optional)\n  Comment associated with the credential.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccountRequest` (optional)\n  The Databricks managed GCP service account configuration.\n:param read_only: bool (optional)\n  Whether the credential is usable only for read operations. Only applicable when purpose is\n  **STORAGE**.\n:param skip_validation: bool (optional)\n  Supplying true to this argument skips validation of the created credential.\n\n:returns: :class:`StorageCredentialInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
                  },
                  "aws_iam_role": {
                    "type": "string",
                    "description": "The AWS IAM role configuration."
                  },
                  "azure_managed_identity": {
                    "type": "string",
                    "description": "The Azure managed identity configuration."
                  },
                  "azure_service_principal": {
                    "type": "string",
                    "description": "The Azure service principal configuration."
                  },
                  "cloudflare_api_token": {
                    "type": "string",
                    "description": "The Cloudflare API token configuration."
                  },
                  "comment": {
                    "type": "string",
                    "description": "Comment associated with the credential."
                  },
                  "databricks_gcp_service_account": {
                    "type": "string",
                    "description": "The Databricks managed GCP service account configuration."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                  },
                  "skip_validation": {
                    "type": "string",
                    "description": "Supplying true to this argument skips validation of the created credential."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "storage_credentials_list",
        "summary": "Gets an array of storage credentials (as __StorageCredentialInfo__ objects). The array is limited to",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Gets an array of storage credentials (as __StorageCredentialInfo__ objects). The array is limited to\nonly those storage credentials the caller has permission to access. If the caller is a metastore\nadmin, retrieval of credentials is unrestricted. There is no guarantee of a specific ordering of the\nelements in the array.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param include_unbound: bool (optional)\n  Whether to include credentials not bound to the workspace. Effective only if the user has permission\n  to update the credential\u2013workspace binding.\n:param max_results: int (optional)\n  Maximum number of storage credentials to return. If not set, all the storage credentials are\n  returned (not recommended). - when set to a value greater than 0, the page length is the minimum of\n  this value and a server configured value; - when set to 0, the page length is set to a server\n  configured value (recommended); - when set to a value less than 0, an invalid parameter error is\n  returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`StorageCredentialInfo`",
        "parameters": [
          {
            "name": "include_unbound",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include credentials not bound to the workspace. Effective only if the user has permission to update the credential\u2013workspace binding."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of storage credentials to return. If not set, all the storage credentials are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/storage-credentials/{name}": {
      "delete": {
        "operationId": "storage_credentials_delete",
        "summary": "Deletes a storage credential from the metastore. The caller must be an owner of the storage",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Deletes a storage credential from the metastore. The caller must be an owner of the storage\ncredential.\n\n:param name: str\n  Name of the storage credential.\n:param force: bool (optional)\n  Force an update even if there are dependent external locations or external tables (when purpose is\n  **STORAGE**) or dependent services (when purpose is **SERVICE**).",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the storage credential."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Force an update even if there are dependent external locations or external tables (when purpose is **STORAGE**) or dependent services (when purpose is **SERVICE**)."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "storage_credentials_get",
        "summary": "Gets a storage credential from the metastore. The caller must be a metastore admin, the owner of the",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Gets a storage credential from the metastore. The caller must be a metastore admin, the owner of the\nstorage credential, or have some permission on the storage credential.\n\n:param name: str\n  Name of the storage credential.\n\n:returns: :class:`StorageCredentialInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the storage credential."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "storage_credentials_update",
        "summary": "Updates a storage credential on the metastore.",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Updates a storage credential on the metastore.\n\nThe caller must be the owner of the storage credential or a metastore admin. If the caller is a\nmetastore admin, only the **owner** field can be changed.\n\n:param name: str\n  Name of the storage credential.\n:param aws_iam_role: :class:`AwsIamRoleRequest` (optional)\n  The AWS IAM role configuration.\n:param azure_managed_identity: :class:`AzureManagedIdentityResponse` (optional)\n  The Azure managed identity configuration.\n:param azure_service_principal: :class:`AzureServicePrincipal` (optional)\n  The Azure service principal configuration.\n:param cloudflare_api_token: :class:`CloudflareApiToken` (optional)\n  The Cloudflare API token configuration.\n:param comment: str (optional)\n  Comment associated with the credential.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccountRequest` (optional)\n  The Databricks managed GCP service account configuration.\n:param force: bool (optional)\n  Force update even if there are dependent external locations or external tables.\n:param isolation_mode: :class:`IsolationMode` (optional)\n  Whether the current securable is accessible from all workspaces or a specific set of workspaces.\n:param new_name: str (optional)\n  New name for the storage credential.\n:param owner: str (optional)\n  Username of current owner of credential.\n:param read_only: bool (optional)\n  Whether the credential is usable only for read operations. Only applicable when purpose is\n  **STORAGE**.\n:param skip_validation: bool (optional)\n  Supplying true to this argument skips validation of the updated credential.\n\n:returns: :class:`StorageCredentialInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the storage credential."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aws_iam_role": {
                    "type": "string",
                    "description": "The AWS IAM role configuration."
                  },
                  "azure_managed_identity": {
                    "type": "string",
                    "description": "The Azure managed identity configuration."
                  },
                  "azure_service_principal": {
                    "type": "string",
                    "description": "The Azure service principal configuration."
                  },
                  "cloudflare_api_token": {
                    "type": "string",
                    "description": "The Cloudflare API token configuration."
                  },
                  "comment": {
                    "type": "string",
                    "description": "Comment associated with the credential."
                  },
                  "databricks_gcp_service_account": {
                    "type": "string",
                    "description": "The Databricks managed GCP service account configuration."
                  },
                  "force": {
                    "type": "string",
                    "description": "Force update even if there are dependent external locations or external tables."
                  },
                  "isolation_mode": {
                    "type": "string",
                    "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the storage credential."
                  },
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of credential."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                  },
                  "skip_validation": {
                    "type": "string",
                    "description": "Supplying true to this argument skips validation of the updated credential."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/validate-storage-credentials": {
      "post": {
        "operationId": "storage_credentials_validate",
        "summary": "Validates a storage credential. At least one of __external_location_name__ and __url__ need to be",
        "tags": [
          "catalog",
          "storage_credentials"
        ],
        "description": "Validates a storage credential. At least one of __external_location_name__ and __url__ need to be\nprovided. If only one of them is provided, it will be used for validation. And if both are provided,\nthe __url__ will be used for validation, and __external_location_name__ will be ignored when checking\noverlapping urls.\n\nEither the __storage_credential_name__ or the cloud-specific credential must be provided.\n\nThe caller must be a metastore admin or the storage credential owner or have the\n**CREATE_EXTERNAL_LOCATION** privilege on the metastore and the storage credential.\n\n:param aws_iam_role: :class:`AwsIamRoleRequest` (optional)\n  The AWS IAM role configuration.\n:param azure_managed_identity: :class:`AzureManagedIdentityRequest` (optional)\n  The Azure managed identity configuration.\n:param azure_service_principal: :class:`AzureServicePrincipal` (optional)\n  The Azure service principal configuration.\n:param cloudflare_api_token: :class:`CloudflareApiToken` (optional)\n  The Cloudflare API token configuration.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccountRequest` (optional)\n  The Databricks created GCP service account configuration.\n:param external_location_name: str (optional)\n  The name of an existing external location to validate.\n:param read_only: bool (optional)\n  Whether the storage credential is only usable for read operations.\n:param storage_credential_name: str (optional)\n  Required. The name of an existing credential or long-lived cloud credential to validate.\n:param url: str (optional)\n  The external location url to validate.\n\n:returns: :class:`ValidateStorageCredentialResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aws_iam_role": {
                    "type": "string",
                    "description": "The AWS IAM role configuration."
                  },
                  "azure_managed_identity": {
                    "type": "string",
                    "description": "The Azure managed identity configuration."
                  },
                  "azure_service_principal": {
                    "type": "string",
                    "description": "The Azure service principal configuration."
                  },
                  "cloudflare_api_token": {
                    "type": "string",
                    "description": "The Cloudflare API token configuration."
                  },
                  "databricks_gcp_service_account": {
                    "type": "string",
                    "description": "The Databricks created GCP service account configuration."
                  },
                  "external_location_name": {
                    "type": "string",
                    "description": "The name of an existing external location to validate."
                  },
                  "read_only": {
                    "type": "string",
                    "description": "Whether the storage credential is only usable for read operations."
                  },
                  "storage_credential_name": {
                    "type": "string",
                    "description": "Required. The name of an existing credential or long-lived cloud credential to validate."
                  },
                  "url": {
                    "type": "string",
                    "description": "The external location url to validate."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateStorageCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/metastores/{metastore_id}/systemschemas/{schema_name}": {
      "delete": {
        "operationId": "system_schemas_disable",
        "summary": "Disables the system schema and removes it from the system catalog. The caller must be an account admin",
        "tags": [
          "catalog",
          "system_schemas"
        ],
        "description": "Disables the system schema and removes it from the system catalog. The caller must be an account admin\nor a metastore admin.\n\n:param metastore_id: str\n  The metastore ID under which the system schema lives.\n:param schema_name: str\n  Full name of the system schema.",
        "parameters": [
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The metastore ID under which the system schema lives."
          },
          {
            "name": "schema_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the system schema."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "system_schemas_enable",
        "summary": "Enables the system schema and adds it to the system catalog. The caller must be an account admin or a",
        "tags": [
          "catalog",
          "system_schemas"
        ],
        "description": "Enables the system schema and adds it to the system catalog. The caller must be an account admin or a\nmetastore admin.\n\n:param metastore_id: str\n  The metastore ID under which the system schema lives.\n:param schema_name: str\n  Full name of the system schema.\n:param catalog_name: str (optional)\n  the catalog for which the system schema is to enabled in",
        "parameters": [
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The metastore ID under which the system schema lives."
          },
          {
            "name": "schema_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the system schema."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "catalog_name": {
                    "type": "string",
                    "description": "the catalog for which the system schema is to enabled in"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/metastores/{metastore_id}/systemschemas": {
      "get": {
        "operationId": "system_schemas_list",
        "summary": "Gets an array of system schemas for a metastore. The caller must be an account admin or a metastore",
        "tags": [
          "catalog",
          "system_schemas"
        ],
        "description": "Gets an array of system schemas for a metastore. The caller must be an account admin or a metastore\nadmin.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param metastore_id: str\n  The ID for the metastore in which the system schema resides.\n:param max_results: int (optional)\n  Maximum number of schemas to return. - When set to 0, the page length is set to a server configured\n  value (recommended); - When set to a value greater than 0, the page length is the minimum of this\n  value and a server configured value; - When set to a value less than 0, an invalid parameter error\n  is returned; - If not set, all the schemas are returned (not recommended).\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`SystemSchemaInfo`",
        "parameters": [
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID for the metastore in which the system schema resides."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of schemas to return. - When set to 0, the page length is set to a server configured value (recommended); - When set to a value greater than 0, the page length is the minimum of this value and a server configured value; - When set to a value less than 0, an invalid parameter error is returned; - If not set, all the schemas are returned (not recommended)."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SystemSchemaInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/constraints": {
      "post": {
        "operationId": "table_constraints_create",
        "summary": "Creates a new table constraint.",
        "tags": [
          "catalog",
          "table_constraints"
        ],
        "description": "Creates a new table constraint.\n\nFor the table constraint creation to succeed, the user must satisfy both of these conditions: - the\nuser must have the **USE_CATALOG** privilege on the table's parent catalog, the **USE_SCHEMA**\nprivilege on the table's parent schema, and be the owner of the table. - if the new constraint is a\n__ForeignKeyConstraint__, the user must have the **USE_CATALOG** privilege on the referenced parent\ntable's catalog, the **USE_SCHEMA** privilege on the referenced parent table's schema, and be the\nowner of the referenced parent table.\n\n:param full_name_arg: str\n  The full name of the table referenced by the constraint.\n:param constraint: :class:`TableConstraint`\n\n:returns: :class:`TableConstraint`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "full_name_arg": {
                    "type": "string",
                    "description": "The full name of the table referenced by the constraint."
                  },
                  "constraint": {
                    "type": "string",
                    "description": ":returns: :class:`TableConstraint`"
                  }
                },
                "required": [
                  "full_name_arg",
                  "constraint"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableConstraint"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/constraints/{full_name}": {
      "delete": {
        "operationId": "table_constraints_delete",
        "summary": "Deletes a table constraint.",
        "tags": [
          "catalog",
          "table_constraints"
        ],
        "description": "Deletes a table constraint.\n\nFor the table constraint deletion to succeed, the user must satisfy both of these conditions: - the\nuser must have the **USE_CATALOG** privilege on the table's parent catalog, the **USE_SCHEMA**\nprivilege on the table's parent schema, and be the owner of the table. - if __cascade__ argument is\n**true**, the user must have the following permissions on all of the child tables: the **USE_CATALOG**\nprivilege on the table's catalog, the **USE_SCHEMA** privilege on the table's schema, and be the owner\nof the table.\n\n:param full_name: str\n  Full name of the table referenced by the constraint.\n:param constraint_name: str\n  The name of the constraint to delete.\n:param cascade: bool\n  If true, try deleting all child constraints of the current constraint. If false, reject this\n  operation if the current constraint has any child constraints.",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table referenced by the constraint."
          },
          {
            "name": "constraint_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the constraint to delete."
          },
          {
            "name": "cascade",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            },
            "description": "If true, try deleting all child constraints of the current constraint. If false, reject this operation if the current constraint has any child constraints."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables": {
      "post": {
        "operationId": "tables_create",
        "summary": "Creates a new table in the specified catalog and schema.",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Creates a new table in the specified catalog and schema.\n\nTo create an external delta table, the caller must have the **EXTERNAL_USE_SCHEMA** privilege on the\nparent schema and the **EXTERNAL_USE_LOCATION** privilege on the external location. These privileges\nmust always be granted explicitly, and cannot be inherited through ownership or **ALL_PRIVILEGES**.\n\nStandard UC permissions needed to create tables still apply: **USE_CATALOG** on the parent catalog (or\nownership of the parent catalog), **CREATE_TABLE** and **USE_SCHEMA** on the parent schema (or\nownership of the parent schema), and **CREATE_EXTERNAL_TABLE** on external location.\n\nThe **columns** field needs to be in a Spark compatible format, so we recommend you use Spark to\ncreate these tables. The API itself does not validate the correctness of the column spec. If the spec\nis not Spark compatible, the tables may not be readable by Databricks Runtime.\n\nNOTE: The Create Table API for external clients only supports creating **external delta tables**. The\nvalues shown in the respective enums are all values supported by Databricks, however for this specific\nCreate Table API, only **table_type** **EXTERNAL** and **data_source_format** **DELTA** are supported.\nAdditionally, column masks are not supported when creating tables through this API.\n\n:param name: str\n  Name of table, relative to parent schema.\n:param catalog_name: str\n  Name of parent catalog.\n:param schema_name: str\n  Name of parent schema relative to its parent catalog.\n:param table_type: :class:`TableType`\n:param data_source_format: :class:`DataSourceFormat`\n:param storage_location: str\n  Storage root URL for table (for **MANAGED**, **EXTERNAL** tables).\n:param columns: List[:class:`ColumnInfo`] (optional)\n  The array of __ColumnInfo__ definitions of the table's columns.\n:param properties: Dict[str,str] (optional)\n  A map of key-value properties attached to the securable.\n\n:returns: :class:`TableInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of table, relative to parent schema."
                  },
                  "catalog_name": {
                    "type": "string",
                    "description": "Name of parent catalog."
                  },
                  "schema_name": {
                    "type": "string",
                    "description": "Name of parent schema relative to its parent catalog."
                  },
                  "table_type": {
                    "type": "string",
                    "description": ":param data_source_format: :class:`DataSourceFormat`"
                  },
                  "data_source_format": {
                    "type": "string"
                  },
                  "storage_location": {
                    "type": "string",
                    "description": "Storage root URL for table (for **MANAGED**, **EXTERNAL** tables)."
                  },
                  "columns": {
                    "type": "string",
                    "description": "The array of __ColumnInfo__ definitions of the table's columns."
                  },
                  "properties": {
                    "type": "string",
                    "description": "A map of key-value properties attached to the securable."
                  }
                },
                "required": [
                  "name",
                  "catalog_name",
                  "schema_name",
                  "table_type",
                  "data_source_format",
                  "storage_location"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "tables_list",
        "summary": "Gets an array of all tables for the current metastore under the parent catalog and schema. The caller",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Gets an array of all tables for the current metastore under the parent catalog and schema. The caller\nmust be a metastore admin or an owner of (or have the **SELECT** privilege on) the table. For the\nlatter case, the caller must also be the owner or have the **USE_CATALOG** privilege on the parent\ncatalog and the **USE_SCHEMA** privilege on the parent schema. There is no guarantee of a specific\nordering of the elements in the array.\n\nNOTE: **view_dependencies** and **table_constraints** are not returned by ListTables queries.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param catalog_name: str\n  Name of parent catalog for tables of interest.\n:param schema_name: str\n  Parent schema of tables.\n:param include_browse: bool (optional)\n  Whether to include tables in the response for which the principal can only access selective metadata\n  for.\n:param include_manifest_capabilities: bool (optional)\n  Whether to include a manifest containing table capabilities in the response.\n:param max_results: int (optional)\n  Maximum number of tables to return. If not set, all the tables are returned (not recommended). -\n  when set to a value greater than 0, the page length is the minimum of this value and a server\n  configured value; - when set to 0, the page length is set to a server configured value\n  (recommended); - when set to a value less than 0, an invalid parameter error is returned;\n:param omit_columns: bool (optional)\n  Whether to omit the columns of the table from the response or not.\n:param omit_properties: bool (optional)\n  Whether to omit the properties of the table from the response or not.\n:param omit_username: bool (optional)\n  Whether to omit the username of the table (e.g. owner, updated_by, created_by) from the response or\n  not.\n:param page_token: str (optional)\n  Opaque token to send for the next page of results (pagination).\n\n:returns: Iterator over :class:`TableInfo`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of parent catalog for tables of interest."
          },
          {
            "name": "schema_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Parent schema of tables."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include tables in the response for which the principal can only access selective metadata for."
          },
          {
            "name": "include_manifest_capabilities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include a manifest containing table capabilities in the response."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of tables to return. If not set, all the tables are returned (not recommended). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value; - when set to 0, the page length is set to a server configured value (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "omit_columns",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to omit the columns of the table from the response or not."
          },
          {
            "name": "omit_properties",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to omit the properties of the table from the response or not."
          },
          {
            "name": "omit_username",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to omit the username of the table (e.g. owner, updated_by, created_by) from the response or not."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token to send for the next page of results (pagination)."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{full_name}": {
      "delete": {
        "operationId": "tables_delete",
        "summary": "Deletes a table from the specified parent catalog and schema. The caller must be the owner of the",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Deletes a table from the specified parent catalog and schema. The caller must be the owner of the\nparent catalog, have the **USE_CATALOG** privilege on the parent catalog and be the owner of the\nparent schema, or be the owner of the table and have the **USE_CATALOG** privilege on the parent\ncatalog and the **USE_SCHEMA** privilege on the parent schema.\n\n:param full_name: str\n  Full name of the table.",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "tables_get",
        "summary": "Gets a table from the metastore for a specific catalog and schema. The caller must satisfy one of the",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Gets a table from the metastore for a specific catalog and schema. The caller must satisfy one of the\nfollowing requirements: * Be a metastore admin * Be the owner of the parent catalog * Be the owner of\nthe parent schema and have the **USE_CATALOG** privilege on the parent catalog * Have the\n**USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema,\nand either be the table owner or have the **SELECT** privilege on the table.\n\n:param full_name: str\n  Full name of the table.\n:param include_browse: bool (optional)\n  Whether to include tables in the response for which the principal can only access selective metadata\n  for.\n:param include_delta_metadata: bool (optional)\n  Whether delta metadata should be included in the response.\n:param include_manifest_capabilities: bool (optional)\n  Whether to include a manifest containing table capabilities in the response.\n\n:returns: :class:`TableInfo`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table."
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include tables in the response for which the principal can only access selective metadata for."
          },
          {
            "name": "include_delta_metadata",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether delta metadata should be included in the response."
          },
          {
            "name": "include_manifest_capabilities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include a manifest containing table capabilities in the response."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "tables_update",
        "summary": "Change the owner of the table. The caller must be the owner of the parent catalog, have the",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Change the owner of the table. The caller must be the owner of the parent catalog, have the\n**USE_CATALOG** privilege on the parent catalog and be the owner of the parent schema, or be the owner\nof the table and have the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**\nprivilege on the parent schema.\n\n:param full_name: str\n  Full name of the table.\n:param owner: str (optional)\n  Username of current owner of table.",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of table."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/tables/{full_name}/exists": {
      "get": {
        "operationId": "tables_exists",
        "summary": "Gets if a table exists in the metastore for a specific catalog and schema. The caller must satisfy one",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Gets if a table exists in the metastore for a specific catalog and schema. The caller must satisfy one\nof the following requirements: * Be a metastore admin * Be the owner of the parent catalog * Be the\nowner of the parent schema and have the **USE_CATALOG** privilege on the parent catalog * Have the\n**USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema,\nand either be the table owner or have the **SELECT** privilege on the table. * Have **BROWSE**\nprivilege on the parent catalog * Have **BROWSE** privilege on the parent schema\n\n:param full_name: str\n  Full name of the table.\n\n:returns: :class:`TableExistsResponse`",
        "parameters": [
          {
            "name": "full_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Full name of the table."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableExistsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/table-summaries": {
      "get": {
        "operationId": "tables_list_summaries",
        "summary": "Gets an array of summaries for tables for a schema and catalog within the metastore. The table",
        "tags": [
          "catalog",
          "tables"
        ],
        "description": "Gets an array of summaries for tables for a schema and catalog within the metastore. The table\nsummaries returned are either:\n\n* summaries for tables (within the current metastore and parent catalog and schema), when the user is\na metastore admin, or: * summaries for tables and schemas (within the current metastore and parent\ncatalog) for which the user has ownership or the **SELECT** privilege on the table and ownership or\n**USE_SCHEMA** privilege on the schema, provided that the user also has ownership or the\n**USE_CATALOG** privilege on the parent catalog.\n\nThere is no guarantee of a specific ordering of the elements in the array.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param catalog_name: str\n  Name of parent catalog for tables of interest.\n:param include_manifest_capabilities: bool (optional)\n  Whether to include a manifest containing table capabilities in the response.\n:param max_results: int (optional)\n  Maximum number of summaries for tables to return. If not set, the page length is set to a server\n  configured value (10000, as of 1/5/2024). - when set to a value greater than 0, the page length is\n  the minimum of this value and a server configured value (10000, as of 1/5/2024); - when set to 0,\n  the page length is set to a server configured value (10000, as of 1/5/2024) (recommended); - when\n  set to a value less than 0, an invalid parameter error is returned;\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n:param schema_name_pattern: str (optional)\n  A sql LIKE pattern (% and _) for schema names. All schemas will be returned if not set or empty.\n:param table_name_pattern: str (optional)\n  A sql LIKE pattern (% and _) for table names. All tables will be returned if not set or empty.\n\n:returns: Iterator over :class:`TableSummary`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of parent catalog for tables of interest."
          },
          {
            "name": "include_manifest_capabilities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include a manifest containing table capabilities in the response."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of summaries for tables to return. If not set, the page length is set to a server configured value (10000, as of 1/5/2024). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value (10000, as of 1/5/2024); - when set to 0, the page length is set to a server configured value (10000, as of 1/5/2024) (recommended); - when set to a value less than 0, an invalid parameter error is returned;"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          },
          {
            "name": "schema_name_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "A sql LIKE pattern (% and _) for schema names. All schemas will be returned if not set or empty."
          },
          {
            "name": "table_name_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "A sql LIKE pattern (% and _) for table names. All tables will be returned if not set or empty."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableSummary"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/unity-catalog/temporary-path-credentials": {
      "post": {
        "operationId": "temporary_path_credentials_generate_temporary_path_credentials",
        "summary": "Get a short-lived credential for directly accessing cloud storage locations registered in Databricks.",
        "tags": [
          "catalog",
          "temporary_path_credentials"
        ],
        "description": "Get a short-lived credential for directly accessing cloud storage locations registered in Databricks.\nThe Generate Temporary Path Credentials API is only supported for external storage paths, specifically\nexternal locations and external tables. Managed tables are not supported by this API. The metastore\nmust have **external_access_enabled** flag set to true (default false). The caller must have the\n**EXTERNAL_USE_LOCATION** privilege on the external location; this privilege can only be granted by\nexternal location owners. For requests on existing external tables, the caller must also have the\n**EXTERNAL_USE_SCHEMA** privilege on the parent schema; this privilege can only be granted by catalog\nowners.\n\n:param url: str\n  URL for path-based access.\n:param operation: :class:`PathOperation`\n  The operation being performed on the path.\n:param dry_run: bool (optional)\n  Optional. When set to true, the service will not validate that the generated credentials can perform\n  write operations, therefore no new paths will be created and the response will not contain valid\n  credentials. Defaults to false.\n\n:returns: :class:`GenerateTemporaryPathCredentialResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "description": "URL for path-based access."
                  },
                  "operation": {
                    "type": "string",
                    "description": "The operation being performed on the path."
                  },
                  "dry_run": {
                    "type": "string",
                    "description": "Optional. When set to true, the service will not validate that the generated credentials can perform write operations, therefore no new paths will be created and the response will not contain valid credentials. Defaults to false."
                  }
                },
                "required": [
                  "url",
                  "operation"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateTemporaryPathCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/unity-catalog/temporary-table-credentials": {
      "post": {
        "operationId": "temporary_table_credentials_generate_temporary_table_credentials",
        "summary": "Get a short-lived credential for directly accessing the table data on cloud storage. The metastore",
        "tags": [
          "catalog",
          "temporary_table_credentials"
        ],
        "description": "Get a short-lived credential for directly accessing the table data on cloud storage. The metastore\nmust have **external_access_enabled** flag set to true (default false). The caller must have the\n**EXTERNAL_USE_SCHEMA** privilege on the parent schema and this privilege can only be granted by\ncatalog owners.\n\n:param operation: :class:`TableOperation` (optional)\n  The operation performed against the table data, either READ or READ_WRITE. If READ_WRITE is\n  specified, the credentials returned will have write permissions, otherwise, it will be read only.\n:param table_id: str (optional)\n  UUID of the table to read or write.\n\n:returns: :class:`GenerateTemporaryTableCredentialResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "operation": {
                    "type": "string",
                    "description": "The operation performed against the table data, either READ or READ_WRITE. If READ_WRITE is specified, the credentials returned will have write permissions, otherwise, it will be read only."
                  },
                  "table_id": {
                    "type": "string",
                    "description": "UUID of the table to read or write."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateTemporaryTableCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/volumes": {
      "post": {
        "operationId": "volumes_create",
        "summary": "Creates a new volume.",
        "tags": [
          "catalog",
          "volumes"
        ],
        "description": "Creates a new volume.\n\nThe user could create either an external volume or a managed volume. An external volume will be\ncreated in the specified external location, while a managed volume will be located in the default\nlocation which is specified by the parent schema, or the parent catalog, or the Metastore.\n\nFor the volume creation to succeed, the user must satisfy following conditions: - The caller must be a\nmetastore admin, or be the owner of the parent catalog and schema, or have the **USE_CATALOG**\nprivilege on the parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The caller\nmust have **CREATE VOLUME** privilege on the parent schema.\n\nFor an external volume, following conditions also need to satisfy - The caller must have **CREATE\nEXTERNAL VOLUME** privilege on the external location. - There are no other tables, nor volumes\nexisting in the specified storage location. - The specified storage location is not under the location\nof other tables, nor volumes, or catalogs or schemas.\n\n:param catalog_name: str\n  The name of the catalog where the schema and the volume are\n:param schema_name: str\n  The name of the schema where the volume is\n:param name: str\n  The name of the volume\n:param volume_type: :class:`VolumeType`\n  The type of the volume. An external volume is located in the specified external location. A managed\n  volume is located in the default location which is specified by the parent schema, or the parent\n  catalog, or the Metastore. [Learn more]\n\n  [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external\n:param comment: str (optional)\n  The comment attached to the volume\n:param storage_location: str (optional)\n  The storage location on the cloud\n\n:returns: :class:`VolumeInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "catalog_name": {
                    "type": "string",
                    "description": "The name of the catalog where the schema and the volume are"
                  },
                  "schema_name": {
                    "type": "string",
                    "description": "The name of the schema where the volume is"
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the volume"
                  },
                  "volume_type": {
                    "type": "string",
                    "description": "The type of the volume. An external volume is located in the specified external location. A managed volume is located in the default location which is specified by the parent schema, or the parent catalog, or the Metastore. [Learn more] [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external"
                  },
                  "comment": {
                    "type": "string",
                    "description": "The comment attached to the volume"
                  },
                  "storage_location": {
                    "type": "string",
                    "description": "The storage location on the cloud"
                  }
                },
                "required": [
                  "catalog_name",
                  "schema_name",
                  "name",
                  "volume_type"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "volumes_list",
        "summary": "Gets an array of volumes for the current metastore under the parent catalog and schema.",
        "tags": [
          "catalog",
          "volumes"
        ],
        "description": "Gets an array of volumes for the current metastore under the parent catalog and schema.\n\nThe returned volumes are filtered based on the privileges of the calling user. For example, the\nmetastore admin is able to list all the volumes. A regular user needs to be the owner or have the\n**READ VOLUME** privilege on the volume to receive the volumes in the response. For the latter case,\nthe caller must also be the owner or have the **USE_CATALOG** privilege on the parent catalog and the\n**USE_SCHEMA** privilege on the parent schema.\n\nThere is no guarantee of a specific ordering of the elements in the array.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param catalog_name: str\n  The identifier of the catalog\n:param schema_name: str\n  The identifier of the schema\n:param include_browse: bool (optional)\n  Whether to include volumes in the response for which the principal can only access selective\n  metadata for\n:param max_results: int (optional)\n  Maximum number of volumes to return (page length).\n\n  If not set, the page length is set to a server configured value (10000, as of 1/29/2024). - when set\n  to a value greater than 0, the page length is the minimum of this value and a server configured\n  value (10000, as of 1/29/2024); - when set to 0, the page length is set to a server configured value\n  (10000, as of 1/29/2024) (recommended); - when set to a value less than 0, an invalid parameter\n  error is returned;\n\n  Note: this parameter controls only the maximum number of volumes to return. The actual number of\n  volumes returned in a page may be smaller than this value, including 0, even if there are more\n  pages.\n:param page_token: str (optional)\n  Opaque token returned by a previous request. It must be included in the request to retrieve the next\n  page of results (pagination).\n\n:returns: Iterator over :class:`VolumeInfo`",
        "parameters": [
          {
            "name": "catalog_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of the catalog"
          },
          {
            "name": "schema_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of the schema"
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include volumes in the response for which the principal can only access selective metadata for"
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of volumes to return (page length). If not set, the page length is set to a server configured value (10000, as of 1/29/2024). - when set to a value greater than 0, the page length is the minimum of this value and a server configured value (10000, as of 1/29/2024); - when set to 0, the page length is set to a server configured value (10000, as of 1/29/2024) (recommended); - when set to a value less than 0, an invalid parameter error is returned; Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination)."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/volumes/{name}": {
      "delete": {
        "operationId": "volumes_delete",
        "summary": "Deletes a volume from the specified parent catalog and schema.",
        "tags": [
          "catalog",
          "volumes"
        ],
        "description": "Deletes a volume from the specified parent catalog and schema.\n\nThe caller must be a metastore admin or an owner of the volume. For the latter case, the caller must\nalso be the owner or have the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**\nprivilege on the parent schema.\n\n:param name: str\n  The three-level (fully qualified) name of the volume",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the volume"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "volumes_read",
        "summary": "Gets a volume from the metastore for a specific catalog and schema.",
        "tags": [
          "catalog",
          "volumes"
        ],
        "description": "Gets a volume from the metastore for a specific catalog and schema.\n\nThe caller must be a metastore admin or an owner of (or have the **READ VOLUME** privilege on) the\nvolume. For the latter case, the caller must also be the owner or have the **USE_CATALOG** privilege\non the parent catalog and the **USE_SCHEMA** privilege on the parent schema.\n\n:param name: str\n  The three-level (fully qualified) name of the volume\n:param include_browse: bool (optional)\n  Whether to include volumes in the response for which the principal can only access selective\n  metadata for\n\n:returns: :class:`VolumeInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the volume"
          },
          {
            "name": "include_browse",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include volumes in the response for which the principal can only access selective metadata for"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "volumes_update",
        "summary": "Updates the specified volume under the specified parent catalog and schema.",
        "tags": [
          "catalog",
          "volumes"
        ],
        "description": "Updates the specified volume under the specified parent catalog and schema.\n\nThe caller must be a metastore admin or an owner of the volume. For the latter case, the caller must\nalso be the owner or have the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**\nprivilege on the parent schema.\n\nCurrently only the name, the owner or the comment of the volume could be updated.\n\n:param name: str\n  The three-level (fully qualified) name of the volume\n:param comment: str (optional)\n  The comment attached to the volume\n:param new_name: str (optional)\n  New name for the volume.\n:param owner: str (optional)\n  The identifier of the user who owns the volume\n\n:returns: :class:`VolumeInfo`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The three-level (fully qualified) name of the volume"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "comment": {
                    "type": "string",
                    "description": "The comment attached to the volume"
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name for the volume."
                  },
                  "owner": {
                    "type": "string",
                    "description": "The identifier of the user who owns the volume"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VolumeInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/workspace-bindings/catalogs/{name}": {
      "get": {
        "operationId": "workspace_bindings_get",
        "summary": "Gets workspace bindings of the catalog. The caller must be a metastore admin or an owner of the",
        "tags": [
          "catalog",
          "workspace_bindings"
        ],
        "description": "Gets workspace bindings of the catalog. The caller must be a metastore admin or an owner of the\ncatalog.\n\n:param name: str\n  The name of the catalog.\n\n:returns: :class:`GetCatalogWorkspaceBindingsResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the catalog."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetCatalogWorkspaceBindingsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "workspace_bindings_update",
        "summary": "Updates workspace bindings of the catalog. The caller must be a metastore admin or an owner of the",
        "tags": [
          "catalog",
          "workspace_bindings"
        ],
        "description": "Updates workspace bindings of the catalog. The caller must be a metastore admin or an owner of the\ncatalog.\n\n:param name: str\n  The name of the catalog.\n:param assign_workspaces: List[int] (optional)\n  A list of workspace IDs.\n:param unassign_workspaces: List[int] (optional)\n  A list of workspace IDs.\n\n:returns: :class:`UpdateCatalogWorkspaceBindingsResponse`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the catalog."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "assign_workspaces": {
                    "type": "string",
                    "description": "A list of workspace IDs."
                  },
                  "unassign_workspaces": {
                    "type": "string",
                    "description": "A list of workspace IDs."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateCatalogWorkspaceBindingsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.1/unity-catalog/bindings/{securable_type}/{securable_name}": {
      "get": {
        "operationId": "workspace_bindings_get_bindings",
        "summary": "Gets workspace bindings of the securable. The caller must be a metastore admin or an owner of the",
        "tags": [
          "catalog",
          "workspace_bindings"
        ],
        "description": "Gets workspace bindings of the securable. The caller must be a metastore admin or an owner of the\nsecurable.\n\nNOTE: we recommend using max_results=0 to use the paginated version of this API. Unpaginated calls\nwill be deprecated soon.\n\nPAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may contain zero results while\nstill providing a next_page_token. Clients must continue reading pages until next_page_token is\nabsent, which is the only indication that the end of results has been reached.\n\n:param securable_type: str\n  The type of the securable to bind to a workspace (catalog, storage_credential, credential, or\n  external_location).\n:param securable_name: str\n  The name of the securable.\n:param max_results: int (optional)\n  Maximum number of workspace bindings to return. - When set to 0, the page length is set to a server\n  configured value (recommended); - When set to a value greater than 0, the page length is the minimum\n  of this value and a server configured value; - When set to a value less than 0, an invalid parameter\n  error is returned; - If not set, all the workspace bindings are returned (not recommended).\n:param page_token: str (optional)\n  Opaque pagination token to go to next page based on previous query.\n\n:returns: Iterator over :class:`WorkspaceBinding`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the securable to bind to a workspace (catalog, storage_credential, credential, or external_location)."
          },
          {
            "name": "securable_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the securable."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Maximum number of workspace bindings to return. - When set to 0, the page length is set to a server configured value (recommended); - When set to a value greater than 0, the page length is the minimum of this value and a server configured value; - When set to a value less than 0, an invalid parameter error is returned; - If not set, all the workspace bindings are returned (not recommended)."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque pagination token to go to next page based on previous query."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkspaceBinding"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "workspace_bindings_update_bindings",
        "summary": "Updates workspace bindings of the securable. The caller must be a metastore admin or an owner of the",
        "tags": [
          "catalog",
          "workspace_bindings"
        ],
        "description": "Updates workspace bindings of the securable. The caller must be a metastore admin or an owner of the\nsecurable.\n\n:param securable_type: str\n  The type of the securable to bind to a workspace (catalog, storage_credential, credential, or\n  external_location).\n:param securable_name: str\n  The name of the securable.\n:param add: List[:class:`WorkspaceBinding`] (optional)\n  List of workspace bindings to add. If a binding for the workspace already exists with a different\n  binding_type, adding it again with a new binding_type will update the existing binding (e.g., from\n  READ_WRITE to READ_ONLY).\n:param remove: List[:class:`WorkspaceBinding`] (optional)\n  List of workspace bindings to remove.\n\n:returns: :class:`UpdateWorkspaceBindingsResponse`",
        "parameters": [
          {
            "name": "securable_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of the securable to bind to a workspace (catalog, storage_credential, credential, or external_location)."
          },
          {
            "name": "securable_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the securable."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "add": {
                    "type": "string",
                    "description": "List of workspace bindings to add. If a binding for the workspace already exists with a different binding_type, adding it again with a new binding_type will update the existing binding (e.g., from READ_WRITE to READ_ONLY)."
                  },
                  "remove": {
                    "type": "string",
                    "description": "List of workspace bindings to remove."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkspaceBindingsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AccessRequestDestinations": {
        "type": "object",
        "properties": {
          "securable": {
            "$ref": "#/components/schemas/Securable"
          },
          "are_any_destinations_hidden": {
            "type": "boolean",
            "description": "Indicates whether any destinations are hidden from the caller due to a lack of permissions. This value is true if the caller does not have permission to see all destinations."
          },
          "destination_source_securable": {
            "$ref": "#/components/schemas/Securable",
            "description": "The source securable from which the destinations are inherited. Either the same value as securable (if destination is set directly on the securable) or the nearest parent securable with destinations set."
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationDestination"
            },
            "description": "The access request destinations for the securable."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the securable. Redundant with the name in the securable object, but necessary for Terraform integration"
          },
          "securable_type": {
            "type": "string",
            "description": "The type of the securable. Redundant with the type in the securable object, but necessary for Terraform integration"
          }
        },
        "required": [
          "securable"
        ]
      },
      "AccountsCreateMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully created."
      },
      "AccountsCreateMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        }
      },
      "AccountsCreateStorageCredentialInfo": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        }
      },
      "AccountsDeleteMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully deleted."
      },
      "AccountsDeleteMetastoreResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore was successfully deleted."
      },
      "AccountsDeleteStorageCredentialResponse": {
        "type": "object",
        "properties": {},
        "description": "The storage credential was successfully deleted."
      },
      "AccountsGetMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        },
        "description": "The metastore was successfully returned."
      },
      "AccountsListMetastoresResponse": {
        "type": "object",
        "properties": {
          "metastores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetastoreInfo"
            },
            "description": "An array of metastore information objects."
          }
        },
        "description": "Metastores were returned successfully."
      },
      "AccountsMetastoreAssignment": {
        "type": "object",
        "properties": {
          "metastore_assignment": {
            "$ref": "#/components/schemas/MetastoreAssignment"
          }
        },
        "description": "The workspace metastore assignment was successfully returned."
      },
      "AccountsStorageCredentialInfo": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        },
        "description": "The storage credential was successfully retrieved."
      },
      "AccountsUpdateMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully updated."
      },
      "AccountsUpdateMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        },
        "description": "The metastore update request succeeded."
      },
      "AccountsUpdateStorageCredentialResponse": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        },
        "description": "The storage credential was successfully updated."
      },
      "ArtifactAllowlistInfo": {
        "type": "object",
        "properties": {
          "artifact_matchers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtifactMatcher"
            }
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this artifact allowlist was set, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of the user who set the artifact allowlist."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          }
        }
      },
      "ArtifactMatcher": {
        "type": "object",
        "properties": {
          "artifact": {
            "type": "string"
          },
          "match_type": {
            "$ref": "#/components/schemas/MatchType",
            "description": "The pattern matching type of the artifact"
          }
        },
        "required": [
          "artifact",
          "match_type"
        ]
      },
      "AssignResponse": {
        "type": "object",
        "properties": {}
      },
      "AwsCredentials": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID that identifies the temporary credentials."
          },
          "access_point": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the S3 access point for temporary credentials related the external location."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access key that can be used to sign AWS API requests."
          },
          "session_token": {
            "type": "string",
            "description": "The token that users must pass to AWS API to use the temporary credentials."
          }
        },
        "description": "AWS temporary credentials for API authentication. Read more at\n    https://docs.aws.amazon.com/STS/latest/APIReference/API_Credentials.html."
      },
      "AwsIamRole": {
        "type": "object",
        "properties": {
          "external_id": {
            "type": "string",
            "description": "The external ID used in role assumption to prevent the confused deputy problem."
          },
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          },
          "unity_catalog_iam_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
          }
        },
        "description": "The AWS IAM role configuration"
      },
      "AwsIamRoleRequest": {
        "type": "object",
        "properties": {
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          }
        },
        "required": [
          "role_arn"
        ],
        "description": "The AWS IAM role configuration"
      },
      "AwsIamRoleResponse": {
        "type": "object",
        "properties": {
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          },
          "external_id": {
            "type": "string",
            "description": "The external ID used in role assumption to prevent the confused deputy problem."
          },
          "unity_catalog_iam_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
          }
        },
        "required": [
          "role_arn"
        ],
        "description": "The AWS IAM role configuration"
      },
      "AwsSqsQueue": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "queue_url": {
            "type": "string",
            "description": "The AQS queue url in the format https://sqs.{region}.amazonaws.com/{account id}/{queue name}. Only required for provided_sqs."
          }
        }
      },
      "AzureActiveDirectoryToken": {
        "type": "object",
        "properties": {
          "aad_token": {
            "type": "string",
            "description": "Opaque token that contains claims that you can use in Azure Active Directory to access cloud services."
          }
        },
        "description": "Azure Active Directory token, essentially the Oauth token for Azure Service Principal or Managed\n    Identity. Read more at\n    https://learn.microsoft.com/en-us/azure/databricks/dev-tools/api/latest/aad/service-prin-aad-token"
      },
      "AzureManagedIdentity": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureManagedIdentityRequest": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureManagedIdentityResponse": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureQueueStorage": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "queue_url": {
            "type": "string",
            "description": "The AQS queue url in the format https://{storage account}.queue.core.windows.net/{queue name} Only required for provided_aqs."
          },
          "resource_group": {
            "type": "string",
            "description": "Optional resource group for the queue, event grid subscription, and external location storage account. Only required for locations with a service principal storage credential"
          },
          "subscription_id": {
            "type": "string",
            "description": "Optional subscription id for the queue, event grid subscription, and external location storage account. Required for locations with a service principal storage credential"
          }
        }
      },
      "AzureServicePrincipal": {
        "type": "object",
        "properties": {
          "directory_id": {
            "type": "string",
            "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
          },
          "application_id": {
            "type": "string",
            "description": "The application ID of the application registration within the referenced AAD tenant."
          },
          "client_secret": {
            "type": "string",
            "description": "The client secret generated for the above app ID in AAD."
          }
        },
        "required": [
          "directory_id",
          "application_id",
          "client_secret"
        ],
        "description": "The Azure service principal configuration. Only applicable when purpose is **STORAGE**."
      },
      "AzureUserDelegationSas": {
        "type": "object",
        "properties": {
          "sas_token": {
            "type": "string",
            "description": "The signed URI (SAS Token) used to access blob services for a given path"
          }
        },
        "description": "Azure temporary credentials for API authentication. Read more at\n    https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas"
      },
      "BatchCreateAccessRequestsResponse": {
        "type": "object",
        "properties": {
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateAccessRequestResponse"
            }
          }
        }
      },
      "CancelRefreshResponse": {
        "type": "object",
        "properties": {}
      },
      "CatalogInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "catalog_type": {
            "$ref": "#/components/schemas/CatalogType"
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "connection_name": {
            "type": "string",
            "description": "The name of the connection to an external data source."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this catalog was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of catalog creator."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization",
            "description": "Whether predictive optimization should be enabled for this object and objects under it."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the catalog. Corresponds with the name field."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/CatalogIsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of catalog."
          },
          "options": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of catalog."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "provider_name": {
            "type": "string",
            "description": "The name of delta sharing provider. A Delta Sharing catalog is a catalog that is based on a Delta share on a remote sharing server."
          },
          "provisioning_info": {
            "$ref": "#/components/schemas/ProvisioningInfo"
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType"
          },
          "share_name": {
            "type": "string",
            "description": "The name of the share under the share provider."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage Location URL (full path) for managed tables within catalog."
          },
          "storage_root": {
            "type": "string",
            "description": "Storage root URL for managed tables within catalog."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this catalog was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified catalog."
          }
        }
      },
      "CloudflareApiToken": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID associated with the API token."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access token generated for the above access key ID."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account associated with the API token."
          }
        },
        "required": [
          "access_key_id",
          "secret_access_key"
        ],
        "description": "The Cloudflare API token configuration. Read more at\n    https://developers.cloudflare.com/r2/api/s3/tokens/"
      },
      "ColumnInfo": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "string"
          },
          "mask": {
            "$ref": "#/components/schemas/ColumnMask"
          },
          "name": {
            "type": "string",
            "description": "Name of Column."
          },
          "nullable": {
            "type": "boolean",
            "description": "Whether field may be Null (default: true)."
          },
          "partition_index": {
            "type": "integer",
            "description": "Partition index for column."
          },
          "position": {
            "type": "integer",
            "description": "Ordinal position of column (starting at position 0)."
          },
          "type_interval_type": {
            "type": "string",
            "description": "Format of IntervalType."
          },
          "type_json": {
            "type": "string",
            "description": "Full data type specification, JSON-serialized."
          },
          "type_name": {
            "$ref": "#/components/schemas/ColumnTypeName"
          },
          "type_precision": {
            "type": "integer",
            "description": "Digits of precision; required for DecimalTypes."
          },
          "type_scale": {
            "type": "integer",
            "description": "Digits to right of decimal; Required for DecimalTypes."
          },
          "type_text": {
            "type": "string",
            "description": "Full data type specification as SQL/catalogString text."
          }
        }
      },
      "ColumnMask": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "using_column_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of additional table columns to be passed as input to the column mask function. The first arg of the mask function should be of the type of the column being masked and the types of the rest of the args should match the types of columns in 'using_column_names'."
          }
        }
      },
      "ColumnMaskOptions": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "on_column": {
            "type": "string",
            "description": "The alias of the column to be masked. The alias must refer to one of matched columns. The values of the column is passed to the column mask function as the first argument. Required on create and update."
          },
          "using": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionArgument"
            },
            "description": "Optional list of column aliases or constant literals to be passed as additional arguments to the column mask function. The type of each column should match the positional argument of the column mask function."
          }
        },
        "required": [
          "function_name",
          "on_column"
        ]
      },
      "ColumnRelationship": {
        "type": "object",
        "properties": {
          "source": {
            "type": "string"
          },
          "target": {
            "type": "string"
          }
        }
      },
      "ConnectionDependency": {
        "type": "object",
        "properties": {
          "connection_name": {
            "type": "string",
            "description": "Full name of the dependent connection, in the form of __connection_name__."
          }
        },
        "description": "A connection that is dependent on a SQL object."
      },
      "ConnectionInfo": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "connection_id": {
            "type": "string",
            "description": "Unique identifier of the Connection."
          },
          "connection_type": {
            "$ref": "#/components/schemas/ConnectionType",
            "description": "The type of connection."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this connection was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of connection creator."
          },
          "credential_type": {
            "$ref": "#/components/schemas/CredentialType",
            "description": "The type of credential."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of connection."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of the connection."
          },
          "options": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of the connection."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "provisioning_info": {
            "$ref": "#/components/schemas/ProvisioningInfo"
          },
          "read_only": {
            "type": "boolean",
            "description": "If the connection is read only."
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType"
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this connection was updated, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified connection."
          },
          "url": {
            "type": "string",
            "description": "URL of the remote data source, extracted from options."
          }
        },
        "description": "Next ID: 24"
      },
      "ContinuousUpdateStatus": {
        "type": "object",
        "properties": {
          "initial_pipeline_sync_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Progress of the initial data synchronization."
          },
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may not be completely synced to the online table yet."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the ONLINE_CONTINUOUS_UPDATE\n    or the ONLINE_UPDATING_PIPELINE_RESOURCES state."
      },
      "CreateAccessRequest": {
        "type": "object",
        "properties": {
          "behalf_of": {
            "$ref": "#/components/schemas/Principal"
          },
          "comment": {
            "type": "string",
            "description": "Optional. Comment associated with the request. At most 200 characters, can only contain lowercase/uppercase letters (a-z, A-Z), numbers (0-9), punctuation, and spaces."
          },
          "securable_permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SecurablePermissions"
            },
            "description": "List of securables and their corresponding requested UC privileges. At most 30 securables can be requested for a principal per batched call. Each securable can only be requested once per principal."
          }
        }
      },
      "CreateAccessRequestResponse": {
        "type": "object",
        "properties": {
          "behalf_of": {
            "$ref": "#/components/schemas/Principal"
          },
          "request_destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessRequestDestinations"
            },
            "description": "The access request destinations for all the securables the principal requested."
          }
        }
      },
      "CreateAccountsMetastore": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateAccountsStorageCredential": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleRequest",
            "description": "The AWS IAM role configuration."
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityRequest",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountRequest",
            "description": "The Databricks managed GCP service account configuration."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent Catalog."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent Schema relative to its parent Catalog."
          },
          "input_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Function input parameters."
          },
          "data_type": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Scalar function return data type."
          },
          "full_data_type": {
            "type": "string",
            "description": "Pretty printed function data type."
          },
          "routine_body": {
            "$ref": "#/components/schemas/CreateFunctionRoutineBody",
            "description": "Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the **external_language** field, and the **return_params** of the function cannot be used (as **TABLE** return type is not supported), and the **sql_data_access** field must be **NO_SQL**."
          },
          "routine_definition": {
            "type": "string",
            "description": "Function body."
          },
          "parameter_style": {
            "$ref": "#/components/schemas/CreateFunctionParameterStyle",
            "description": "Function parameter style. **S** is the value for SQL."
          },
          "is_deterministic": {
            "type": "boolean",
            "description": "Whether the function is deterministic."
          },
          "sql_data_access": {
            "$ref": "#/components/schemas/CreateFunctionSqlDataAccess",
            "description": "Function SQL data access."
          },
          "is_null_call": {
            "type": "boolean",
            "description": "Function null call."
          },
          "security_type": {
            "$ref": "#/components/schemas/CreateFunctionSecurityType",
            "description": "Function security type."
          },
          "specific_name": {
            "type": "string",
            "description": "Specific name of the function; Reserved for future use."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "external_language": {
            "type": "string",
            "description": "External function language."
          },
          "external_name": {
            "type": "string",
            "description": "External function name."
          },
          "properties": {
            "type": "string",
            "description": "JSON-serialized key-value pair map, encoded (escaped) as a string."
          },
          "return_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Table function return parameters."
          },
          "routine_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "function dependencies."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          }
        },
        "required": [
          "name",
          "catalog_name",
          "schema_name",
          "input_params",
          "data_type",
          "full_data_type",
          "routine_body",
          "routine_definition",
          "parameter_style",
          "is_deterministic",
          "sql_data_access",
          "is_null_call",
          "security_type",
          "specific_name"
        ]
      },
      "CreateMetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          }
        },
        "required": [
          "workspace_id",
          "metastore_id",
          "default_catalog_name"
        ]
      },
      "CreateRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "CredentialDependency": {
        "type": "object",
        "properties": {
          "credential_name": {
            "type": "string",
            "description": "Full name of the dependent credential, in the form of __credential_name__."
          }
        },
        "description": "A credential that is dependent on a SQL object."
      },
      "CredentialInfo": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRole"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentity",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this credential was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of credential creator."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccount",
            "description": "The Databricks managed GCP service account configuration."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the credential."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the credential."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of the parent metastore."
          },
          "name": {
            "type": "string",
            "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "purpose": {
            "$ref": "#/components/schemas/CredentialPurpose",
            "description": "Indicates the purpose of the credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this credential was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the credential."
          },
          "used_for_managed_storage": {
            "type": "boolean",
            "description": "Whether this credential is the current metastore's root storage credential. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "CredentialValidationResult": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "result": {
            "$ref": "#/components/schemas/ValidateCredentialResult",
            "description": "The results of the tested operation."
          }
        }
      },
      "DatabricksGcpServiceAccount": {
        "type": "object",
        "properties": {
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "email": {
            "type": "string",
            "description": "The email of the service account."
          },
          "private_key_id": {
            "type": "string",
            "description": "The ID that represents the private key for this Service Account"
          }
        },
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DatabricksGcpServiceAccountRequest": {
        "type": "object",
        "properties": {},
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DatabricksGcpServiceAccountResponse": {
        "type": "object",
        "properties": {
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "email": {
            "type": "string",
            "description": "The email of the service account."
          }
        },
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DeleteCredentialResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteMonitorResponse": {
        "type": "object",
        "properties": {}
      },
      "DeletePolicyResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "DeleteResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteTableConstraintResponse": {
        "type": "object",
        "properties": {}
      },
      "DeltaRuntimePropertiesKvPairs": {
        "type": "object",
        "properties": {
          "delta_runtime_properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          }
        },
        "required": [
          "delta_runtime_properties"
        ],
        "description": "Properties pertaining to the current state of the delta table as given by the commit server.\n    This does not contain **delta.*** (input) properties in __TableInfo.properties__."
      },
      "Dependency": {
        "type": "object",
        "properties": {
          "connection": {
            "$ref": "#/components/schemas/ConnectionDependency"
          },
          "credential": {
            "$ref": "#/components/schemas/CredentialDependency"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionDependency"
          },
          "table": {
            "$ref": "#/components/schemas/TableDependency"
          }
        },
        "description": "A dependency of a SQL object. One of the following fields must be defined: __table__,\n    __function__, __connection__, or __credential__."
      },
      "DependencyList": {
        "type": "object",
        "properties": {
          "dependencies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Dependency"
            },
            "description": "Array of dependencies."
          }
        },
        "description": "A list of dependencies."
      },
      "DisableResponse": {
        "type": "object",
        "properties": {}
      },
      "EffectivePermissionsList": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EffectivePrivilegeAssignment"
            },
            "description": "The privileges conveyed to each principal (either directly or via inheritance)"
          }
        }
      },
      "EffectivePredictiveOptimizationFlag": {
        "type": "object",
        "properties": {
          "value": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization"
          },
          "inherited_from_name": {
            "type": "string",
            "description": "The name of the object from which the flag was inherited. If there was no inheritance, this field is left blank."
          },
          "inherited_from_type": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlagInheritedFromType",
            "description": "The type of the object from which the flag was inherited. If there was no inheritance, this field is left blank."
          }
        },
        "required": [
          "value"
        ]
      },
      "EffectivePrivilege": {
        "type": "object",
        "properties": {
          "inherited_from_name": {
            "type": "string"
          },
          "inherited_from_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "The type of the object that conveys this privilege via inheritance. This field is omitted when privilege is not inherited (it's assigned to the securable itself)."
          },
          "privilege": {
            "$ref": "#/components/schemas/Privilege",
            "description": "The privilege assigned to the principal."
          }
        }
      },
      "EffectivePrivilegeAssignment": {
        "type": "object",
        "properties": {
          "principal": {
            "type": "string"
          },
          "privileges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EffectivePrivilege"
            },
            "description": "The privileges conveyed to the principal (either directly or via inheritance)."
          }
        }
      },
      "EnableResponse": {
        "type": "object",
        "properties": {}
      },
      "EncryptionDetails": {
        "type": "object",
        "properties": {
          "sse_encryption_details": {
            "$ref": "#/components/schemas/SseEncryptionDetails",
            "description": "Server-Side Encryption properties for clients communicating with AWS s3."
          }
        },
        "description": "Encryption options that apply to clients connecting to cloud storage."
      },
      "EntityTagAssignment": {
        "type": "object",
        "properties": {
          "entity_name": {
            "type": "string",
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          "tag_key": {
            "type": "string",
            "description": "The key of the tag"
          },
          "entity_type": {
            "type": "string",
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          "tag_value": {
            "type": "string",
            "description": "The value of the tag"
          }
        },
        "required": [
          "entity_name",
          "tag_key",
          "entity_type"
        ],
        "description": "Represents a tag assignment to an entity"
      },
      "ExternalLineageExternalMetadata": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "ExternalLineageExternalMetadataInfo": {
        "type": "object",
        "properties": {
          "entity_type": {
            "type": "string",
            "description": "Type of entity represented by the external metadata object."
          },
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "name": {
            "type": "string",
            "description": "Name of the external metadata object."
          },
          "system_type": {
            "$ref": "#/components/schemas/SystemType",
            "description": "Type of external system."
          }
        },
        "description": "Represents the external metadata object in the lineage event."
      },
      "ExternalLineageFileInfo": {
        "type": "object",
        "properties": {
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "path": {
            "type": "string",
            "description": "URL of the path."
          },
          "securable_name": {
            "type": "string",
            "description": "The full name of the securable on the path."
          },
          "securable_type": {
            "type": "string",
            "description": "The securable type of the securable on the path."
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location associated with securable on the path."
          }
        },
        "description": "Represents the path information in the lineage event."
      },
      "ExternalLineageInfo": {
        "type": "object",
        "properties": {
          "external_lineage_info": {
            "$ref": "#/components/schemas/ExternalLineageRelationshipInfo",
            "description": "Information about the edge metadata of the external lineage relationship."
          },
          "external_metadata_info": {
            "$ref": "#/components/schemas/ExternalLineageExternalMetadataInfo",
            "description": "Information about external metadata involved in the lineage relationship."
          },
          "file_info": {
            "$ref": "#/components/schemas/ExternalLineageFileInfo",
            "description": "Information about the file involved in the lineage relationship."
          },
          "model_info": {
            "$ref": "#/components/schemas/ExternalLineageModelVersionInfo",
            "description": "Information about the model version involved in the lineage relationship."
          },
          "table_info": {
            "$ref": "#/components/schemas/ExternalLineageTableInfo",
            "description": "Information about the table involved in the lineage relationship."
          }
        },
        "description": "Lineage response containing lineage information of a data asset."
      },
      "ExternalLineageModelVersion": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        }
      },
      "ExternalLineageModelVersionInfo": {
        "type": "object",
        "properties": {
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "model_name": {
            "type": "string",
            "description": "Name of the model."
          },
          "version": {
            "type": "integer",
            "description": "Version number of the model."
          }
        },
        "description": "Represents the model version information in the lineage event."
      },
      "ExternalLineageObject": {
        "type": "object",
        "properties": {
          "external_metadata": {
            "$ref": "#/components/schemas/ExternalLineageExternalMetadata"
          },
          "model_version": {
            "$ref": "#/components/schemas/ExternalLineageModelVersion"
          },
          "path": {
            "$ref": "#/components/schemas/ExternalLineagePath"
          },
          "table": {
            "$ref": "#/components/schemas/ExternalLineageTable"
          }
        }
      },
      "ExternalLineagePath": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "ExternalLineageRelationship": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "ExternalLineageRelationshipInfo": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "ExternalLineageTable": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "ExternalLineageTableInfo": {
        "type": "object",
        "properties": {
          "catalog_name": {
            "type": "string",
            "description": "Name of Catalog."
          },
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "name": {
            "type": "string",
            "description": "Name of Table."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of Schema."
          }
        },
        "description": "Represents the table information in the lineage event."
      },
      "ExternalLocationInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this external location was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of external location creator."
          },
          "credential_id": {
            "type": "string",
            "description": "Unique ID of the location's storage credential."
          },
          "credential_name": {
            "type": "string",
            "description": "Name of the storage credential used with this location."
          },
          "enable_file_events": {
            "type": "boolean",
            "description": "Whether to enable file events on this external location. Default to `true`. Set to `false` to disable file events."
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "fallback": {
            "type": "boolean",
            "description": "Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled, the access to the location falls back to cluster credentials if UC credentials are not sufficient."
          },
          "file_event_queue": {
            "$ref": "#/components/schemas/FileEventQueue",
            "description": "File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly one of the documented properties."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode"
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore hosting the external location."
          },
          "name": {
            "type": "string",
            "description": "Name of the external location."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the external location."
          },
          "read_only": {
            "type": "boolean",
            "description": "Indicates whether the external location is read-only."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which external location this was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the external location."
          },
          "url": {
            "type": "string",
            "description": "Path URL of the external location."
          }
        }
      },
      "ExternalMetadata": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "system_type": {
            "$ref": "#/components/schemas/SystemType",
            "description": "Type of external system."
          },
          "entity_type": {
            "type": "string",
            "description": "Type of entity within the external system."
          },
          "columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of columns associated with the external metadata object."
          },
          "create_time": {
            "type": "string",
            "description": "Time at which this external metadata object was created."
          },
          "created_by": {
            "type": "string",
            "description": "Username of external metadata object creator."
          },
          "description": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external metadata object."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "owner": {
            "type": "string",
            "description": "Owner of the external metadata object."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the external metadata object."
          },
          "update_time": {
            "type": "string",
            "description": "Time at which this external metadata object was last modified."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified external metadata object."
          },
          "url": {
            "type": "string",
            "description": "URL associated with the external metadata object."
          }
        },
        "required": [
          "name",
          "system_type",
          "entity_type"
        ]
      },
      "FailedStatus": {
        "type": "object",
        "properties": {
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may only be partially synced to the online table. Only populated if the table is still online and available for serving."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table. Only populated if the table is still online and available for serving."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the OFFLINE_FAILED or the\n    ONLINE_PIPELINE_FAILED state."
      },
      "FileEventQueue": {
        "type": "object",
        "properties": {
          "managed_aqs": {
            "$ref": "#/components/schemas/AzureQueueStorage"
          },
          "managed_pubsub": {
            "$ref": "#/components/schemas/GcpPubsub"
          },
          "managed_sqs": {
            "$ref": "#/components/schemas/AwsSqsQueue"
          },
          "provided_aqs": {
            "$ref": "#/components/schemas/AzureQueueStorage"
          },
          "provided_pubsub": {
            "$ref": "#/components/schemas/GcpPubsub"
          },
          "provided_sqs": {
            "$ref": "#/components/schemas/AwsSqsQueue"
          }
        }
      },
      "ForeignKeyConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "child_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "parent_table": {
            "type": "string",
            "description": "The full name of the parent constraint."
          },
          "parent_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "rely": {
            "type": "boolean",
            "description": "True if the constraint is RELY, false or unset if NORELY."
          }
        },
        "required": [
          "name",
          "child_columns",
          "parent_table",
          "parent_columns"
        ]
      },
      "FunctionArgument": {
        "type": "object",
        "properties": {
          "alias": {
            "type": "string"
          },
          "constant": {
            "type": "string",
            "description": "A constant literal."
          }
        }
      },
      "FunctionDependency": {
        "type": "object",
        "properties": {
          "function_full_name": {
            "type": "string",
            "description": "Full name of the dependent function, in the form of __catalog_name__.__schema_name__.__function_name__."
          }
        },
        "required": [
          "function_full_name"
        ],
        "description": "A function that is dependent on a SQL object."
      },
      "FunctionInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent Catalog."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this function was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of function creator."
          },
          "data_type": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Scalar function return data type."
          },
          "external_language": {
            "type": "string",
            "description": "External function language."
          },
          "external_name": {
            "type": "string",
            "description": "External function name."
          },
          "full_data_type": {
            "type": "string",
            "description": "Pretty printed function data type."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of Function, in form of **catalog_name**.**schema_name**.**function_name**"
          },
          "function_id": {
            "type": "string",
            "description": "Id of Function, relative to parent schema."
          },
          "input_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Function input parameters."
          },
          "is_deterministic": {
            "type": "boolean",
            "description": "Whether the function is deterministic."
          },
          "is_null_call": {
            "type": "boolean",
            "description": "Function null call."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of function, relative to parent schema."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of the function."
          },
          "parameter_style": {
            "$ref": "#/components/schemas/FunctionInfoParameterStyle",
            "description": "Function parameter style. **S** is the value for SQL."
          },
          "properties": {
            "type": "string",
            "description": "JSON-serialized key-value pair map, encoded (escaped) as a string."
          },
          "return_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Table function return parameters."
          },
          "routine_body": {
            "$ref": "#/components/schemas/FunctionInfoRoutineBody",
            "description": "Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the **external_language** field, and the **return_params** of the function cannot be used (as **TABLE** return type is not supported), and the **sql_data_access** field must be **NO_SQL**."
          },
          "routine_definition": {
            "type": "string",
            "description": "Function body."
          },
          "routine_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "function dependencies."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent Schema relative to its parent Catalog."
          },
          "security_type": {
            "$ref": "#/components/schemas/FunctionInfoSecurityType",
            "description": "Function security type."
          },
          "specific_name": {
            "type": "string",
            "description": "Specific name of the function; Reserved for future use."
          },
          "sql_data_access": {
            "$ref": "#/components/schemas/FunctionInfoSqlDataAccess",
            "description": "Function SQL data access."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this function was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the function."
          }
        }
      },
      "FunctionParameterInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type_text": {
            "type": "string",
            "description": "Full data type spec, SQL/catalogString text."
          },
          "type_name": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Name of type (INT, STRUCT, MAP, etc.)"
          },
          "position": {
            "type": "integer",
            "description": "Ordinal position of column (starting at position 0)."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "parameter_default": {
            "type": "string",
            "description": "Default value of the parameter."
          },
          "parameter_mode": {
            "$ref": "#/components/schemas/FunctionParameterMode",
            "description": "Function parameter mode."
          },
          "parameter_type": {
            "$ref": "#/components/schemas/FunctionParameterType",
            "description": "Function parameter type."
          },
          "type_interval_type": {
            "type": "string",
            "description": "Format of IntervalType."
          },
          "type_json": {
            "type": "string",
            "description": "Full data type spec, JSON-serialized."
          },
          "type_precision": {
            "type": "integer",
            "description": "Digits of precision; required on Create for DecimalTypes."
          },
          "type_scale": {
            "type": "integer",
            "description": "Digits to right of decimal; Required on Create for DecimalTypes."
          }
        },
        "required": [
          "name",
          "type_text",
          "type_name",
          "position"
        ]
      },
      "FunctionParameterInfos": {
        "type": "object",
        "properties": {
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionParameterInfo"
            }
          }
        }
      },
      "GcpOauthToken": {
        "type": "object",
        "properties": {
          "oauth_token": {
            "type": "string"
          }
        },
        "description": "GCP temporary credentials for API authentication. Read more at\n    https://developers.google.com/identity/protocols/oauth2/service-account"
      },
      "GcpPubsub": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "subscription_name": {
            "type": "string",
            "description": "The Pub/Sub subscription name in the format projects/{project}/subscriptions/{subscription name}. Only required for provided_pubsub."
          }
        }
      },
      "GenerateTemporaryPathCredentialResponse": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "azure_user_delegation_sas": {
            "$ref": "#/components/schemas/AzureUserDelegationSas"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          },
          "r2_temp_credentials": {
            "$ref": "#/components/schemas/R2Credentials"
          },
          "url": {
            "type": "string",
            "description": "The URL of the storage path accessible by the temporary credential."
          }
        }
      },
      "GenerateTemporaryServiceCredentialAzureOptions": {
        "type": "object",
        "properties": {
          "resources": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The resources to which the temporary Azure credential should apply. These resources are the scopes that are passed to the token provider (see https://learn.microsoft.com/python/api/azure-core/azure.core.credentials.tokencredential?view=azure-python)"
          }
        },
        "description": "The Azure cloud options to customize the requested temporary credential"
      },
      "GenerateTemporaryServiceCredentialGcpOptions": {
        "type": "object",
        "properties": {
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The scopes to which the temporary GCP credential should apply. These resources are the scopes that are passed to the token provider (see https://google-auth.readthedocs.io/en/latest/reference/google.auth.html#google.auth.credentials.Credentials)"
          }
        },
        "description": "The GCP cloud options to customize the requested temporary credential"
      },
      "GenerateTemporaryTableCredentialResponse": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "azure_user_delegation_sas": {
            "$ref": "#/components/schemas/AzureUserDelegationSas"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          },
          "r2_temp_credentials": {
            "$ref": "#/components/schemas/R2Credentials"
          },
          "url": {
            "type": "string",
            "description": "The URL of the storage path accessible by the temporary credential."
          }
        }
      },
      "GetCatalogWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "workspaces": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "GetMetastoreSummaryResponse": {
        "type": "object",
        "properties": {
          "cloud": {
            "type": "string"
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this metastore was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of metastore creator."
          },
          "default_data_access_config_id": {
            "type": "string",
            "description": "Unique identifier of the metastore's (Default) Data Access Configuration."
          },
          "delta_sharing_organization_name": {
            "type": "string",
            "description": "The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta Sharing as the official name."
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "global_metastore_id": {
            "type": "string",
            "description": "Globally unique metastore ID across clouds and regions, of the form `cloud:region:metastore_id`."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore."
          },
          "name": {
            "type": "string",
            "description": "The user-specified name of the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          },
          "storage_root_credential_name": {
            "type": "string",
            "description": "Name of the storage credential to access the metastore storage_root."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the metastore was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the metastore."
          }
        }
      },
      "GetPermissionsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PrivilegeAssignment"
            },
            "description": "The privileges assigned to each principal"
          }
        }
      },
      "GetQuotaResponse": {
        "type": "object",
        "properties": {
          "quota_info": {
            "$ref": "#/components/schemas/QuotaInfo"
          }
        }
      },
      "GetWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkspaceBinding"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListAccountMetastoreAssignmentsResponse": {
        "type": "object",
        "properties": {
          "workspace_ids": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "description": "The metastore assignments were successfully returned."
      },
      "ListAccountStorageCredentialsResponse": {
        "type": "object",
        "properties": {
          "storage_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorageCredentialInfo"
            },
            "description": "An array of metastore storage credentials."
          }
        },
        "description": "The metastore storage credentials were successfully returned."
      },
      "ListCatalogsResponse": {
        "type": "object",
        "properties": {
          "catalogs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CatalogInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListConnectionsResponse": {
        "type": "object",
        "properties": {
          "connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListCredentialsResponse": {
        "type": "object",
        "properties": {
          "credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CredentialInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListEntityTagAssignmentsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tag_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityTagAssignment"
            },
            "description": "The list of tag assignments"
          }
        }
      },
      "ListExternalLineageRelationshipsResponse": {
        "type": "object",
        "properties": {
          "external_lineage_relationships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalLineageInfo"
            }
          },
          "next_page_token": {
            "type": "string"
          }
        }
      },
      "ListExternalLocationsResponse": {
        "type": "object",
        "properties": {
          "external_locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalLocationInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListExternalMetadataResponse": {
        "type": "object",
        "properties": {
          "external_metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalMetadata"
            }
          },
          "next_page_token": {
            "type": "string"
          }
        }
      },
      "ListFunctionsResponse": {
        "type": "object",
        "properties": {
          "functions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListMetastoresResponse": {
        "type": "object",
        "properties": {
          "metastores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetastoreInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListModelVersionsResponse": {
        "type": "object",
        "properties": {
          "model_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListPoliciesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "policies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PolicyInfo"
            },
            "description": "The list of retrieved policies."
          }
        }
      },
      "ListQuotasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "quotas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuotaInfo"
            },
            "description": "An array of returned QuotaInfos."
          }
        }
      },
      "ListRegisteredModelsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "registered_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelInfo"
            }
          }
        }
      },
      "ListSchemasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SchemaInfo"
            },
            "description": "An array of schema information objects."
          }
        }
      },
      "ListStorageCredentialsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "storage_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorageCredentialInfo"
            }
          }
        }
      },
      "ListSystemSchemasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SystemSchemaInfo"
            },
            "description": "An array of system schema information objects."
          }
        }
      },
      "ListTableSummariesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableSummary"
            },
            "description": "List of table summaries."
          }
        }
      },
      "ListTablesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableInfo"
            },
            "description": "An array of table information objects."
          }
        }
      },
      "ListVolumesResponseContent": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "volumes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VolumeInfo"
            }
          }
        }
      },
      "MatchColumn": {
        "type": "object",
        "properties": {
          "alias": {
            "type": "string"
          },
          "condition": {
            "type": "string",
            "description": "The condition expression used to match a table column."
          }
        }
      },
      "MetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          }
        },
        "required": [
          "workspace_id",
          "metastore_id"
        ]
      },
      "MetastoreInfo": {
        "type": "object",
        "properties": {
          "cloud": {
            "type": "string"
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this metastore was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of metastore creator."
          },
          "default_data_access_config_id": {
            "type": "string",
            "description": "Unique identifier of the metastore's (Default) Data Access Configuration."
          },
          "delta_sharing_organization_name": {
            "type": "string",
            "description": "The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta Sharing as the official name."
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "global_metastore_id": {
            "type": "string",
            "description": "Globally unique metastore ID across clouds and regions, of the form `cloud:region:metastore_id`."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore."
          },
          "name": {
            "type": "string",
            "description": "The user-specified name of the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          },
          "storage_root_credential_name": {
            "type": "string",
            "description": "Name of the storage credential to access the metastore storage_root."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the metastore was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the metastore."
          }
        }
      },
      "ModelVersionInfo": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelAlias"
            }
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog containing the model version"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the model version"
          },
          "created_at": {
            "type": "integer"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the model version"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the model version"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore containing the model version"
          },
          "model_name": {
            "type": "string",
            "description": "The name of the parent registered model of the model version, relative to parent schema"
          },
          "model_version_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "Model version dependencies, for feature-store packaged models"
          },
          "run_id": {
            "type": "string",
            "description": "MLflow run ID used when creating the model version, if ``source`` was generated by an experiment run stored in an MLflow tracking server"
          },
          "run_workspace_id": {
            "type": "integer",
            "description": "ID of the Databricks workspace containing the MLflow run that generated this model version, if applicable"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema containing the model version, relative to parent catalog"
          },
          "source": {
            "type": "string",
            "description": "URI indicating the location of the source artifacts (files) for the model version"
          },
          "status": {
            "$ref": "#/components/schemas/ModelVersionInfoStatus",
            "description": "Current status of the model version. Newly created model versions start in PENDING_REGISTRATION status, then move to READY status once the model version files are uploaded and the model version is finalized. Only model versions in READY status can be loaded for inference or served."
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud under which model version data files are stored"
          },
          "updated_at": {
            "type": "integer"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the model version last time"
          },
          "version": {
            "type": "integer",
            "description": "Integer model version number, used to reference the model version in API requests."
          }
        }
      },
      "MonitorCronSchedule": {
        "type": "object",
        "properties": {
          "quartz_cron_expression": {
            "type": "string"
          },
          "timezone_id": {
            "type": "string",
            "description": "The timezone id (e.g., ``PST``) in which to evaluate the quartz expression."
          },
          "pause_status": {
            "$ref": "#/components/schemas/MonitorCronSchedulePauseStatus",
            "description": "Read only field that indicates whether a schedule is paused or not."
          }
        },
        "required": [
          "quartz_cron_expression",
          "timezone_id"
        ]
      },
      "MonitorDataClassificationConfig": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether to enable data classification."
          }
        },
        "description": "Data classification related configuration."
      },
      "MonitorDestination": {
        "type": "object",
        "properties": {
          "email_addresses": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MonitorInferenceLog": {
        "type": "object",
        "properties": {
          "problem_type": {
            "$ref": "#/components/schemas/MonitorInferenceLogProblemType"
          },
          "timestamp_col": {
            "type": "string",
            "description": "Column for the timestamp."
          },
          "granularities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of granularities to use when aggregating data into time windows based on their timestamp."
          },
          "prediction_col": {
            "type": "string",
            "description": "Column for the prediction."
          },
          "model_id_col": {
            "type": "string",
            "description": "Column for the model identifier."
          },
          "label_col": {
            "type": "string",
            "description": "Column for the label."
          },
          "prediction_proba_col": {
            "type": "string",
            "description": "Column for prediction probabilities"
          }
        },
        "required": [
          "problem_type",
          "timestamp_col",
          "granularities",
          "prediction_col",
          "model_id_col"
        ]
      },
      "MonitorInfo": {
        "type": "object",
        "properties": {
          "output_schema_name": {
            "type": "string"
          },
          "table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] UC table to monitor. Format: `catalog.schema.table_name`"
          },
          "status": {
            "$ref": "#/components/schemas/MonitorInfoStatus",
            "description": "[Create:ERR Update:IGN] The monitor status."
          },
          "profile_metrics_table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] Table that stores profile metrics data. Format: `catalog.schema.table_name`."
          },
          "drift_metrics_table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] Table that stores drift metrics data. Format: `catalog.schema.table_name`."
          },
          "monitor_version": {
            "type": "integer",
            "description": "[Create:ERR Update:IGN] Represents the current monitor configuration version in use. The version will be represented in a numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted monitor_version numbers."
          },
          "assets_dir": {
            "type": "string",
            "description": "[Create:REQ Update:IGN] Field for specifying the absolute path to a custom directory to store data-monitoring assets. Normally prepopulated to a default user location via UI and Python APIs."
          },
          "baseline_table_name": {
            "type": "string",
            "description": "[Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in the monitored `table_name`. The baseline table and the monitored table shall have the same schema."
          },
          "custom_metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitorMetric"
            },
            "description": "[Create:OPT Update:OPT] Custom metrics."
          },
          "dashboard_id": {
            "type": "string",
            "description": "[Create:ERR Update:OPT] Id of dashboard that visualizes the computed metrics. This can be empty if the monitor is in PENDING state."
          },
          "data_classification_config": {
            "$ref": "#/components/schemas/MonitorDataClassificationConfig",
            "description": "[Create:OPT Update:OPT] Data classification related config."
          },
          "inference_log": {
            "$ref": "#/components/schemas/MonitorInferenceLog"
          },
          "latest_monitor_failure_msg": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] The latest error message for a monitor failure."
          },
          "notifications": {
            "$ref": "#/components/schemas/MonitorNotifications",
            "description": "[Create:OPT Update:OPT] Field for specifying notification settings."
          },
          "schedule": {
            "$ref": "#/components/schemas/MonitorCronSchedule",
            "description": "[Create:OPT Update:OPT] The monitor schedule."
          },
          "slicing_exprs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "[Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The data is grouped by each expression independently, resulting in a separate slice for each predicate and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate slices."
          },
          "snapshot": {
            "$ref": "#/components/schemas/MonitorSnapshot",
            "description": "Configuration for monitoring snapshot tables."
          },
          "time_series": {
            "$ref": "#/components/schemas/MonitorTimeSeries",
            "description": "Configuration for monitoring time series tables."
          }
        },
        "required": [
          "output_schema_name",
          "table_name",
          "status",
          "profile_metrics_table_name",
          "drift_metrics_table_name",
          "monitor_version"
        ]
      },
      "MonitorMetric": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the metric in the output tables."
          },
          "definition": {
            "type": "string",
            "description": "Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition]. [create metric definition]: https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition"
          },
          "input_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of column names in the input table the metric should be computed for. Can use ``\":table\"`` to indicate that the metric needs information from multiple columns."
          },
          "output_data_type": {
            "type": "string",
            "description": "The output type of the custom metric."
          },
          "type": {
            "$ref": "#/components/schemas/MonitorMetricType",
            "description": "Can only be one of ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"``, ``\"CUSTOM_METRIC_TYPE_DERIVED\"``, or ``\"CUSTOM_METRIC_TYPE_DRIFT\"``. The ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"`` and ``\"CUSTOM_METRIC_TYPE_DERIVED\"`` metrics are computed on a single table, whereas the ``\"CUSTOM_METRIC_TYPE_DRIFT\"`` compare metrics across baseline and input table, or across the two consecutive time windows. - CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing columns in your table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed aggregate metrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously computed aggregate or derived metrics"
          }
        },
        "required": [
          "name",
          "definition",
          "input_columns",
          "output_data_type",
          "type"
        ],
        "description": "Custom metric definition."
      },
      "MonitorNotifications": {
        "type": "object",
        "properties": {
          "on_failure": {
            "$ref": "#/components/schemas/MonitorDestination"
          },
          "on_new_classification_tag_detected": {
            "$ref": "#/components/schemas/MonitorDestination",
            "description": "Destinations to send notifications on new classification tag detected."
          }
        }
      },
      "MonitorRefreshInfo": {
        "type": "object",
        "properties": {
          "refresh_id": {
            "type": "integer"
          },
          "state": {
            "$ref": "#/components/schemas/MonitorRefreshInfoState",
            "description": "The current state of the refresh."
          },
          "start_time_ms": {
            "type": "integer",
            "description": "Time at which refresh operation was initiated (milliseconds since 1/1/1970 UTC)."
          },
          "end_time_ms": {
            "type": "integer",
            "description": "Time at which refresh operation completed (milliseconds since 1/1/1970 UTC)."
          },
          "message": {
            "type": "string",
            "description": "An optional message to give insight into the current state of the job (e.g. FAILURE messages)."
          },
          "trigger": {
            "$ref": "#/components/schemas/MonitorRefreshInfoTrigger",
            "description": "The method by which the refresh was triggered."
          }
        },
        "required": [
          "refresh_id",
          "state",
          "start_time_ms"
        ]
      },
      "MonitorRefreshListResponse": {
        "type": "object",
        "properties": {
          "refreshes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitorRefreshInfo"
            }
          }
        }
      },
      "MonitorSnapshot": {
        "type": "object",
        "properties": {},
        "description": "Snapshot analysis configuration"
      },
      "MonitorTimeSeries": {
        "type": "object",
        "properties": {
          "timestamp_col": {
            "type": "string",
            "description": "Column for the timestamp."
          },
          "granularities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Granularities for aggregating data into time windows based on their timestamp. Currently the following static granularities are supported: {``\\\"5 minutes\\\"``, ``\\\"30 minutes\\\"``, ``\\\"1 hour\\\"``, ``\\\"1 day\\\"``, ``\\\"\\u003cn\\u003e week(s)\\\"``, ``\\\"1 month\\\"``, ``\\\"1 year\\\"``}."
          }
        },
        "required": [
          "timestamp_col",
          "granularities"
        ],
        "description": "Time series analysis configuration."
      },
      "NamedTableConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "NotificationDestination": {
        "type": "object",
        "properties": {
          "destination_id": {
            "type": "string"
          },
          "destination_type": {
            "$ref": "#/components/schemas/DestinationType",
            "description": "The type of the destination."
          },
          "special_destination": {
            "$ref": "#/components/schemas/SpecialDestination",
            "description": "This field is used to denote whether the destination is the email of the owner of the securable object. The special destination cannot be assigned to a securable and only represents the default destination of the securable. The securable types that support default special destinations are: \"catalog\", \"external_location\", \"connection\", \"credential\", and \"metastore\". The **destination_type** of a **special_destination** is always EMAIL."
          }
        }
      },
      "OnlineTable": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Full three-part (catalog, schema, table) name of the table."
          },
          "spec": {
            "$ref": "#/components/schemas/OnlineTableSpec",
            "description": "Specification of the online table."
          },
          "status": {
            "$ref": "#/components/schemas/OnlineTableStatus",
            "description": "Online Table data synchronization status"
          },
          "table_serving_url": {
            "type": "string",
            "description": "Data serving REST API URL for this table"
          },
          "unity_catalog_provisioning_state": {
            "$ref": "#/components/schemas/ProvisioningInfoState",
            "description": "The provisioning state of the online table entity in Unity Catalog. This is distinct from the state of the data synchronization pipeline (i.e. the table may be in \"ACTIVE\" but the pipeline may be in \"PROVISIONING\" as it runs asynchronously)."
          }
        },
        "description": "Online Table information."
      },
      "OnlineTableSpec": {
        "type": "object",
        "properties": {
          "perform_full_copy": {
            "type": "boolean",
            "description": "Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports \"triggered\" scheduling policy."
          },
          "pipeline_id": {
            "type": "string",
            "description": "ID of the associated pipeline. Generated by the server - cannot be set by the caller."
          },
          "primary_key_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Primary Key columns to be used for data insert/update in the destination."
          },
          "run_continuously": {
            "$ref": "#/components/schemas/OnlineTableSpecContinuousSchedulingPolicy",
            "description": "Pipeline runs continuously after generating the initial data."
          },
          "run_triggered": {
            "$ref": "#/components/schemas/OnlineTableSpecTriggeredSchedulingPolicy",
            "description": "Pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers)"
          },
          "source_table_full_name": {
            "type": "string",
            "description": "Three-part (catalog, schema, table) name of the source Delta table."
          },
          "timeseries_key": {
            "type": "string",
            "description": "Time series key to deduplicate (tie-break) rows with the same primary key."
          }
        },
        "description": "Specification of an online table."
      },
      "OnlineTableSpecContinuousSchedulingPolicy": {
        "type": "object",
        "properties": {}
      },
      "OnlineTableSpecTriggeredSchedulingPolicy": {
        "type": "object",
        "properties": {}
      },
      "OnlineTableStatus": {
        "type": "object",
        "properties": {
          "continuous_update_status": {
            "$ref": "#/components/schemas/ContinuousUpdateStatus"
          },
          "detailed_state": {
            "$ref": "#/components/schemas/OnlineTableState",
            "description": "The state of the online table."
          },
          "failed_status": {
            "$ref": "#/components/schemas/FailedStatus"
          },
          "message": {
            "type": "string",
            "description": "A text description of the current state of the online table."
          },
          "provisioning_status": {
            "$ref": "#/components/schemas/ProvisioningStatus"
          },
          "triggered_update_status": {
            "$ref": "#/components/schemas/TriggeredUpdateStatus"
          }
        },
        "description": "Status of an online table."
      },
      "OptionSpec": {
        "type": "object",
        "properties": {
          "allowed_values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "For drop down / radio button selections, UI will want to know the possible input values, it can also be used by other option types to limit input selections."
          },
          "default_value": {
            "type": "string",
            "description": "The default value of the option, for example, value '443' for 'port' option."
          },
          "description": {
            "type": "string",
            "description": "A concise user facing description of what the input value of this option should look like."
          },
          "hint": {
            "type": "string",
            "description": "The hint is used on the UI to suggest what the input value can possibly be like, for example: example.com for 'host' option. Unlike default value, it will not be applied automatically without user input."
          },
          "is_copiable": {
            "type": "boolean",
            "description": "Indicates whether an option should be displayed with copy button on the UI."
          },
          "is_creatable": {
            "type": "boolean",
            "description": "Indicates whether an option can be provided by users in the create/update path of an entity."
          },
          "is_hidden": {
            "type": "boolean",
            "description": "Is the option value not user settable and is thus not shown on the UI."
          },
          "is_loggable": {
            "type": "boolean",
            "description": "Specifies whether this option is safe to log, i.e. no sensitive information."
          },
          "is_required": {
            "type": "boolean",
            "description": "Is the option required."
          },
          "is_secret": {
            "type": "boolean",
            "description": "Is the option value considered secret and thus redacted on the UI."
          },
          "is_updatable": {
            "type": "boolean",
            "description": "Is the option updatable by users."
          },
          "name": {
            "type": "string",
            "description": "The unique name of the option."
          },
          "oauth_stage": {
            "$ref": "#/components/schemas/OptionSpecOauthStage",
            "description": "Specifies when the option value is displayed on the UI within the OAuth flow."
          },
          "type": {
            "$ref": "#/components/schemas/OptionSpecOptionType",
            "description": "The type of the option."
          }
        },
        "description": "Spec of an allowed option on a securable kind and its attributes. This is mostly used by UI to\n    provide user friendly hints and descriptions in order to facilitate the securable creation\n    process."
      },
      "PermissionsChange": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            }
          },
          "principal": {
            "type": "string",
            "description": "The principal whose privileges we are changing. Only one of principal or principal_id should be specified, never both at the same time."
          },
          "remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            },
            "description": "The set of privileges to remove."
          }
        }
      },
      "PipelineProgress": {
        "type": "object",
        "properties": {
          "estimated_completion_time_seconds": {
            "type": "number",
            "description": "The estimated time remaining to complete this update in seconds."
          },
          "latest_version_currently_processing": {
            "type": "integer",
            "description": "The source table Delta version that was last processed by the pipeline. The pipeline may not have completely processed this version yet."
          },
          "sync_progress_completion": {
            "type": "number",
            "description": "The completion ratio of this update. This is a number between 0 and 1."
          },
          "synced_row_count": {
            "type": "integer",
            "description": "The number of rows that have been synced in this update."
          },
          "total_row_count": {
            "type": "integer",
            "description": "The total number of rows that need to be synced in this update. This number may be an estimate."
          }
        },
        "description": "Progress information of the Online Table data synchronization pipeline."
      },
      "PolicyInfo": {
        "type": "object",
        "properties": {
          "to_principals": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "for_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Type of securables that the policy should take effect on. Only `TABLE` is supported at this moment. Required on create and optional on update."
          },
          "policy_type": {
            "$ref": "#/components/schemas/PolicyType",
            "description": "Type of the policy. Required on create."
          },
          "column_mask": {
            "$ref": "#/components/schemas/ColumnMaskOptions",
            "description": "Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`. Required on create and optional on update. When specified on update, the new options will replace the existing options as a whole."
          },
          "comment": {
            "type": "string",
            "description": "Optional description of the policy."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which the policy was created, in epoch milliseconds. Output only."
          },
          "created_by": {
            "type": "string",
            "description": "Username of the user who created the policy. Output only."
          },
          "except_principals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional list of user or group names that should be excluded from the policy."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the policy. This field is output only and is generated by the system."
          },
          "match_columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MatchColumn"
            },
            "description": "Optional list of condition expressions used to match table columns. Only valid when `for_securable_type` is `TABLE`. When specified, the policy only applies to tables whose columns satisfy all match conditions."
          },
          "name": {
            "type": "string",
            "description": "Name of the policy. Required on create and optional on update. To rename the policy, set `name` to a different value on update."
          },
          "on_securable_fullname": {
            "type": "string",
            "description": "Full name of the securable on which the policy is defined. Required on create."
          },
          "on_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Type of the securable on which the policy is defined. Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment. Required on create."
          },
          "row_filter": {
            "$ref": "#/components/schemas/RowFilterOptions",
            "description": "Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`. Required on create and optional on update. When specified on update, the new options will replace the existing options as a whole."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the policy was last modified, in epoch milliseconds. Output only."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of the user who last modified the policy. Output only."
          },
          "when_condition": {
            "type": "string",
            "description": "Optional condition when the policy should take effect."
          }
        },
        "required": [
          "to_principals",
          "for_securable_type",
          "policy_type"
        ]
      },
      "PrimaryKeyConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "child_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "rely": {
            "type": "boolean",
            "description": "True if the constraint is RELY, false or unset if NORELY."
          },
          "timeseries_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names that represent a timeseries."
          }
        },
        "required": [
          "name",
          "child_columns"
        ]
      },
      "Principal": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "principal_type": {
            "$ref": "#/components/schemas/PrincipalType"
          }
        }
      },
      "PrivilegeAssignment": {
        "type": "object",
        "properties": {
          "principal": {
            "type": "string"
          },
          "privileges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            },
            "description": "The privileges assigned to the principal."
          }
        }
      },
      "ProvisioningInfo": {
        "type": "object",
        "properties": {
          "state": {
            "$ref": "#/components/schemas/ProvisioningInfoState",
            "description": "The provisioning state of the resource."
          }
        },
        "description": "Status of an asynchronously provisioned resource."
      },
      "ProvisioningStatus": {
        "type": "object",
        "properties": {
          "initial_pipeline_sync_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Details about initial data synchronization. Only populated when in the PROVISIONING_INITIAL_SNAPSHOT state."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the\n    PROVISIONING_PIPELINE_RESOURCES or the PROVISIONING_INITIAL_SNAPSHOT state."
      },
      "QuotaInfo": {
        "type": "object",
        "properties": {
          "last_refreshed_at": {
            "type": "integer"
          },
          "parent_full_name": {
            "type": "string",
            "description": "Name of the parent resource. Returns metastore ID if the parent is a metastore."
          },
          "parent_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "The quota parent securable type."
          },
          "quota_count": {
            "type": "integer",
            "description": "The current usage of the resource quota."
          },
          "quota_limit": {
            "type": "integer",
            "description": "The current limit of the resource quota."
          },
          "quota_name": {
            "type": "string",
            "description": "The name of the quota."
          }
        }
      },
      "R2Credentials": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID that identifies the temporary credentials."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access key associated with the access key."
          },
          "session_token": {
            "type": "string",
            "description": "The generated JWT that users must pass to use the temporary credentials."
          }
        },
        "description": "R2 temporary credentials for API authentication. Read more at\n    https://developers.cloudflare.com/r2/api/s3/tokens/."
      },
      "RegenerateDashboardResponse": {
        "type": "object",
        "properties": {
          "dashboard_id": {
            "type": "string"
          },
          "parent_folder": {
            "type": "string",
            "description": "Parent folder is equivalent to {assets_dir}/{tableName}"
          }
        }
      },
      "RegisteredModelAlias": {
        "type": "object",
        "properties": {
          "alias_name": {
            "type": "string"
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog containing the model version"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the alias"
          },
          "model_name": {
            "type": "string",
            "description": "The name of the parent registered model of the model version, relative to parent schema"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema containing the model version, relative to parent catalog"
          },
          "version_num": {
            "type": "integer",
            "description": "Integer version number of the model version to which this alias points."
          }
        }
      },
      "RegisteredModelInfo": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelAlias"
            }
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog where the schema and the registered model reside"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the registered model"
          },
          "created_at": {
            "type": "integer",
            "description": "Creation timestamp of the registered model in milliseconds since the Unix epoch"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the registered model"
          },
          "full_name": {
            "type": "string",
            "description": "The three-level (fully qualified) name of the registered model"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore"
          },
          "name": {
            "type": "string",
            "description": "The name of the registered model"
          },
          "owner": {
            "type": "string",
            "description": "The identifier of the user who owns the registered model"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema where the registered model resides"
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud under which model version data files are stored"
          },
          "updated_at": {
            "type": "integer",
            "description": "Last-update timestamp of the registered model in milliseconds since the Unix epoch"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the registered model last time"
          }
        }
      },
      "RowFilterOptions": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "using": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionArgument"
            },
            "description": "Optional list of column aliases or constant literals to be passed as arguments to the row filter function. The type of each column should match the positional argument of the row filter function."
          }
        },
        "required": [
          "function_name"
        ]
      },
      "SchemaInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent catalog."
          },
          "catalog_type": {
            "$ref": "#/components/schemas/CatalogType",
            "description": "The type of the parent catalog."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this schema was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of schema creator."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization",
            "description": "Whether predictive optimization should be enabled for this object and objects under it."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of schema, in form of __catalog_name__.__schema_name__."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of schema, relative to parent catalog."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of schema."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "schema_id": {
            "type": "string",
            "description": "The unique identifier of the schema."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage location for managed tables within schema."
          },
          "storage_root": {
            "type": "string",
            "description": "Storage root URL for managed tables within schema."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this schema was created, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified schema."
          }
        },
        "description": "Next ID: 45"
      },
      "Securable": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string",
            "description": "Required. The full name of the catalog/schema/table. Optional if resource_name is present."
          },
          "provider_share": {
            "type": "string",
            "description": "Optional. The name of the Share object that contains the securable when the securable is getting shared in D2D Delta Sharing."
          },
          "type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Required. The type of securable (catalog/schema/table). Optional if resource_name is present."
          }
        },
        "description": "Generic definition of a securable, which is uniquely defined in a metastore by its type and full\n    name."
      },
      "SecurableKindManifest": {
        "type": "object",
        "properties": {
          "assignable_privileges": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Privileges that can be assigned to the securable."
          },
          "capabilities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of capabilities in the securable kind."
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OptionSpec"
            },
            "description": "Detailed specs of allowed options."
          },
          "securable_kind": {
            "$ref": "#/components/schemas/SecurableKind",
            "description": "Securable kind to get manifest of."
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Securable Type of the kind."
          }
        },
        "description": "Manifest of a specific securable kind."
      },
      "SecurablePermissions": {
        "type": "object",
        "properties": {
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "securable": {
            "$ref": "#/components/schemas/Securable",
            "description": "The securable for which the access request destinations are being requested."
          }
        }
      },
      "SseEncryptionDetails": {
        "type": "object",
        "properties": {
          "algorithm": {
            "$ref": "#/components/schemas/SseEncryptionDetailsAlgorithm",
            "description": "Sets the value of the 'x-amz-server-side-encryption' header in S3 request."
          },
          "aws_kms_key_arn": {
            "type": "string",
            "description": "Optional. The ARN of the SSE-KMS key used with the S3 location, when algorithm = \"SSE-KMS\". Sets the value of the 'x-amz-server-side-encryption-aws-kms-key-id' header."
          }
        },
        "description": "Server-Side Encryption properties for clients communicating with AWS s3."
      },
      "StorageCredentialInfo": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleResponse"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityResponse",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this credential was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of credential creator."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountResponse",
            "description": "The Databricks managed GCP service account configuration."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the credential."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the credential."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of the parent metastore."
          },
          "name": {
            "type": "string",
            "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this credential was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the credential."
          },
          "used_for_managed_storage": {
            "type": "boolean",
            "description": "Whether this credential is the current metastore's root storage credential. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "SystemSchemaInfo": {
        "type": "object",
        "properties": {
          "schema": {
            "type": "string"
          },
          "state": {
            "type": "string",
            "description": "The current state of enablement for the system schema. An empty string means the system schema is available and ready for opt-in. Possible values: AVAILABLE | ENABLE_INITIALIZED | ENABLE_COMPLETED | DISABLE_INITIALIZED | UNAVAILABLE | MANAGED"
          }
        },
        "required": [
          "schema",
          "state"
        ]
      },
      "TableConstraint": {
        "type": "object",
        "properties": {
          "foreign_key_constraint": {
            "$ref": "#/components/schemas/ForeignKeyConstraint"
          },
          "named_table_constraint": {
            "$ref": "#/components/schemas/NamedTableConstraint"
          },
          "primary_key_constraint": {
            "$ref": "#/components/schemas/PrimaryKeyConstraint"
          }
        },
        "description": "A table constraint, as defined by *one* of the following fields being set:\n    __primary_key_constraint__, __foreign_key_constraint__, __named_table_constraint__."
      },
      "TableDependency": {
        "type": "object",
        "properties": {
          "table_full_name": {
            "type": "string",
            "description": "Full name of the dependent table, in the form of __catalog_name__.__schema_name__.__table_name__."
          }
        },
        "required": [
          "table_full_name"
        ],
        "description": "A table that is dependent on a SQL object."
      },
      "TableExistsResponse": {
        "type": "object",
        "properties": {
          "table_exists": {
            "type": "boolean"
          }
        }
      },
      "TableInfo": {
        "type": "object",
        "properties": {
          "access_point": {
            "type": "string"
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent catalog."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "The array of __ColumnInfo__ definitions of the table's columns."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this table was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of table creator."
          },
          "data_access_configuration_id": {
            "type": "string",
            "description": "Unique ID of the Data Access Configuration to use with the table data."
          },
          "data_source_format": {
            "$ref": "#/components/schemas/DataSourceFormat"
          },
          "deleted_at": {
            "type": "integer",
            "description": "Time at which this table was deleted, in epoch milliseconds. Field is omitted if table is not deleted."
          },
          "delta_runtime_properties_kvpairs": {
            "$ref": "#/components/schemas/DeltaRuntimePropertiesKvPairs",
            "description": "Information pertaining to current state of the delta table."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization"
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "full_name": {
            "type": "string",
            "description": "Full name of table, in form of __catalog_name__.__schema_name__.__table_name__"
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of table, relative to parent schema."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of table."
          },
          "pipeline_id": {
            "type": "string",
            "description": "The pipeline ID of the table. Applicable for tables created by pipelines (Materialized View, Streaming Table, etc.)."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "row_filter": {
            "$ref": "#/components/schemas/TableRowFilter"
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent schema relative to its parent catalog."
          },
          "securable_kind_manifest": {
            "$ref": "#/components/schemas/SecurableKindManifest",
            "description": "SecurableKindManifest of table, including capabilities the table has."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          },
          "storage_credential_name": {
            "type": "string",
            "description": "Name of the storage credential, when a storage credential is configured for use with this table."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage root URL for table (for **MANAGED**, **EXTERNAL** tables)."
          },
          "table_constraints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableConstraint"
            },
            "description": "List of table constraints. Note: this field is not set in the output of the __listTables__ API."
          },
          "table_id": {
            "type": "string",
            "description": "The unique identifier of the table."
          },
          "table_type": {
            "$ref": "#/components/schemas/TableType"
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this table was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the table."
          },
          "view_definition": {
            "type": "string",
            "description": "View definition SQL (when __table_type__ is **VIEW**, **MATERIALIZED_VIEW**, or **STREAMING_TABLE**)"
          },
          "view_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "View dependencies (when table_type == **VIEW** or **MATERIALIZED_VIEW**, **STREAMING_TABLE**) - when DependencyList is None, the dependency is not provided; - when DependencyList is an empty list, the dependency is provided but is empty; - when DependencyList is not an empty list, dependencies are provided and recorded. Note: this field is not set in the output of the __listTables__ API."
          }
        }
      },
      "TableRowFilter": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "input_column_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of table columns to be passed as input to the row filter function. The column types should match the types of the filter function arguments."
          }
        },
        "required": [
          "function_name",
          "input_column_names"
        ]
      },
      "TableSummary": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string"
          },
          "securable_kind_manifest": {
            "$ref": "#/components/schemas/SecurableKindManifest",
            "description": "SecurableKindManifest of table, including capabilities the table has."
          },
          "table_type": {
            "$ref": "#/components/schemas/TableType"
          }
        }
      },
      "TagKeyValue": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string",
            "description": "value of the tag associated with the key, could be optional"
          }
        }
      },
      "TemporaryCredentials": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          }
        }
      },
      "TriggeredUpdateStatus": {
        "type": "object",
        "properties": {
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may not be completely synced to the online table yet."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table."
          },
          "triggered_update_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Progress of the active data synchronization pipeline."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the ONLINE_TRIGGERED_UPDATE\n    or the ONLINE_NO_PENDING_UPDATE state."
      },
      "UnassignResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateAccountsMetastore": {
        "type": "object",
        "properties": {
          "delta_sharing_organization_name": {
            "type": "string"
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          }
        }
      },
      "UpdateAccountsStorageCredential": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleRequest"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityResponse",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountRequest",
            "description": "The Databricks managed GCP service account configuration."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "UpdateAssignmentResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateCatalogWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "workspaces": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "UpdateMetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          }
        },
        "required": [
          "workspace_id"
        ]
      },
      "UpdatePermissionsResponse": {
        "type": "object",
        "properties": {
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PrivilegeAssignment"
            }
          }
        }
      },
      "UpdateRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "UpdateResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkspaceBinding"
            },
            "description": "List of workspace bindings."
          }
        },
        "description": "A list of workspace IDs that are bound to the securable"
      },
      "ValidateCredentialResponse": {
        "type": "object",
        "properties": {
          "is_dir": {
            "type": "boolean"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CredentialValidationResult"
            },
            "description": "The results of the validation check."
          }
        }
      },
      "ValidateStorageCredentialResponse": {
        "type": "object",
        "properties": {
          "is_dir": {
            "type": "boolean"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationResult"
            },
            "description": "The results of the validation check."
          }
        }
      },
      "ValidationResult": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "operation": {
            "$ref": "#/components/schemas/ValidationResultOperation",
            "description": "The operation tested."
          },
          "result": {
            "$ref": "#/components/schemas/ValidationResultResult",
            "description": "The results of the tested operation."
          }
        }
      },
      "VolumeInfo": {
        "type": "object",
        "properties": {
          "access_point": {
            "type": "string"
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog where the schema and the volume are"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the volume"
          },
          "created_at": {
            "type": "integer"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the volume"
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "full_name": {
            "type": "string",
            "description": "The three-level (fully qualified) name of the volume"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore"
          },
          "name": {
            "type": "string",
            "description": "The name of the volume"
          },
          "owner": {
            "type": "string",
            "description": "The identifier of the user who owns the volume"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema where the volume is"
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud"
          },
          "updated_at": {
            "type": "integer"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the volume last time"
          },
          "volume_id": {
            "type": "string",
            "description": "The unique identifier of the volume"
          },
          "volume_type": {
            "$ref": "#/components/schemas/VolumeType",
            "description": "The type of the volume. An external volume is located in the specified external location. A managed volume is located in the default location which is specified by the parent schema, or the parent catalog, or the Metastore. [Learn more] [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external"
          }
        }
      },
      "WorkspaceBinding": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "binding_type": {
            "$ref": "#/components/schemas/WorkspaceBindingBindingType",
            "description": "One of READ_WRITE/READ_ONLY. Default is READ_WRITE."
          }
        },
        "required": [
          "workspace_id"
        ]
      },
      "ArtifactType": {
        "type": "string",
        "enum": [
          "INIT_SCRIPT",
          "LIBRARY_JAR",
          "LIBRARY_MAVEN"
        ],
        "description": "The artifact type"
      },
      "CatalogIsolationMode": {
        "type": "string",
        "enum": [
          "ISOLATED",
          "OPEN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CatalogType": {
        "type": "string",
        "enum": [
          "DELTASHARING_CATALOG",
          "FOREIGN_CATALOG",
          "INTERNAL_CATALOG",
          "MANAGED_CATALOG",
          "MANAGED_ONLINE_CATALOG",
          "SYSTEM_CATALOG"
        ],
        "description": "The type of the catalog."
      },
      "ColumnTypeName": {
        "type": "string",
        "enum": [
          "ARRAY",
          "BINARY",
          "BOOLEAN",
          "BYTE",
          "CHAR",
          "DATE",
          "DECIMAL",
          "DOUBLE",
          "FLOAT",
          "GEOGRAPHY",
          "GEOMETRY",
          "INT",
          "INTERVAL",
          "LONG",
          "MAP",
          "NULL",
          "SHORT",
          "STRING",
          "STRUCT",
          "TABLE_TYPE",
          "TIMESTAMP",
          "TIMESTAMP_NTZ",
          "USER_DEFINED_TYPE",
          "VARIANT"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ConnectionType": {
        "type": "string",
        "enum": [
          "BIGQUERY",
          "DATABRICKS",
          "GA4_RAW_DATA",
          "GLUE",
          "HIVE_METASTORE",
          "HTTP",
          "MYSQL",
          "ORACLE",
          "POSTGRESQL",
          "POWER_BI",
          "REDSHIFT",
          "SALESFORCE",
          "SALESFORCE_DATA_CLOUD",
          "SERVICENOW",
          "SNOWFLAKE",
          "SQLDW",
          "SQLSERVER",
          "TERADATA",
          "UNKNOWN_CONNECTION_TYPE",
          "WORKDAY_RAAS"
        ],
        "description": "Next Id: 72"
      },
      "CreateFunctionParameterStyle": {
        "type": "string",
        "enum": [
          "S"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionRoutineBody": {
        "type": "string",
        "enum": [
          "EXTERNAL",
          "SQL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionSecurityType": {
        "type": "string",
        "enum": [
          "DEFINER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionSqlDataAccess": {
        "type": "string",
        "enum": [
          "CONTAINS_SQL",
          "NO_SQL",
          "READS_SQL_DATA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CredentialPurpose": {
        "type": "string",
        "enum": [
          "SERVICE",
          "STORAGE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CredentialType": {
        "type": "string",
        "enum": [
          "ANY_STATIC_CREDENTIAL",
          "BEARER_TOKEN",
          "OAUTH_ACCESS_TOKEN",
          "OAUTH_M2M",
          "OAUTH_MTLS",
          "OAUTH_REFRESH_TOKEN",
          "OAUTH_RESOURCE_OWNER_PASSWORD",
          "OAUTH_U2M",
          "OAUTH_U2M_MAPPING",
          "OIDC_TOKEN",
          "PEM_PRIVATE_KEY",
          "SERVICE_CREDENTIAL",
          "SSWS_TOKEN",
          "UNKNOWN_CREDENTIAL_TYPE",
          "USERNAME_PASSWORD"
        ],
        "description": "Next Id: 15"
      },
      "DataSourceFormat": {
        "type": "string",
        "enum": [
          "AVRO",
          "BIGQUERY_FORMAT",
          "CSV",
          "DATABRICKS_FORMAT",
          "DATABRICKS_ROW_STORE_FORMAT",
          "DELTA",
          "DELTASHARING",
          "DELTA_UNIFORM_HUDI",
          "DELTA_UNIFORM_ICEBERG",
          "HIVE",
          "ICEBERG",
          "JSON",
          "MONGODB_FORMAT",
          "MYSQL_FORMAT",
          "NETSUITE_FORMAT",
          "ORACLE_FORMAT",
          "ORC",
          "PARQUET",
          "POSTGRESQL_FORMAT",
          "REDSHIFT_FORMAT",
          "SALESFORCE_DATA_CLOUD_FORMAT",
          "SALESFORCE_FORMAT",
          "SNOWFLAKE_FORMAT",
          "SQLDW_FORMAT",
          "SQLSERVER_FORMAT",
          "TERADATA_FORMAT",
          "TEXT",
          "UNITY_CATALOG",
          "VECTOR_INDEX_FORMAT",
          "WORKDAY_RAAS_FORMAT"
        ],
        "description": "Data source format"
      },
      "DeltaSharingScopeEnum": {
        "type": "string",
        "enum": [
          "INTERNAL",
          "INTERNAL_AND_EXTERNAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DestinationType": {
        "type": "string",
        "enum": [
          "EMAIL",
          "GENERIC_WEBHOOK",
          "MICROSOFT_TEAMS",
          "SLACK",
          "URL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EffectivePredictiveOptimizationFlagInheritedFromType": {
        "type": "string",
        "enum": [
          "CATALOG",
          "SCHEMA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EnablePredictiveOptimization": {
        "type": "string",
        "enum": [
          "DISABLE",
          "ENABLE",
          "INHERIT"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoParameterStyle": {
        "type": "string",
        "enum": [
          "S"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoRoutineBody": {
        "type": "string",
        "enum": [
          "EXTERNAL",
          "SQL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoSecurityType": {
        "type": "string",
        "enum": [
          "DEFINER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoSqlDataAccess": {
        "type": "string",
        "enum": [
          "CONTAINS_SQL",
          "NO_SQL",
          "READS_SQL_DATA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionParameterMode": {
        "type": "string",
        "enum": [
          "IN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionParameterType": {
        "type": "string",
        "enum": [
          "COLUMN",
          "PARAM"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "IsolationMode": {
        "type": "string",
        "enum": [
          "ISOLATION_MODE_ISOLATED",
          "ISOLATION_MODE_OPEN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "LineageDirection": {
        "type": "string",
        "enum": [
          "DOWNSTREAM",
          "UPSTREAM"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MatchType": {
        "type": "string",
        "enum": [
          "PREFIX_MATCH"
        ],
        "description": "The artifact pattern matching type"
      },
      "ModelVersionInfoStatus": {
        "type": "string",
        "enum": [
          "FAILED_REGISTRATION",
          "MODEL_VERSION_STATUS_UNKNOWN",
          "PENDING_REGISTRATION",
          "READY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorCronSchedulePauseStatus": {
        "type": "string",
        "enum": [
          "PAUSED",
          "UNPAUSED",
          "UNSPECIFIED"
        ],
        "description": "Source link:\nhttps://src.dev.databricks.com/databricks/universe/-/blob/elastic-spark-common/api/messages/schedule.proto\nMonitoring workflow schedule pause status."
      },
      "MonitorInferenceLogProblemType": {
        "type": "string",
        "enum": [
          "PROBLEM_TYPE_CLASSIFICATION",
          "PROBLEM_TYPE_REGRESSION"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorInfoStatus": {
        "type": "string",
        "enum": [
          "MONITOR_STATUS_ACTIVE",
          "MONITOR_STATUS_DELETE_PENDING",
          "MONITOR_STATUS_ERROR",
          "MONITOR_STATUS_FAILED",
          "MONITOR_STATUS_PENDING"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorMetricType": {
        "type": "string",
        "enum": [
          "CUSTOM_METRIC_TYPE_AGGREGATE",
          "CUSTOM_METRIC_TYPE_DERIVED",
          "CUSTOM_METRIC_TYPE_DRIFT"
        ],
        "description": "Can only be one of ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"``, ``\"CUSTOM_METRIC_TYPE_DERIVED\"``, or\n``\"CUSTOM_METRIC_TYPE_DRIFT\"``. The ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"`` and\n``\"CUSTOM_METRIC_TYPE_DERIVED\"`` metrics are computed on a single table, whereas the\n``\"CUSTOM_METRIC_TYPE_DRIFT\"`` compare metrics across baseline and input table, or across the\ntwo consecutive time windows. - CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing\ncolumns in your table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed aggregate\nmetrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously computed aggregate or derived metrics"
      },
      "MonitorRefreshInfoState": {
        "type": "string",
        "enum": [
          "CANCELED",
          "FAILED",
          "PENDING",
          "RUNNING",
          "SUCCESS",
          "UNKNOWN"
        ],
        "description": "The current state of the refresh."
      },
      "MonitorRefreshInfoTrigger": {
        "type": "string",
        "enum": [
          "MANUAL",
          "SCHEDULE",
          "UNKNOWN_TRIGGER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "OnlineTableState": {
        "type": "string",
        "enum": [
          "OFFLINE",
          "OFFLINE_FAILED",
          "ONLINE",
          "ONLINE_CONTINUOUS_UPDATE",
          "ONLINE_NO_PENDING_UPDATE",
          "ONLINE_PIPELINE_FAILED",
          "ONLINE_TRIGGERED_UPDATE",
          "ONLINE_UPDATING_PIPELINE_RESOURCES",
          "PROVISIONING",
          "PROVISIONING_INITIAL_SNAPSHOT",
          "PROVISIONING_PIPELINE_RESOURCES"
        ],
        "description": "The state of an online table."
      },
      "OptionSpecOauthStage": {
        "type": "string",
        "enum": [
          "BEFORE_ACCESS_TOKEN",
          "BEFORE_AUTHORIZATION_CODE"
        ],
        "description": "During the OAuth flow, specifies which stage the option should be displayed in the UI.\nOAUTH_STAGE_UNSPECIFIED is the default value for options unrelated to the OAuth flow.\nBEFORE_AUTHORIZATION_CODE corresponds to options necessary to initiate the OAuth process.\nBEFORE_ACCESS_TOKEN corresponds to options that are necessary to create a foreign connection,\nbut that should be displayed after the authorization code has already been received."
      },
      "OptionSpecOptionType": {
        "type": "string",
        "enum": [
          "OPTION_BIGINT",
          "OPTION_BOOLEAN",
          "OPTION_ENUM",
          "OPTION_MULTILINE_STRING",
          "OPTION_NUMBER",
          "OPTION_SERVICE_CREDENTIAL",
          "OPTION_STRING"
        ],
        "description": "Type of the option, we purposely follow JavaScript types so that the UI can map the options to\nJS types. https://www.w3schools.com/js/js_datatypes.asp Enum is a special case that it's just\nstring with selections."
      },
      "PathOperation": {
        "type": "string",
        "enum": [
          "PATH_CREATE_TABLE",
          "PATH_READ",
          "PATH_READ_WRITE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PolicyType": {
        "type": "string",
        "enum": [
          "POLICY_TYPE_COLUMN_MASK",
          "POLICY_TYPE_ROW_FILTER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PrincipalType": {
        "type": "string",
        "enum": [
          "GROUP_PRINCIPAL",
          "SERVICE_PRINCIPAL",
          "USER_PRINCIPAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "Privilege": {
        "type": "string",
        "enum": [
          "ACCESS",
          "ALL_PRIVILEGES",
          "APPLY_TAG",
          "BROWSE",
          "CREATE",
          "CREATE_CATALOG",
          "CREATE_CLEAN_ROOM",
          "CREATE_CONNECTION",
          "CREATE_EXTERNAL_LOCATION",
          "CREATE_EXTERNAL_TABLE",
          "CREATE_EXTERNAL_VOLUME",
          "CREATE_FOREIGN_CATALOG",
          "CREATE_FOREIGN_SECURABLE",
          "CREATE_FUNCTION",
          "CREATE_MANAGED_STORAGE",
          "CREATE_MATERIALIZED_VIEW",
          "CREATE_MODEL",
          "CREATE_PROVIDER",
          "CREATE_RECIPIENT",
          "CREATE_SCHEMA",
          "CREATE_SERVICE_CREDENTIAL",
          "CREATE_SHARE",
          "CREATE_STORAGE_CREDENTIAL",
          "CREATE_TABLE",
          "CREATE_VIEW",
          "CREATE_VOLUME",
          "EXECUTE",
          "EXECUTE_CLEAN_ROOM_TASK",
          "EXTERNAL_USE_SCHEMA",
          "MANAGE",
          "MANAGE_ALLOWLIST",
          "MODIFY",
          "MODIFY_CLEAN_ROOM",
          "READ_FILES",
          "READ_PRIVATE_FILES",
          "READ_VOLUME",
          "REFRESH",
          "SELECT",
          "SET_SHARE_PERMISSION",
          "USAGE",
          "USE_CATALOG",
          "USE_CONNECTION",
          "USE_MARKETPLACE_ASSETS",
          "USE_PROVIDER",
          "USE_RECIPIENT",
          "USE_SCHEMA",
          "USE_SHARE",
          "WRITE_FILES",
          "WRITE_PRIVATE_FILES",
          "WRITE_VOLUME"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ProvisioningInfoState": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "DEGRADED",
          "DELETING",
          "FAILED",
          "PROVISIONING",
          "UPDATING"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SecurableKind": {
        "type": "string",
        "enum": [
          "TABLE_DB_STORAGE",
          "TABLE_DELTA",
          "TABLE_DELTASHARING",
          "TABLE_DELTASHARING_MUTABLE",
          "TABLE_DELTASHARING_OPEN_DIR_BASED",
          "TABLE_DELTA_EXTERNAL",
          "TABLE_DELTA_ICEBERG_DELTASHARING",
          "TABLE_DELTA_ICEBERG_MANAGED",
          "TABLE_DELTA_UNIFORM_HUDI_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_DELTASHARING",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_HIVE_METASTORE_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_HIVE_METASTORE_MANAGED",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_SNOWFLAKE",
          "TABLE_EXTERNAL",
          "TABLE_FEATURE_STORE",
          "TABLE_FEATURE_STORE_EXTERNAL",
          "TABLE_FOREIGN_BIGQUERY",
          "TABLE_FOREIGN_DATABRICKS",
          "TABLE_FOREIGN_DELTASHARING",
          "TABLE_FOREIGN_HIVE_METASTORE",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_SHALLOW_CLONE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_SHALLOW_CLONE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_VIEW",
          "TABLE_FOREIGN_HIVE_METASTORE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_SHALLOW_CLONE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_SHALLOW_CLONE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_VIEW",
          "TABLE_FOREIGN_MONGODB",
          "TABLE_FOREIGN_MYSQL",
          "TABLE_FOREIGN_NETSUITE",
          "TABLE_FOREIGN_ORACLE",
          "TABLE_FOREIGN_POSTGRESQL",
          "TABLE_FOREIGN_REDSHIFT",
          "TABLE_FOREIGN_SALESFORCE",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD_FILE_SHARING",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD_FILE_SHARING_VIEW",
          "TABLE_FOREIGN_SNOWFLAKE",
          "TABLE_FOREIGN_SQLDW",
          "TABLE_FOREIGN_SQLSERVER",
          "TABLE_FOREIGN_TERADATA",
          "TABLE_FOREIGN_WORKDAY_RAAS",
          "TABLE_ICEBERG_UNIFORM_MANAGED",
          "TABLE_INTERNAL",
          "TABLE_MANAGED_POSTGRESQL",
          "TABLE_MATERIALIZED_VIEW",
          "TABLE_MATERIALIZED_VIEW_DELTASHARING",
          "TABLE_METRIC_VIEW",
          "TABLE_METRIC_VIEW_DELTASHARING",
          "TABLE_ONLINE_VECTOR_INDEX_DIRECT",
          "TABLE_ONLINE_VECTOR_INDEX_REPLICA",
          "TABLE_ONLINE_VIEW",
          "TABLE_STANDARD",
          "TABLE_STREAMING_LIVE_TABLE",
          "TABLE_STREAMING_LIVE_TABLE_DELTASHARING",
          "TABLE_SYSTEM",
          "TABLE_SYSTEM_DELTASHARING",
          "TABLE_VIEW",
          "TABLE_VIEW_DELTASHARING"
        ],
        "description": "Latest kind: CONNECTION_OKTA_SYSTEM_LOGS_SSWS_TOKEN = 295; Next id: 296"
      },
      "SecurableType": {
        "type": "string",
        "enum": [
          "CATALOG",
          "CLEAN_ROOM",
          "CONNECTION",
          "CREDENTIAL",
          "EXTERNAL_LOCATION",
          "EXTERNAL_METADATA",
          "FUNCTION",
          "METASTORE",
          "PIPELINE",
          "PROVIDER",
          "RECIPIENT",
          "SCHEMA",
          "SHARE",
          "STAGING_TABLE",
          "STORAGE_CREDENTIAL",
          "TABLE",
          "VOLUME"
        ],
        "description": "The type of Unity Catalog securable."
      },
      "SpecialDestination": {
        "type": "string",
        "enum": [
          "SPECIAL_DESTINATION_CATALOG_OWNER",
          "SPECIAL_DESTINATION_CONNECTION_OWNER",
          "SPECIAL_DESTINATION_CREDENTIAL_OWNER",
          "SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER",
          "SPECIAL_DESTINATION_METASTORE_OWNER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SseEncryptionDetailsAlgorithm": {
        "type": "string",
        "enum": [
          "AWS_SSE_KMS",
          "AWS_SSE_S3"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SystemType": {
        "type": "string",
        "enum": [
          "AMAZON_REDSHIFT",
          "AZURE_SYNAPSE",
          "CONFLUENT",
          "DATABRICKS",
          "GOOGLE_BIGQUERY",
          "KAFKA",
          "LOOKER",
          "MICROSOFT_FABRIC",
          "MICROSOFT_SQL_SERVER",
          "MONGODB",
          "MYSQL",
          "ORACLE",
          "OTHER",
          "POSTGRESQL",
          "POWER_BI",
          "SALESFORCE",
          "SAP",
          "SERVICENOW",
          "SNOWFLAKE",
          "STREAM_NATIVE",
          "TABLEAU",
          "TERADATA",
          "WORKDAY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "TableOperation": {
        "type": "string",
        "enum": [
          "READ",
          "READ_WRITE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "TableType": {
        "type": "string",
        "enum": [
          "EXTERNAL",
          "EXTERNAL_SHALLOW_CLONE",
          "FOREIGN",
          "MANAGED",
          "MANAGED_SHALLOW_CLONE",
          "MATERIALIZED_VIEW",
          "METRIC_VIEW",
          "STREAMING_TABLE",
          "VIEW"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ValidateCredentialResult": {
        "type": "string",
        "enum": [
          "FAIL",
          "PASS",
          "SKIP"
        ],
        "description": "A enum represents the result of the file operation"
      },
      "ValidationResultOperation": {
        "type": "string",
        "enum": [
          "DELETE",
          "LIST",
          "PATH_EXISTS",
          "READ",
          "WRITE"
        ],
        "description": "A enum represents the file operation performed on the external location with the storage\ncredential"
      },
      "ValidationResultResult": {
        "type": "string",
        "enum": [
          "FAIL",
          "PASS",
          "SKIP"
        ],
        "description": "A enum represents the result of the file operation"
      },
      "VolumeType": {
        "type": "string",
        "enum": [
          "EXTERNAL",
          "MANAGED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "WorkspaceBindingBindingType": {
        "type": "string",
        "enum": [
          "BINDING_TYPE_READ_ONLY",
          "BINDING_TYPE_READ_WRITE"
        ],
        "description": "Using `BINDING_TYPE_` prefix here to avoid conflict with `TableOperation` enum in\n`credentials_common.proto`."
      }
    }
  }
}