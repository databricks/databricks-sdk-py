{
  "openapi": "3.0.0",
  "info": {
    "title": "Databricks Files API (workspace)",
    "description": "OpenAPI specification for the Databricks files service (workspace-level APIs), generated from the Databricks Python SDK.",
    "version": "0.1.0"
  },
  "servers": [
    {
      "url": "https://{workspace}.cloud.databricks.com",
      "description": "Databricks workspace",
      "variables": {
        "workspace": {
          "default": "your-workspace",
          "description": "Your Databricks workspace name"
        }
      }
    }
  ],
  "paths": {
    "/api/2.0/dbfs/add-block": {
      "post": {
        "operationId": "add_block",
        "summary": "Appends a block of data to the stream specified by the input handle. If the handle does not exist,",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Appends a block of data to the stream specified by the input handle. If the handle does not exist,\nthis call will throw an exception with ``RESOURCE_DOES_NOT_EXIST``.\n\nIf the block of data exceeds 1 MB, this call will throw an exception with ``MAX_BLOCK_SIZE_EXCEEDED``.\n\n:param handle: int\n  The handle on an open stream.\n:param data: str\n  The base64-encoded data to append to the stream. This has a limit of 1 MB.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "handle": {
                    "type": "integer",
                    "description": "The handle on an open stream."
                  },
                  "data": {
                    "type": "string",
                    "description": "The base64-encoded data to append to the stream. This has a limit of 1 MB."
                  }
                },
                "required": [
                  "handle",
                  "data"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/close": {
      "post": {
        "operationId": "close",
        "summary": "Closes the stream specified by the input handle. If the handle does not exist, this call throws an",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Closes the stream specified by the input handle. If the handle does not exist, this call throws an\nexception with ``RESOURCE_DOES_NOT_EXIST``.\n\n:param handle: int\n  The handle on an open stream.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "handle": {
                    "type": "integer",
                    "description": "The handle on an open stream."
                  }
                },
                "required": [
                  "handle"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/create": {
      "post": {
        "operationId": "create",
        "summary": "Opens a stream to write to a file and returns a handle to this stream. There is a 10 minute idle",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Opens a stream to write to a file and returns a handle to this stream. There is a 10 minute idle\ntimeout on this handle. If a file or directory already exists on the given path and __overwrite__ is\nset to false, this call will throw an exception with ``RESOURCE_ALREADY_EXISTS``.\n\nA typical workflow for file upload would be:\n\n1. Issue a ``create`` call and get a handle. 2. Issue one or more ``add-block`` calls with the handle\nyou have. 3. Issue a ``close`` call with the handle you have.\n\n:param path: str\n  The path of the new file. The path should be the absolute DBFS path.\n:param overwrite: bool (optional)\n  The flag that specifies whether to overwrite existing file/files.\n\n:returns: :class:`CreateResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The path of the new file. The path should be the absolute DBFS path."
                  },
                  "overwrite": {
                    "type": "string",
                    "description": "The flag that specifies whether to overwrite existing file/files."
                  }
                },
                "required": [
                  "path"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/delete": {
      "post": {
        "operationId": "delete",
        "summary": "Delete the file or directory (optionally recursively delete all files in the directory). This call",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Delete the file or directory (optionally recursively delete all files in the directory). This call\nthrows an exception with `IO_ERROR` if the path is a non-empty directory and `recursive` is set to\n`false` or on other similar errors.\n\nWhen you delete a large number of files, the delete operation is done in increments. The call returns\na response after approximately 45 seconds with an error message (503 Service Unavailable) asking you\nto re-invoke the delete operation until the directory structure is fully deleted.\n\nFor operations that delete more than 10K files, we discourage using the DBFS REST API, but advise you\nto perform such operations in the context of a cluster, using the [File system utility\n(dbutils.fs)](/dev-tools/databricks-utils.html#dbutils-fs). `dbutils.fs` covers the functional scope\nof the DBFS REST API, but from notebooks. Running such operations using notebooks provides better\ncontrol and manageability, such as selective deletes, and the possibility to automate periodic delete\njobs.\n\n:param path: str\n  The path of the file or directory to delete. The path should be the absolute DBFS path.\n:param recursive: bool (optional)\n  Whether or not to recursively delete the directory's contents. Deleting empty directories can be\n  done without providing the recursive flag.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The path of the file or directory to delete. The path should be the absolute DBFS path."
                  },
                  "recursive": {
                    "type": "string",
                    "description": "Whether or not to recursively delete the directory's contents. Deleting empty directories can be done without providing the recursive flag."
                  }
                },
                "required": [
                  "path"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/get-status": {
      "get": {
        "operationId": "get_status",
        "summary": "Gets the file information for a file or directory. If the file or directory does not exist, this call",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Gets the file information for a file or directory. If the file or directory does not exist, this call\nthrows an exception with `RESOURCE_DOES_NOT_EXIST`.\n\n:param path: str\n  The path of the file or directory. The path should be the absolute DBFS path.\n\n:returns: :class:`FileInfo`",
        "parameters": [
          {
            "name": "path",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The path of the file or directory. The path should be the absolute DBFS path."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/list": {
      "get": {
        "operationId": "list",
        "summary": "List the contents of a directory, or details of the file. If the file or directory does not exist,",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "List the contents of a directory, or details of the file. If the file or directory does not exist,\nthis call throws an exception with `RESOURCE_DOES_NOT_EXIST`.\n\nWhen calling list on a large directory, the list operation will time out after approximately 60\nseconds. We strongly recommend using list only on directories containing less than 10K files and\ndiscourage using the DBFS REST API for operations that list more than 10K files. Instead, we recommend\nthat you perform such operations in the context of a cluster, using the [File system utility\n(dbutils.fs)](/dev-tools/databricks-utils.html#dbutils-fs), which provides the same functionality\nwithout timing out.\n\n:param path: str\n  The path of the file or directory. The path should be the absolute DBFS path.\n\n:returns: Iterator over :class:`FileInfo`",
        "parameters": [
          {
            "name": "path",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The path of the file or directory. The path should be the absolute DBFS path."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Iterator[FileInfo]"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/mkdirs": {
      "post": {
        "operationId": "mkdirs",
        "summary": "Creates the given directory and necessary parent directories if they do not exist. If a file (not a",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Creates the given directory and necessary parent directories if they do not exist. If a file (not a\ndirectory) exists at any prefix of the input path, this call throws an exception with\n`RESOURCE_ALREADY_EXISTS`. **Note**: If this operation fails, it might have succeeded in creating some\nof the necessary parent directories.\n\n:param path: str\n  The path of the new directory. The path should be the absolute DBFS path.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The path of the new directory. The path should be the absolute DBFS path."
                  }
                },
                "required": [
                  "path"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/move": {
      "post": {
        "operationId": "move",
        "summary": "Moves a file from one location to another location within DBFS. If the source file does not exist,",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Moves a file from one location to another location within DBFS. If the source file does not exist,\nthis call throws an exception with `RESOURCE_DOES_NOT_EXIST`. If a file already exists in the\ndestination path, this call throws an exception with `RESOURCE_ALREADY_EXISTS`. If the given source\npath is a directory, this call always recursively moves all files.\n\n:param source_path: str\n  The source path of the file or directory. The path should be the absolute DBFS path.\n:param destination_path: str\n  The destination path of the file or directory. The path should be the absolute DBFS path.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "source_path": {
                    "type": "string",
                    "description": "The source path of the file or directory. The path should be the absolute DBFS path."
                  },
                  "destination_path": {
                    "type": "string",
                    "description": "The destination path of the file or directory. The path should be the absolute DBFS path."
                  }
                },
                "required": [
                  "source_path",
                  "destination_path"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/put": {
      "post": {
        "operationId": "put",
        "summary": "Uploads a file through the use of multipart form post. It is mainly used for streaming uploads, but",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Uploads a file through the use of multipart form post. It is mainly used for streaming uploads, but\ncan also be used as a convenient single call for data upload.\n\nAlternatively you can pass contents as base64 string.\n\nThe amount of data that can be passed (when not streaming) using the __contents__ parameter is limited\nto 1 MB. `MAX_BLOCK_SIZE_EXCEEDED` will be thrown if this limit is exceeded.\n\nIf you want to upload large files, use the streaming upload. For details, see :method:dbfs/create,\n:method:dbfs/addBlock, :method:dbfs/close.\n\n:param path: str\n  The path of the new file. The path should be the absolute DBFS path.\n:param contents: str (optional)\n  This parameter might be absent, and instead a posted file will be used.\n:param overwrite: bool (optional)\n  The flag that specifies whether to overwrite existing file/files.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The path of the new file. The path should be the absolute DBFS path."
                  },
                  "contents": {
                    "type": "string",
                    "description": "This parameter might be absent, and instead a posted file will be used."
                  },
                  "overwrite": {
                    "type": "string",
                    "description": "The flag that specifies whether to overwrite existing file/files."
                  }
                },
                "required": [
                  "path"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/dbfs/read": {
      "get": {
        "operationId": "read",
        "summary": "Returns the contents of a file. If the file does not exist, this call throws an exception with",
        "tags": [
          "files",
          "dbfs"
        ],
        "description": "Returns the contents of a file. If the file does not exist, this call throws an exception with\n`RESOURCE_DOES_NOT_EXIST`. If the path is a directory, the read length is negative, or if the offset\nis negative, this call throws an exception with `INVALID_PARAMETER_VALUE`. If the read length exceeds\n1 MB, this call throws an exception with `MAX_READ_SIZE_EXCEEDED`.\n\nIf `offset + length` exceeds the number of bytes in a file, it reads the contents until the end of\nfile.\n\n:param path: str\n  The path of the file to read. The path should be the absolute DBFS path.\n:param length: int (optional)\n  The number of bytes to read starting from the offset. This has a limit of 1 MB, and a default value\n  of 0.5 MB.\n:param offset: int (optional)\n  The offset to read from in bytes.\n\n:returns: :class:`ReadResponse`",
        "parameters": [
          {
            "name": "path",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The path of the file to read. The path should be the absolute DBFS path."
          },
          {
            "name": "length",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The number of bytes to read starting from the offset. This has a limit of 1 MB, and a default value of 0.5 MB."
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The offset to read from in bytes."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/fs/directories{directory_path}": {
      "put": {
        "operationId": "create_directory",
        "summary": "Creates an empty directory. If necessary, also creates any parent directories of the new, empty",
        "tags": [
          "files"
        ],
        "description": "Creates an empty directory. If necessary, also creates any parent directories of the new, empty\ndirectory (like the shell command `mkdir -p`). If called on an existing directory, returns a success\nresponse; this method is idempotent (it will succeed if the directory already exists).\n\n:param directory_path: str\n  The absolute path of a directory.",
        "parameters": [
          {
            "name": "directory_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of a directory."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "delete_directory",
        "summary": "Deletes an empty directory.",
        "tags": [
          "files"
        ],
        "description": "Deletes an empty directory.\n\nTo delete a non-empty directory, first delete all of its contents. This can be done by listing the\ndirectory contents and deleting each file and subdirectory recursively.\n\n:param directory_path: str\n  The absolute path of a directory.",
        "parameters": [
          {
            "name": "directory_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of a directory."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "head": {
        "operationId": "get_directory_metadata",
        "summary": "Get the metadata of a directory. The response HTTP headers contain the metadata. There is no response",
        "tags": [
          "files"
        ],
        "description": "Get the metadata of a directory. The response HTTP headers contain the metadata. There is no response\nbody.\n\nThis method is useful to check if a directory exists and the caller has access to it.\n\nIf you wish to ensure the directory exists, you can instead use `PUT`, which will create the directory\nif it does not exist, and is idempotent (it will succeed if the directory already exists).\n\n:param directory_path: str\n  The absolute path of a directory.",
        "parameters": [
          {
            "name": "directory_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of a directory."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "list_directory_contents",
        "summary": "Returns the contents of a directory. If there is no directory at the specified path, the API returns a",
        "tags": [
          "files"
        ],
        "description": "Returns the contents of a directory. If there is no directory at the specified path, the API returns a\nHTTP 404 error.\n\n:param directory_path: str\n  The absolute path of a directory.\n:param page_size: int (optional)\n  The maximum number of directory entries to return. The response may contain fewer entries. If the\n  response contains a `next_page_token`, there may be more entries, even if fewer than `page_size`\n  entries are in the response.\n\n  We recommend not to set this value unless you are intentionally listing less than the complete\n  directory contents.\n\n  If unspecified, at most 1000 directory entries will be returned. The maximum value is 1000. Values\n  above 1000 will be coerced to 1000.\n:param page_token: str (optional)\n  An opaque page token which was the `next_page_token` in the response of the previous request to list\n  the contents of this directory. Provide this token to retrieve the next page of directory entries.\n  When providing a `page_token`, all other parameters provided to the request must match the previous\n  request. To list all of the entries in a directory, it is necessary to continue requesting pages of\n  entries until the response contains no `next_page_token`. Note that the number of entries returned\n  must not be used to determine when the listing is complete.\n\n:returns: Iterator over :class:`DirectoryEntry`",
        "parameters": [
          {
            "name": "directory_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of a directory."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of directory entries to return. The response may contain fewer entries. If the response contains a `next_page_token`, there may be more entries, even if fewer than `page_size` entries are in the response. We recommend not to set this value unless you are intentionally listing less than the complete directory contents. If unspecified, at most 1000 directory entries will be returned. The maximum value is 1000. Values above 1000 will be coerced to 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "An opaque page token which was the `next_page_token` in the response of the previous request to list the contents of this directory. Provide this token to retrieve the next page of directory entries. When providing a `page_token`, all other parameters provided to the request must match the previous request. To list all of the entries in a directory, it is necessary to continue requesting pages of entries until the response contains no `next_page_token`. Note that the number of entries returned must not be used to determine when the listing is complete."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Iterator[DirectoryEntry]"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/fs/files{file_path}": {
      "delete": {
        "operationId": "delete",
        "summary": "Deletes a file. If the request is successful, there is no response body.",
        "tags": [
          "files"
        ],
        "description": "Deletes a file. If the request is successful, there is no response body.\n\n:param file_path: str\n  The absolute path of the file.",
        "parameters": [
          {
            "name": "file_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of the file."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "download",
        "summary": "Downloads a file. The file contents are the response body. This is a standard HTTP file download, not",
        "tags": [
          "files"
        ],
        "description": "Downloads a file. The file contents are the response body. This is a standard HTTP file download, not\na JSON RPC. It supports the Range and If-Unmodified-Since HTTP headers.\n\n:param file_path: str\n  The absolute path of the file.\n\n:returns: :class:`DownloadResponse`",
        "parameters": [
          {
            "name": "file_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of the file."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DownloadResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "head": {
        "operationId": "get_metadata",
        "summary": "Get the metadata of a file. The response HTTP headers contain the metadata. There is no response body.",
        "tags": [
          "files"
        ],
        "description": "Get the metadata of a file. The response HTTP headers contain the metadata. There is no response body.\n\n:param file_path: str\n  The absolute path of the file.\n\n:returns: :class:`GetMetadataResponse`",
        "parameters": [
          {
            "name": "file_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of the file."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetMetadataResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "upload",
        "summary": "Uploads a file of up to 5 GiB. The file contents should be sent as the request body as raw bytes (an",
        "tags": [
          "files"
        ],
        "description": "Uploads a file of up to 5 GiB. The file contents should be sent as the request body as raw bytes (an\noctet stream); do not encode or otherwise modify the bytes before sending. The contents of the\nresulting file will be exactly the bytes sent in the request body. If the request is successful, there\nis no response body.\n\n:param file_path: str\n  The absolute path of the file.\n:param contents: BinaryIO\n:param overwrite: bool (optional)\n  If true or unspecified, an existing file will be overwritten. If false, an error will be returned if\n  the path points to an existing file.",
        "parameters": [
          {
            "name": "file_path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The absolute path of the file."
          },
          {
            "name": "overwrite",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "contents": {
                    "type": "string",
                    "description": ":param overwrite: bool (optional) If true or unspecified, an existing file will be overwritten. If false, an error will be returned if the path points to an existing file."
                  }
                },
                "required": [
                  "contents"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AddBlockResponse": {
        "type": "object",
        "properties": {}
      },
      "CloseResponse": {
        "type": "object",
        "properties": {}
      },
      "CreateResponse": {
        "type": "object",
        "properties": {
          "handle": {
            "type": "integer"
          }
        }
      },
      "DeleteResponse": {
        "type": "object",
        "properties": {}
      },
      "DirectoryEntry": {
        "type": "object",
        "properties": {
          "file_size": {
            "type": "integer"
          },
          "is_directory": {
            "type": "boolean",
            "description": "True if the path is a directory."
          },
          "last_modified": {
            "type": "integer",
            "description": "Last modification time of given file in milliseconds since unix epoch."
          },
          "name": {
            "type": "string",
            "description": "The name of the file or directory. This is the last component of the path."
          },
          "path": {
            "type": "string",
            "description": "The absolute path of the file or directory."
          }
        }
      },
      "DownloadResponse": {
        "type": "object",
        "properties": {
          "content_length": {
            "type": "integer"
          },
          "content_type": {
            "type": "string"
          },
          "contents": {
            "$ref": "#/components/schemas/BinaryIO"
          },
          "last_modified": {
            "type": "string",
            "description": "The last modified time of the file in HTTP-date (RFC 7231) format."
          }
        }
      },
      "FileInfo": {
        "type": "object",
        "properties": {
          "file_size": {
            "type": "integer"
          },
          "is_dir": {
            "type": "boolean",
            "description": "True if the path is a directory."
          },
          "modification_time": {
            "type": "integer",
            "description": "Last modification time of given file in milliseconds since epoch."
          },
          "path": {
            "type": "string",
            "description": "The absolute path of the file or directory."
          }
        }
      },
      "GetMetadataResponse": {
        "type": "object",
        "properties": {
          "content_length": {
            "type": "integer"
          },
          "content_type": {
            "type": "string"
          },
          "last_modified": {
            "type": "string",
            "description": "The last modified time of the file in HTTP-date (RFC 7231) format."
          }
        }
      },
      "ListDirectoryResponse": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DirectoryEntry"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "A token, which can be sent as `page_token` to retrieve the next page."
          }
        }
      },
      "ListStatusResponse": {
        "type": "object",
        "properties": {
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            }
          }
        }
      },
      "MkDirsResponse": {
        "type": "object",
        "properties": {}
      },
      "MoveResponse": {
        "type": "object",
        "properties": {}
      },
      "PutResponse": {
        "type": "object",
        "properties": {}
      },
      "ReadResponse": {
        "type": "object",
        "properties": {
          "bytes_read": {
            "type": "integer"
          },
          "data": {
            "type": "string",
            "description": "The base64-encoded contents of the file read."
          }
        }
      }
    }
  }
}