{
  "openapi": "3.0.0",
  "info": {
    "title": "Databricks Sql API (workspace)",
    "description": "OpenAPI specification for the Databricks sql service (workspace-level APIs), generated from the Databricks Python SDK.",
    "version": "0.1.0"
  },
  "servers": [
    {
      "url": "https://{workspace}.cloud.databricks.com",
      "description": "Databricks workspace",
      "variables": {
        "workspace": {
          "default": "your-workspace",
          "description": "Your Databricks workspace name"
        }
      }
    }
  ],
  "paths": {
    "/api/2.0/sql/alerts": {
      "post": {
        "operationId": "alerts_create",
        "summary": "Creates an alert.",
        "tags": [
          "sql",
          "alerts"
        ],
        "description": "Creates an alert.\n\n:param alert: :class:`CreateAlertRequestAlert` (optional)\n:param auto_resolve_display_name: bool (optional)\n  If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the\n  alert's display name conflicts with an existing alert's display name.\n\n:returns: :class:`Alert`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "alert": {
                    "type": "string",
                    "description": ":param auto_resolve_display_name: bool (optional) If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the alert's display name conflicts with an existing alert's display name."
                  },
                  "auto_resolve_display_name": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Alert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "alerts_list",
        "summary": "Gets a list of alerts accessible to the user, ordered by creation time. **Warning:** Calling this API",
        "tags": [
          "sql",
          "alerts"
        ],
        "description": "Gets a list of alerts accessible to the user, ordered by creation time. **Warning:** Calling this API\nconcurrently 10 or more times could result in throttling, service degradation, or a temporary ban.\n\n:param page_size: int (optional)\n:param page_token: str (optional)\n\n:returns: Iterator over :class:`ListAlertsResponseAlert`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": ":param page_token: str (optional)"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAlertsResponseAlert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/alerts/{id}": {
      "delete": {
        "operationId": "alerts_delete",
        "summary": "Moves an alert to the trash. Trashed alerts immediately disappear from searches and list views, and",
        "tags": [
          "sql",
          "alerts"
        ],
        "description": "Moves an alert to the trash. Trashed alerts immediately disappear from searches and list views, and\ncan no longer trigger. You can restore a trashed alert through the UI. A trashed alert is permanently\ndeleted after 30 days.\n\n:param id: str",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "alerts_get",
        "summary": "Gets an alert.",
        "tags": [
          "sql",
          "alerts"
        ],
        "description": "Gets an alert.\n\n:param id: str\n\n:returns: :class:`Alert`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`Alert`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Alert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "alerts_update",
        "summary": "Updates an alert.",
        "tags": [
          "sql",
          "alerts"
        ],
        "description": "Updates an alert.\n\n:param id: str\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n:param alert: :class:`UpdateAlertRequestAlert` (optional)\n:param auto_resolve_display_name: bool (optional)\n  If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the\n  alert's display name conflicts with an existing alert's display name.\n\n:returns: :class:`Alert`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "update_mask": {
                    "type": "string"
                  },
                  "alert": {
                    "type": "string",
                    "description": ":param auto_resolve_display_name: bool (optional) If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the alert's display name conflicts with an existing alert's display name."
                  },
                  "auto_resolve_display_name": {
                    "type": "string"
                  }
                },
                "required": [
                  "update_mask"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Alert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/alerts": {
      "post": {
        "operationId": "alerts_legacy_create",
        "summary": "Creates an alert. An alert is a Databricks SQL object that periodically runs a query, evaluates a",
        "tags": [
          "sql",
          "alerts_legacy"
        ],
        "description": "Creates an alert. An alert is a Databricks SQL object that periodically runs a query, evaluates a\ncondition of its result, and notifies users or notification destinations if the condition was met.\n\n**Warning**: This API is deprecated. Please use :method:alerts/create instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param name: str\n  Name of the alert.\n:param options: :class:`AlertOptions`\n  Alert configuration options.\n:param query_id: str\n  Query ID.\n:param parent: str (optional)\n  The identifier of the workspace folder containing the object.\n:param rearm: int (optional)\n  Number of seconds after being triggered before the alert rearms itself and can be triggered again.\n  If `null`, alert will never be triggered again.\n\n:returns: :class:`LegacyAlert`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the alert."
                  },
                  "options": {
                    "type": "string",
                    "description": "Alert configuration options."
                  },
                  "query_id": {
                    "type": "string",
                    "description": "Query ID."
                  },
                  "parent": {
                    "type": "string",
                    "description": "The identifier of the workspace folder containing the object."
                  },
                  "rearm": {
                    "type": "string",
                    "description": "Number of seconds after being triggered before the alert rearms itself and can be triggered again. If `null`, alert will never be triggered again."
                  }
                },
                "required": [
                  "name",
                  "options",
                  "query_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyAlert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "alerts_legacy_list",
        "summary": "Gets a list of alerts.",
        "tags": [
          "sql",
          "alerts_legacy"
        ],
        "description": "Gets a list of alerts.\n\n**Warning**: This API is deprecated. Please use :method:alerts/list instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n\n:returns: Iterator over :class:`LegacyAlert`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyAlert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/alerts/{alert_id}": {
      "delete": {
        "operationId": "alerts_legacy_delete",
        "summary": "Deletes an alert. Deleted alerts are no longer accessible and cannot be restored. **Note**: Unlike",
        "tags": [
          "sql",
          "alerts_legacy"
        ],
        "description": "Deletes an alert. Deleted alerts are no longer accessible and cannot be restored. **Note**: Unlike\nqueries and dashboards, alerts cannot be moved to the trash.\n\n**Warning**: This API is deprecated. Please use :method:alerts/delete instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param alert_id: str",
        "parameters": [
          {
            "name": "alert_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "alerts_legacy_get",
        "summary": "Gets an alert.",
        "tags": [
          "sql",
          "alerts_legacy"
        ],
        "description": "Gets an alert.\n\n**Warning**: This API is deprecated. Please use :method:alerts/get instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param alert_id: str\n\n:returns: :class:`LegacyAlert`",
        "parameters": [
          {
            "name": "alert_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`LegacyAlert`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyAlert"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "alerts_legacy_update",
        "summary": "Updates an alert.",
        "tags": [
          "sql",
          "alerts_legacy"
        ],
        "description": "Updates an alert.\n\n**Warning**: This API is deprecated. Please use :method:alerts/update instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param alert_id: str\n:param name: str\n  Name of the alert.\n:param options: :class:`AlertOptions`\n  Alert configuration options.\n:param query_id: str\n  Query ID.\n:param rearm: int (optional)\n  Number of seconds after being triggered before the alert rearms itself and can be triggered again.\n  If `null`, alert will never be triggered again.",
        "parameters": [
          {
            "name": "alert_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param name: str Name of the alert."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "options": {
                    "type": "string",
                    "description": "Alert configuration options."
                  },
                  "query_id": {
                    "type": "string",
                    "description": "Query ID."
                  },
                  "rearm": {
                    "type": "string",
                    "description": "Number of seconds after being triggered before the alert rearms itself and can be triggered again. If `null`, alert will never be triggered again."
                  }
                },
                "required": [
                  "name",
                  "options",
                  "query_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/alerts": {
      "post": {
        "operationId": "alerts_v2_create_alert",
        "summary": "Create Alert",
        "tags": [
          "sql",
          "alerts_v2"
        ],
        "description": "Create Alert\n\n:param alert: :class:`AlertV2`\n\n:returns: :class:`AlertV2`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "alert": {
                    "type": "string",
                    "description": ":returns: :class:`AlertV2`"
                  }
                },
                "required": [
                  "alert"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertV2"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "alerts_v2_list_alerts",
        "summary": "Gets a list of alerts accessible to the user, ordered by creation time.",
        "tags": [
          "sql",
          "alerts_v2"
        ],
        "description": "Gets a list of alerts accessible to the user, ordered by creation time.\n\n:param page_size: int (optional)\n:param page_token: str (optional)\n\n:returns: Iterator over :class:`AlertV2`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": ":param page_token: str (optional)"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertV2"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/alerts/{id}": {
      "get": {
        "operationId": "alerts_v2_get_alert",
        "summary": "Gets an alert.",
        "tags": [
          "sql",
          "alerts_v2"
        ],
        "description": "Gets an alert.\n\n:param id: str\n\n:returns: :class:`AlertV2`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`AlertV2`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertV2"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "operationId": "alerts_v2_trash_alert",
        "summary": "Moves an alert to the trash. Trashed alerts immediately disappear from list views, and can no longer",
        "tags": [
          "sql",
          "alerts_v2"
        ],
        "description": "Moves an alert to the trash. Trashed alerts immediately disappear from list views, and can no longer\ntrigger. You can restore a trashed alert through the UI. A trashed alert is permanently deleted after\n30 days.\n\n:param id: str\n:param purge: bool (optional)\n  Whether to permanently delete the alert. If not set, the alert will only be soft deleted.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param purge: bool (optional) Whether to permanently delete the alert. If not set, the alert will only be soft deleted."
          },
          {
            "name": "purge",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "alerts_v2_update_alert",
        "summary": "Update alert",
        "tags": [
          "sql",
          "alerts_v2"
        ],
        "description": "Update alert\n\n:param id: str\n  UUID identifying the alert.\n:param alert: :class:`AlertV2`\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n\n:returns: :class:`AlertV2`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "UUID identifying the alert."
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "alert": {
                    "type": "string",
                    "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
                  }
                },
                "required": [
                  "alert"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlertV2"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/widgets": {
      "post": {
        "operationId": "dashboard_widgets_create",
        "summary": "Adds a widget to a dashboard",
        "tags": [
          "sql",
          "dashboard_widgets"
        ],
        "description": "Adds a widget to a dashboard\n\n:param dashboard_id: str\n  Dashboard ID returned by :method:dashboards/create.\n:param options: :class:`WidgetOptions`\n:param width: int\n  Width of a widget\n:param text: str (optional)\n  If this is a textbox widget, the application displays this text. This field is ignored if the widget\n  contains a visualization in the `visualization` field.\n:param visualization_id: str (optional)\n  Query Vizualization ID returned by :method:queryvisualizations/create.\n\n:returns: :class:`Widget`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dashboard_id": {
                    "type": "string",
                    "description": "Dashboard ID returned by :method:dashboards/create."
                  },
                  "options": {
                    "type": "string",
                    "description": ":param width: int Width of a widget"
                  },
                  "width": {
                    "type": "integer"
                  },
                  "text": {
                    "type": "string",
                    "description": "If this is a textbox widget, the application displays this text. This field is ignored if the widget contains a visualization in the `visualization` field."
                  },
                  "visualization_id": {
                    "type": "string",
                    "description": "Query Vizualization ID returned by :method:queryvisualizations/create."
                  }
                },
                "required": [
                  "dashboard_id",
                  "options",
                  "width"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Widget"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/widgets/{id}": {
      "delete": {
        "operationId": "dashboard_widgets_delete",
        "summary": "Removes a widget from a dashboard",
        "tags": [
          "sql",
          "dashboard_widgets"
        ],
        "description": "Removes a widget from a dashboard\n\n:param id: str\n  Widget ID returned by :method:dashboardwidgets/create",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Widget ID returned by :method:dashboardwidgets/create"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "dashboard_widgets_update",
        "summary": "Updates an existing widget",
        "tags": [
          "sql",
          "dashboard_widgets"
        ],
        "description": "Updates an existing widget\n\n:param id: str\n  Widget ID returned by :method:dashboardwidgets/create\n:param dashboard_id: str\n  Dashboard ID returned by :method:dashboards/create.\n:param options: :class:`WidgetOptions`\n:param width: int\n  Width of a widget\n:param text: str (optional)\n  If this is a textbox widget, the application displays this text. This field is ignored if the widget\n  contains a visualization in the `visualization` field.\n:param visualization_id: str (optional)\n  Query Vizualization ID returned by :method:queryvisualizations/create.\n\n:returns: :class:`Widget`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Widget ID returned by :method:dashboardwidgets/create"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dashboard_id": {
                    "type": "string",
                    "description": "Dashboard ID returned by :method:dashboards/create."
                  },
                  "options": {
                    "type": "string",
                    "description": ":param width: int Width of a widget"
                  },
                  "width": {
                    "type": "integer"
                  },
                  "text": {
                    "type": "string",
                    "description": "If this is a textbox widget, the application displays this text. This field is ignored if the widget contains a visualization in the `visualization` field."
                  },
                  "visualization_id": {
                    "type": "string",
                    "description": "Query Vizualization ID returned by :method:queryvisualizations/create."
                  }
                },
                "required": [
                  "dashboard_id",
                  "options",
                  "width"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Widget"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/dashboards/{dashboard_id}": {
      "delete": {
        "operationId": "dashboards_delete",
        "summary": "Moves a dashboard to the trash. Trashed dashboards do not appear in list views or searches, and cannot",
        "tags": [
          "sql",
          "dashboards"
        ],
        "description": "Moves a dashboard to the trash. Trashed dashboards do not appear in list views or searches, and cannot\nbe shared.\n\n:param dashboard_id: str",
        "parameters": [
          {
            "name": "dashboard_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "dashboards_get",
        "summary": "Returns a JSON representation of a dashboard object, including its visualization and query objects.",
        "tags": [
          "sql",
          "dashboards"
        ],
        "description": "Returns a JSON representation of a dashboard object, including its visualization and query objects.\n\n:param dashboard_id: str\n\n:returns: :class:`Dashboard`",
        "parameters": [
          {
            "name": "dashboard_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`Dashboard`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dashboard"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "dashboards_update",
        "summary": "Modify this dashboard definition. This operation only affects attributes of the dashboard object. It",
        "tags": [
          "sql",
          "dashboards"
        ],
        "description": "Modify this dashboard definition. This operation only affects attributes of the dashboard object. It\ndoes not add, modify, or remove widgets.\n\n**Note**: You cannot undo this operation.\n\n:param dashboard_id: str\n:param name: str (optional)\n  The title of this dashboard that appears in list views and at the top of the dashboard page.\n:param run_as_role: :class:`RunAsRole` (optional)\n  Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as\n  viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)\n:param tags: List[str] (optional)\n\n:returns: :class:`Dashboard`",
        "parameters": [
          {
            "name": "dashboard_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param name: str (optional) The title of this dashboard that appears in list views and at the top of the dashboard page."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "run_as_role": {
                    "type": "string",
                    "description": "Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)"
                  },
                  "tags": {
                    "type": "string",
                    "description": ":returns: :class:`Dashboard`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dashboard"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/dashboards": {
      "get": {
        "operationId": "dashboards_list",
        "summary": "Fetch a paginated list of dashboard objects.",
        "tags": [
          "sql",
          "dashboards"
        ],
        "description": "Fetch a paginated list of dashboard objects.\n\n**Warning**: Calling this API concurrently 10 or more times could result in throttling, service\ndegradation, or a temporary ban.\n\n:param order: :class:`ListOrder` (optional)\n  Name of dashboard attribute to order by.\n:param page: int (optional)\n  Page number to retrieve.\n:param page_size: int (optional)\n  Number of dashboards to return per page.\n:param q: str (optional)\n  Full text search term.\n\n:returns: Iterator over :class:`Dashboard`",
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Name of dashboard attribute to order by."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Page number to retrieve."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Number of dashboards to return per page."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Full text search term."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Dashboard"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/dashboards/trash/{dashboard_id}": {
      "post": {
        "operationId": "dashboards_restore",
        "summary": "A restored dashboard appears in list views and searches and can be shared.",
        "tags": [
          "sql",
          "dashboards"
        ],
        "description": "A restored dashboard appears in list views and searches and can be shared.\n\n:param dashboard_id: str",
        "parameters": [
          {
            "name": "dashboard_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/data_sources": {
      "get": {
        "operationId": "data_sources_list",
        "summary": "Retrieves a full list of SQL warehouses available in this workspace. All fields that appear in this",
        "tags": [
          "sql",
          "data_sources"
        ],
        "description": "Retrieves a full list of SQL warehouses available in this workspace. All fields that appear in this\nAPI response are enumerated for clarity. However, you need only a SQL warehouse's `id` to create new\nqueries against it.\n\n**Warning**: This API is deprecated. Please use :method:warehouses/list instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n\n:returns: Iterator over :class:`DataSource`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataSource"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/permissions/{object_type.value}/{object_id}": {
      "get": {
        "operationId": "dbsql_permissions_get",
        "summary": "Gets a JSON representation of the access control list (ACL) for a specified object.",
        "tags": [
          "sql",
          "dbsql_permissions"
        ],
        "description": "Gets a JSON representation of the access control list (ACL) for a specified object.\n\n**Warning**: This API is deprecated. Please use :method:workspace/getpermissions instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param object_type: :class:`ObjectTypePlural`\n  The type of object permissions to check.\n:param object_id: str\n  Object ID. An ACL is returned for the object with this UUID.\n\n:returns: :class:`GetResponse`",
        "parameters": [
          {
            "name": "object_type.value",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "object_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Object ID. An ACL is returned for the object with this UUID."
          },
          {
            "name": "object_type",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The type of object permissions to check."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "dbsql_permissions_set",
        "summary": "Sets the access control list (ACL) for a specified object. This operation will complete rewrite the",
        "tags": [
          "sql",
          "dbsql_permissions"
        ],
        "description": "Sets the access control list (ACL) for a specified object. This operation will complete rewrite the\nACL.\n\n**Warning**: This API is deprecated. Please use :method:workspace/setpermissions instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param object_type: :class:`ObjectTypePlural`\n  The type of object permission to set.\n:param object_id: str\n  Object ID. The ACL for the object with this UUID is overwritten by this request's POST content.\n:param access_control_list: List[:class:`AccessControl`] (optional)\n\n:returns: :class:`SetResponse`",
        "parameters": [
          {
            "name": "object_type.value",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "object_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Object ID. The ACL for the object with this UUID is overwritten by this request's POST content."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "object_type": {
                    "type": "string",
                    "description": "The type of object permission to set."
                  },
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`SetResponse`"
                  }
                },
                "required": [
                  "object_type"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/permissions/{object_type.value}/{object_id}/transfer": {
      "post": {
        "operationId": "dbsql_permissions_transfer_ownership",
        "summary": "Transfers ownership of a dashboard, query, or alert to an active user. Requires an admin API key.",
        "tags": [
          "sql",
          "dbsql_permissions"
        ],
        "description": "Transfers ownership of a dashboard, query, or alert to an active user. Requires an admin API key.\n\n**Warning**: This API is deprecated. For queries and alerts, please use :method:queries/update and\n:method:alerts/update respectively instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param object_type: :class:`OwnableObjectType`\n  The type of object on which to change ownership.\n:param object_id: :class:`TransferOwnershipObjectId`\n  The ID of the object on which to change ownership.\n:param new_owner: str (optional)\n  Email address for the new owner, who must exist in the workspace.\n\n:returns: :class:`Success`",
        "parameters": [
          {
            "name": "object_type.value",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "object_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The ID of the object on which to change ownership."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "object_type": {
                    "type": "string",
                    "description": "The type of object on which to change ownership."
                  },
                  "new_owner": {
                    "type": "string",
                    "description": "Email address for the new owner, who must exist in the workspace."
                  }
                },
                "required": [
                  "object_type"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Success"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/queries": {
      "post": {
        "operationId": "queries_create",
        "summary": "Creates a query.",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Creates a query.\n\n:param auto_resolve_display_name: bool (optional)\n  If true, automatically resolve query display name conflicts. Otherwise, fail the request if the\n  query's display name conflicts with an existing query's display name.\n:param query: :class:`CreateQueryRequestQuery` (optional)\n\n:returns: :class:`Query`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "auto_resolve_display_name": {
                    "type": "string",
                    "description": "If true, automatically resolve query display name conflicts. Otherwise, fail the request if the query's display name conflicts with an existing query's display name."
                  },
                  "query": {
                    "type": "string",
                    "description": ":returns: :class:`Query`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Query"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "queries_list",
        "summary": "Gets a list of queries accessible to the user, ordered by creation time. **Warning:** Calling this API",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Gets a list of queries accessible to the user, ordered by creation time. **Warning:** Calling this API\nconcurrently 10 or more times could result in throttling, service degradation, or a temporary ban.\n\n:param page_size: int (optional)\n:param page_token: str (optional)\n\n:returns: Iterator over :class:`ListQueryObjectsResponseQuery`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": ":param page_token: str (optional)"
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQueryObjectsResponseQuery"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/queries/{id}": {
      "delete": {
        "operationId": "queries_delete",
        "summary": "Moves a query to the trash. Trashed queries immediately disappear from searches and list views, and",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Moves a query to the trash. Trashed queries immediately disappear from searches and list views, and\ncannot be used for alerts. You can restore a trashed query through the UI. A trashed query is\npermanently deleted after 30 days.\n\n:param id: str",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "queries_get",
        "summary": "Gets a query.",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Gets a query.\n\n:param id: str\n\n:returns: :class:`Query`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`Query`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Query"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "queries_update",
        "summary": "Updates a query.",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Updates a query.\n\n:param id: str\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n:param auto_resolve_display_name: bool (optional)\n  If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the\n  alert's display name conflicts with an existing alert's display name.\n:param query: :class:`UpdateQueryRequestQuery` (optional)\n\n:returns: :class:`Query`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "update_mask": {
                    "type": "string"
                  },
                  "auto_resolve_display_name": {
                    "type": "string",
                    "description": "If true, automatically resolve alert display name conflicts. Otherwise, fail the request if the alert's display name conflicts with an existing alert's display name."
                  },
                  "query": {
                    "type": "string",
                    "description": ":returns: :class:`Query`"
                  }
                },
                "required": [
                  "update_mask"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Query"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/queries/{id}/visualizations": {
      "get": {
        "operationId": "queries_list_visualizations",
        "summary": "Gets a list of visualizations on a query.",
        "tags": [
          "sql",
          "queries"
        ],
        "description": "Gets a list of visualizations on a query.\n\n:param id: str\n:param page_size: int (optional)\n:param page_token: str (optional)\n\n:returns: Iterator over :class:`Visualization`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param page_size: int (optional)"
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": ":returns: Iterator over :class:`Visualization`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Visualization"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/queries": {
      "post": {
        "operationId": "queries_legacy_create",
        "summary": "Creates a new query definition. Queries created with this endpoint belong to the authenticated user",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Creates a new query definition. Queries created with this endpoint belong to the authenticated user\nmaking the request.\n\nThe `data_source_id` field specifies the ID of the SQL warehouse to run this query against. You can\nuse the Data Sources API to see a complete list of available SQL warehouses. Or you can copy the\n`data_source_id` from an existing query.\n\n**Note**: You cannot add a visualization until you create the query.\n\n**Warning**: This API is deprecated. Please use :method:queries/create instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param data_source_id: str (optional)\n  Data source ID maps to the ID of the data source used by the resource and is distinct from the\n  warehouse ID. [Learn more]\n\n  [Learn more]: https://docs.databricks.com/api/workspace/datasources/list\n:param description: str (optional)\n  General description that conveys additional information about this query such as usage notes.\n:param name: str (optional)\n  The title of this query that appears in list views, widget headings, and on the query page.\n:param options: Any (optional)\n  Exclusively used for storing a list parameter definitions. A parameter is an object with `title`,\n  `name`, `type`, and `value` properties. The `value` field here is the default value. It can be\n  overridden at runtime.\n:param parent: str (optional)\n  The identifier of the workspace folder containing the object.\n:param query: str (optional)\n  The text of the query to be run.\n:param run_as_role: :class:`RunAsRole` (optional)\n  Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as\n  viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)\n:param tags: List[str] (optional)\n\n:returns: :class:`LegacyQuery`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "data_source_id": {
                    "type": "string",
                    "description": "Data source ID maps to the ID of the data source used by the resource and is distinct from the warehouse ID. [Learn more] [Learn more]: https://docs.databricks.com/api/workspace/datasources/list"
                  },
                  "description": {
                    "type": "string",
                    "description": "General description that conveys additional information about this query such as usage notes."
                  },
                  "name": {
                    "type": "string",
                    "description": "The title of this query that appears in list views, widget headings, and on the query page."
                  },
                  "options": {
                    "type": "string",
                    "description": "Exclusively used for storing a list parameter definitions. A parameter is an object with `title`, `name`, `type`, and `value` properties. The `value` field here is the default value. It can be overridden at runtime."
                  },
                  "parent": {
                    "type": "string",
                    "description": "The identifier of the workspace folder containing the object."
                  },
                  "query": {
                    "type": "string",
                    "description": "The text of the query to be run."
                  },
                  "run_as_role": {
                    "type": "string",
                    "description": "Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)"
                  },
                  "tags": {
                    "type": "string",
                    "description": ":returns: :class:`LegacyQuery`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyQuery"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "queries_legacy_list",
        "summary": "Gets a list of queries. Optionally, this list can be filtered by a search term.",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Gets a list of queries. Optionally, this list can be filtered by a search term.\n\n**Warning**: Calling this API concurrently 10 or more times could result in throttling, service\ndegradation, or a temporary ban.\n\n**Warning**: This API is deprecated. Please use :method:queries/list instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param order: str (optional)\n  Name of query attribute to order by. Default sort order is ascending. Append a dash (`-`) to order\n  descending instead.\n\n  - `name`: The name of the query.\n\n  - `created_at`: The timestamp the query was created.\n\n  - `runtime`: The time it took to run this query. This is blank for parameterized queries. A blank\n  value is treated as the highest value for sorting.\n\n  - `executed_at`: The timestamp when the query was last run.\n\n  - `created_by`: The user name of the user that created the query.\n:param page: int (optional)\n  Page number to retrieve.\n:param page_size: int (optional)\n  Number of queries to return per page.\n:param q: str (optional)\n  Full text search term\n\n:returns: Iterator over :class:`LegacyQuery`",
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Name of query attribute to order by. Default sort order is ascending. Append a dash (`-`) to order descending instead. - `name`: The name of the query. - `created_at`: The timestamp the query was created. - `runtime`: The time it took to run this query. This is blank for parameterized queries. A blank value is treated as the highest value for sorting. - `executed_at`: The timestamp when the query was last run. - `created_by`: The user name of the user that created the query."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Page number to retrieve."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Number of queries to return per page."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Full text search term"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyQuery"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/queries/{query_id}": {
      "delete": {
        "operationId": "queries_legacy_delete",
        "summary": "Moves a query to the trash. Trashed queries immediately disappear from searches and list views, and",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Moves a query to the trash. Trashed queries immediately disappear from searches and list views, and\nthey cannot be used for alerts. The trash is deleted after 30 days.\n\n**Warning**: This API is deprecated. Please use :method:queries/delete instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param query_id: str",
        "parameters": [
          {
            "name": "query_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "queries_legacy_get",
        "summary": "Retrieve a query object definition along with contextual permissions information about the currently",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Retrieve a query object definition along with contextual permissions information about the currently\nauthenticated user.\n\n**Warning**: This API is deprecated. Please use :method:queries/get instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param query_id: str\n\n:returns: :class:`LegacyQuery`",
        "parameters": [
          {
            "name": "query_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":returns: :class:`LegacyQuery`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyQuery"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "queries_legacy_update",
        "summary": "Modify this query definition.",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Modify this query definition.\n\n**Note**: You cannot undo this operation.\n\n**Warning**: This API is deprecated. Please use :method:queries/update instead. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param query_id: str\n:param data_source_id: str (optional)\n  Data source ID maps to the ID of the data source used by the resource and is distinct from the\n  warehouse ID. [Learn more]\n\n  [Learn more]: https://docs.databricks.com/api/workspace/datasources/list\n:param description: str (optional)\n  General description that conveys additional information about this query such as usage notes.\n:param name: str (optional)\n  The title of this query that appears in list views, widget headings, and on the query page.\n:param options: Any (optional)\n  Exclusively used for storing a list parameter definitions. A parameter is an object with `title`,\n  `name`, `type`, and `value` properties. The `value` field here is the default value. It can be\n  overridden at runtime.\n:param query: str (optional)\n  The text of the query to be run.\n:param run_as_role: :class:`RunAsRole` (optional)\n  Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as\n  viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)\n:param tags: List[str] (optional)\n\n:returns: :class:`LegacyQuery`",
        "parameters": [
          {
            "name": "query_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param data_source_id: str (optional) Data source ID maps to the ID of the data source used by the resource and is distinct from the warehouse ID. [Learn more] [Learn more]: https://docs.databricks.com/api/workspace/datasources/list"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "data_source_id": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string",
                    "description": "General description that conveys additional information about this query such as usage notes."
                  },
                  "name": {
                    "type": "string",
                    "description": "The title of this query that appears in list views, widget headings, and on the query page."
                  },
                  "options": {
                    "type": "string",
                    "description": "Exclusively used for storing a list parameter definitions. A parameter is an object with `title`, `name`, `type`, and `value` properties. The `value` field here is the default value. It can be overridden at runtime."
                  },
                  "query": {
                    "type": "string",
                    "description": "The text of the query to be run."
                  },
                  "run_as_role": {
                    "type": "string",
                    "description": "Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)"
                  },
                  "tags": {
                    "type": "string",
                    "description": ":returns: :class:`LegacyQuery`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyQuery"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/queries/trash/{query_id}": {
      "post": {
        "operationId": "queries_legacy_restore",
        "summary": "Restore a query that has been moved to the trash. A restored query appears in list views and searches.",
        "tags": [
          "sql",
          "queries_legacy"
        ],
        "description": "Restore a query that has been moved to the trash. A restored query appears in list views and searches.\nYou can use restored queries for alerts.\n\n**Warning**: This API is deprecated. Please see the latest version. [Learn more]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param query_id: str",
        "parameters": [
          {
            "name": "query_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/history/queries": {
      "get": {
        "operationId": "query_history_list",
        "summary": "List the history of queries through SQL warehouses, and serverless compute.",
        "tags": [
          "sql",
          "query_history"
        ],
        "description": "List the history of queries through SQL warehouses, and serverless compute.\n\nYou can filter by user ID, warehouse ID, status, and time range. Most recently started queries are\nreturned first (up to max_results in request). The pagination token returned in response can be used\nto list subsequent query statuses.\n\n:param filter_by: :class:`QueryFilter` (optional)\n  An optional filter object to limit query history results. Accepts parameters such as user IDs,\n  endpoint IDs, and statuses to narrow the returned data. In a URL, the parameters of this filter are\n  specified with dot notation. For example: `filter_by.statement_ids`.\n:param include_metrics: bool (optional)\n  Whether to include the query metrics with each query. Only use this for a small subset of queries\n  (max_results). Defaults to false.\n:param max_results: int (optional)\n  Limit the number of results returned in one page. Must be less than 1000 and the default is 100.\n:param page_token: str (optional)\n  A token that can be used to get the next page of results. The token can contains characters that\n  need to be encoded before using it in a URL. For example, the character '+' needs to be replaced by\n  %2B. This field is optional.\n\n:returns: :class:`ListQueriesResponse`",
        "parameters": [
          {
            "name": "filter_by",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "An optional filter object to limit query history results. Accepts parameters such as user IDs, endpoint IDs, and statuses to narrow the returned data. In a URL, the parameters of this filter are specified with dot notation. For example: `filter_by.statement_ids`."
          },
          {
            "name": "include_metrics",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Whether to include the query metrics with each query. Only use this for a small subset of queries (max_results). Defaults to false."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Limit the number of results returned in one page. Must be less than 1000 and the default is 100."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "A token that can be used to get the next page of results. The token can contains characters that need to be encoded before using it in a URL. For example, the character '+' needs to be replaced by %2B. This field is optional."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQueriesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/visualizations": {
      "post": {
        "operationId": "query_visualizations_create",
        "summary": "Adds a visualization to a query.",
        "tags": [
          "sql",
          "query_visualizations"
        ],
        "description": "Adds a visualization to a query.\n\n:param visualization: :class:`CreateVisualizationRequestVisualization` (optional)\n\n:returns: :class:`Visualization`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "visualization": {
                    "type": "string",
                    "description": ":returns: :class:`Visualization`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Visualization"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/visualizations/{id}": {
      "delete": {
        "operationId": "query_visualizations_delete",
        "summary": "Removes a visualization.",
        "tags": [
          "sql",
          "query_visualizations"
        ],
        "description": "Removes a visualization.\n\n:param id: str",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "str"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "query_visualizations_update",
        "summary": "Updates a visualization.",
        "tags": [
          "sql",
          "query_visualizations"
        ],
        "description": "Updates a visualization.\n\n:param id: str\n:param update_mask: str\n  The field mask must be a single string, with multiple fields separated by commas (no spaces). The\n  field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g.,\n  `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only\n  the entire collection field can be specified. Field names must exactly match the resource field\n  names.\n\n  A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the\n  fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API\n  changes in the future.\n:param visualization: :class:`UpdateVisualizationRequestVisualization` (optional)\n\n:returns: :class:`Visualization`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": ":param update_mask: str The field mask must be a single string, with multiple fields separated by commas (no spaces). The field path is relative to the resource object, using a dot (`.`) to navigate sub-fields (e.g., `author.given_name`). Specification of elements in sequence or map fields is not allowed, as only the entire collection field can be specified. Field names must exactly match the resource field names. A field mask of `*` indicates full replacement. It\u2019s recommended to always explicitly list the fields being updated and avoid using `*` wildcards, as it can lead to unintended results if the API changes in the future."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "update_mask": {
                    "type": "string"
                  },
                  "visualization": {
                    "type": "string",
                    "description": ":returns: :class:`Visualization`"
                  }
                },
                "required": [
                  "update_mask"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Visualization"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/visualizations": {
      "post": {
        "operationId": "query_visualizations_legacy_create",
        "summary": "Creates visualization in the query.",
        "tags": [
          "sql",
          "query_visualizations_legacy"
        ],
        "description": "Creates visualization in the query.\n\n**Warning**: This API is deprecated. Please use :method:queryvisualizations/create instead. [Learn\nmore]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param options: Any\n  The options object varies widely from one visualization type to the next and is unsupported.\n  Databricks does not recommend modifying visualization settings in JSON.\n:param query_id: str\n  The identifier returned by :method:queries/create\n:param type: str\n  The type of visualization: chart, table, pivot table, and so on.\n:param description: str (optional)\n  A short description of this visualization. This is not displayed in the UI.\n:param name: str (optional)\n  The name of the visualization that appears on dashboards and the query screen.\n\n:returns: :class:`LegacyVisualization`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "options": {
                    "type": "string",
                    "description": "The options object varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization settings in JSON."
                  },
                  "query_id": {
                    "type": "string",
                    "description": "The identifier returned by :method:queries/create"
                  },
                  "type": {
                    "type": "string",
                    "description": "The type of visualization: chart, table, pivot table, and so on."
                  },
                  "description": {
                    "type": "string",
                    "description": "A short description of this visualization. This is not displayed in the UI."
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the visualization that appears on dashboards and the query screen."
                  }
                },
                "required": [
                  "options",
                  "query_id",
                  "type"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyVisualization"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/preview/sql/visualizations/{id}": {
      "delete": {
        "operationId": "query_visualizations_legacy_delete",
        "summary": "Removes a visualization from the query.",
        "tags": [
          "sql",
          "query_visualizations_legacy"
        ],
        "description": "Removes a visualization from the query.\n\n**Warning**: This API is deprecated. Please use :method:queryvisualizations/delete instead. [Learn\nmore]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param id: str\n  Widget ID returned by :method:queryvisualizations/create",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Widget ID returned by :method:queryvisualizations/create"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "query_visualizations_legacy_update",
        "summary": "Updates visualization in the query.",
        "tags": [
          "sql",
          "query_visualizations_legacy"
        ],
        "description": "Updates visualization in the query.\n\n**Warning**: This API is deprecated. Please use :method:queryvisualizations/update instead. [Learn\nmore]\n\n[Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html\n\n:param created_at: str (optional)\n:param description: str (optional)\n  A short description of this visualization. This is not displayed in the UI.\n:param id: str (optional)\n  The UUID for this visualization.\n:param name: str (optional)\n  The name of the visualization that appears on dashboards and the query screen.\n:param options: Any (optional)\n  The options object varies widely from one visualization type to the next and is unsupported.\n  Databricks does not recommend modifying visualization settings in JSON.\n:param query: :class:`LegacyQuery` (optional)\n:param type: str (optional)\n  The type of visualization: chart, table, pivot table, and so on.\n:param updated_at: str (optional)\n\n:returns: :class:`LegacyVisualization`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The UUID for this visualization."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "created_at": {
                    "type": "string",
                    "description": ":param description: str (optional) A short description of this visualization. This is not displayed in the UI."
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the visualization that appears on dashboards and the query screen."
                  },
                  "options": {
                    "type": "string",
                    "description": "The options object varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization settings in JSON."
                  },
                  "query": {
                    "type": "string",
                    "description": ":param type: str (optional) The type of visualization: chart, table, pivot table, and so on."
                  },
                  "type": {
                    "type": "string"
                  },
                  "updated_at": {
                    "type": "string",
                    "description": ":returns: :class:`LegacyVisualization`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyVisualization"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/redash-v2/config": {
      "get": {
        "operationId": "redash_config_get_config",
        "summary": "Read workspace configuration for Redash-v2.",
        "tags": [
          "sql",
          "redash_config"
        ],
        "description": "Read workspace configuration for Redash-v2.\n\n\n:returns: :class:`ClientConfig`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClientConfig"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/statements/{statement_id}/cancel": {
      "post": {
        "operationId": "statement_execution_cancel_execution",
        "summary": "Requests that an executing statement be canceled. Callers must poll for status to see the terminal",
        "tags": [
          "sql",
          "statement_execution"
        ],
        "description": "Requests that an executing statement be canceled. Callers must poll for status to see the terminal\nstate. Cancel response is empty; receiving response indicates successful receipt.\n\n:param statement_id: str\n  The statement ID is returned upon successfully submitting a SQL statement, and is a required\n  reference for all subsequent calls.",
        "parameters": [
          {
            "name": "statement_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The statement ID is returned upon successfully submitting a SQL statement, and is a required reference for all subsequent calls."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/statements": {
      "post": {
        "operationId": "statement_execution_execute_statement",
        "summary": "Execute a SQL statement and optionally await its results for a specified time.",
        "tags": [
          "sql",
          "statement_execution"
        ],
        "description": "Execute a SQL statement and optionally await its results for a specified time.\n\n**Use case: small result sets with INLINE + JSON_ARRAY**\n\nFor flows that generate small and predictable result sets (<= 25 MiB), `INLINE` responses of\n`JSON_ARRAY` result data are typically the simplest way to execute and fetch result data.\n\n**Use case: large result sets with EXTERNAL_LINKS**\n\nUsing `EXTERNAL_LINKS` to fetch result data allows you to fetch large result sets efficiently. The\nmain differences from using `INLINE` disposition are that the result data is accessed with URLs, and\nthat there are 3 supported formats: `JSON_ARRAY`, `ARROW_STREAM` and `CSV` compared to only\n`JSON_ARRAY` with `INLINE`.\n\n** URLs**\n\nExternal links point to data stored within your workspace's internal storage, in the form of a URL.\nThe URLs are valid for only a short period, <= 15 minutes. Alongside each `external_link` is an\nexpiration field indicating the time at which the URL is no longer valid. In `EXTERNAL_LINKS` mode,\nchunks can be resolved and fetched multiple times and in parallel.\n\n----\n\n### **Warning: Databricks strongly recommends that you protect the URLs that are returned by the\n`EXTERNAL_LINKS` disposition.**\n\nWhen you use the `EXTERNAL_LINKS` disposition, a short-lived, URL is generated, which can be used to\ndownload the results directly from . As a short-lived is embedded in this URL, you should protect the\nURL.\n\nBecause URLs are already generated with embedded temporary s, you must not set an `Authorization`\nheader in the download requests.\n\nThe `EXTERNAL_LINKS` disposition can be disabled upon request by creating a support case.\n\nSee also [Security best practices].\n\n----\n\nStatementResponse contains `statement_id` and `status`; other fields might be absent or present\ndepending on context. If the SQL warehouse fails to execute the provided statement, a 200 response is\nreturned with `status.state` set to `FAILED` (in contrast to a failure when accepting the request,\nwhich results in a non-200 response). Details of the error can be found at `status.error` in case of\nexecution failures.\n\n[Security best practices]: https://docs.databricks.com/sql/admin/sql-execution-tutorial.html#security-best-practices\n\n:param statement: str\n  The SQL statement to execute. The statement can optionally be parameterized, see `parameters`. The\n  maximum query text size is 16 MiB.\n:param warehouse_id: str\n  Warehouse upon which to execute a statement. See also [What are SQL warehouses?]\n\n  [What are SQL warehouses?]: https://docs.databricks.com/sql/admin/warehouse-type.html\n:param byte_limit: int (optional)\n  Applies the given byte limit to the statement's result size. Byte counts are based on internal data\n  representations and might not match the final size in the requested `format`. If the result was\n  truncated due to the byte limit, then `truncated` in the response is set to `true`. When using\n  `EXTERNAL_LINKS` disposition, a default `byte_limit` of 100 GiB is applied if `byte_limit` is not\n  explicitly set.\n:param catalog: str (optional)\n  Sets default catalog for statement execution, similar to [`USE CATALOG`] in SQL.\n\n  [`USE CATALOG`]: https://docs.databricks.com/sql/language-manual/sql-ref-syntax-ddl-use-catalog.html\n:param disposition: :class:`Disposition` (optional)\n  The fetch disposition provides two modes of fetching results: `INLINE` and `EXTERNAL_LINKS`.\n\n  Statements executed with `INLINE` disposition will return result data inline, in `JSON_ARRAY`\n  format, in a series of chunks. If a given statement produces a result set with a size larger than 25\n  MiB, that statement execution is aborted, and no result set will be available.\n\n  **NOTE** Byte limits are computed based upon internal representations of the result set data, and\n  might not match the sizes visible in JSON responses.\n\n  Statements executed with `EXTERNAL_LINKS` disposition will return result data as external links:\n  URLs that point to cloud storage internal to the workspace. Using `EXTERNAL_LINKS` disposition\n  allows statements to generate arbitrarily sized result sets for fetching up to 100 GiB. The\n  resulting links have two important properties:\n\n  1. They point to resources _external_ to the Databricks compute; therefore any associated\n  authentication information (typically a personal access token, OAuth token, or similar) _must be\n  removed_ when fetching from these links.\n\n  2. These are URLs with a specific expiration, indicated in the response. The behavior when\n  attempting to use an expired link is cloud specific.\n:param format: :class:`Format` (optional)\n  Statement execution supports three result formats: `JSON_ARRAY` (default), `ARROW_STREAM`, and\n  `CSV`.\n\n  Important: The formats `ARROW_STREAM` and `CSV` are supported only with `EXTERNAL_LINKS`\n  disposition. `JSON_ARRAY` is supported in `INLINE` and `EXTERNAL_LINKS` disposition.\n\n  When specifying `format=JSON_ARRAY`, result data will be formatted as an array of arrays of values,\n  where each value is either the *string representation* of a value, or `null`. For example, the\n  output of `SELECT concat('id-', id) AS strCol, id AS intCol, null AS nullCol FROM range(3)` would\n  look like this:\n\n  ``` [ [ \"id-1\", \"1\", null ], [ \"id-2\", \"2\", null ], [ \"id-3\", \"3\", null ], ] ```\n\n  When specifying `format=JSON_ARRAY` and `disposition=EXTERNAL_LINKS`, each chunk in the result\n  contains compact JSON with no indentation or extra whitespace.\n\n  When specifying `format=ARROW_STREAM` and `disposition=EXTERNAL_LINKS`, each chunk in the result\n  will be formatted as Apache Arrow Stream. See the [Apache Arrow streaming format].\n\n  When specifying `format=CSV` and `disposition=EXTERNAL_LINKS`, each chunk in the result will be a\n  CSV according to [RFC 4180] standard. All the columns values will have *string representation*\n  similar to the `JSON_ARRAY` format, and `null` values will be encoded as \u201cnull\u201d. Only the first\n  chunk in the result would contain a header row with column names. For example, the output of `SELECT\n  concat('id-', id) AS strCol, id AS intCol, null as nullCol FROM range(3)` would look like this:\n\n  ``` strCol,intCol,nullCol id-1,1,null id-2,2,null id-3,3,null ```\n\n  [Apache Arrow streaming format]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n  [RFC 4180]: https://www.rfc-editor.org/rfc/rfc4180\n:param on_wait_timeout: :class:`ExecuteStatementRequestOnWaitTimeout` (optional)\n  When `wait_timeout > 0s`, the call will block up to the specified time. If the statement execution\n  doesn't finish within this time, `on_wait_timeout` determines whether the execution should continue\n  or be canceled. When set to `CONTINUE`, the statement execution continues asynchronously and the\n  call returns a statement ID which can be used for polling with\n  :method:statementexecution/getStatement. When set to `CANCEL`, the statement execution is canceled\n  and the call returns with a `CANCELED` state.\n:param parameters: List[:class:`StatementParameterListItem`] (optional)\n  A list of parameters to pass into a SQL statement containing parameter markers. A parameter consists\n  of a name, a value, and optionally a type. To represent a NULL value, the `value` field may be\n  omitted or set to `null` explicitly. If the `type` field is omitted, the value is interpreted as a\n  string.\n\n  If the type is given, parameters will be checked for type correctness according to the given type. A\n  value is correct if the provided string can be converted to the requested type using the `cast`\n  function. The exact semantics are described in the section [`cast` function] of the SQL language\n  reference.\n\n  For example, the following statement contains two parameters, `my_name` and `my_date`:\n\n  ``` SELECT * FROM my_table WHERE name = :my_name AND date = :my_date ```\n\n  The parameters can be passed in the request body as follows:\n\n  ` { ..., \"statement\": \"SELECT * FROM my_table WHERE name = :my_name AND date = :my_date\",\n  \"parameters\": [ { \"name\": \"my_name\", \"value\": \"the name\" }, { \"name\": \"my_date\", \"value\":\n  \"2020-01-01\", \"type\": \"DATE\" } ] } `\n\n  Currently, positional parameters denoted by a `?` marker are not supported by the Databricks SQL\n  Statement Execution API.\n\n  Also see the section [Parameter markers] of the SQL language reference.\n\n  [Parameter markers]: https://docs.databricks.com/sql/language-manual/sql-ref-parameter-marker.html\n  [`cast` function]: https://docs.databricks.com/sql/language-manual/functions/cast.html\n:param query_tags: List[:class:`QueryTag`] (optional)\n  An array of query tags to annotate a SQL statement. A query tag consists of a non-empty key and,\n  optionally, a value. To represent a NULL value, either omit the `value` field or manually set it to\n  `null` or white space. Refer to the SQL language reference for the format specification of query\n  tags. There's no significance to the order of tags. Only one value per key will be recorded. A\n  sequence in excess of 20 query tags will be coerced to 20. Example:\n\n  { ..., \"query_tags\": [ { \"key\": \"team\", \"value\": \"eng\" }, { \"key\": \"some key only tag\" } ] }\n:param row_limit: int (optional)\n  Applies the given row limit to the statement's result set, but unlike the `LIMIT` clause in SQL, it\n  also sets the `truncated` field in the response to indicate whether the result was trimmed due to\n  the limit or not.\n:param schema: str (optional)\n  Sets default schema for statement execution, similar to [`USE SCHEMA`] in SQL.\n\n  [`USE SCHEMA`]: https://docs.databricks.com/sql/language-manual/sql-ref-syntax-ddl-use-schema.html\n:param wait_timeout: str (optional)\n  The time in seconds the call will wait for the statement's result set as `Ns`, where `N` can be set\n  to 0 or to a value between 5 and 50.\n\n  When set to `0s`, the statement will execute in asynchronous mode and the call will not wait for the\n  execution to finish. In this case, the call returns directly with `PENDING` state and a statement ID\n  which can be used for polling with :method:statementexecution/getStatement.\n\n  When set between 5 and 50 seconds, the call will behave synchronously up to this timeout and wait\n  for the statement execution to finish. If the execution finishes within this time, the call returns\n  immediately with a manifest and result data (or a `FAILED` state in case of an execution error). If\n  the statement takes longer to execute, `on_wait_timeout` determines what should happen after the\n  timeout is reached.\n\n:returns: :class:`StatementResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "statement": {
                    "type": "string",
                    "description": "The SQL statement to execute. The statement can optionally be parameterized, see `parameters`. The maximum query text size is 16 MiB."
                  },
                  "warehouse_id": {
                    "type": "string",
                    "description": "Warehouse upon which to execute a statement. See also [What are SQL warehouses?] [What are SQL warehouses?]: https://docs.databricks.com/sql/admin/warehouse-type.html"
                  },
                  "byte_limit": {
                    "type": "string",
                    "description": "Applies the given byte limit to the statement's result size. Byte counts are based on internal data representations and might not match the final size in the requested `format`. If the result was truncated due to the byte limit, then `truncated` in the response is set to `true`. When using `EXTERNAL_LINKS` disposition, a default `byte_limit` of 100 GiB is applied if `byte_limit` is not explicitly set."
                  },
                  "catalog": {
                    "type": "string",
                    "description": "Sets default catalog for statement execution, similar to [`USE CATALOG`] in SQL. [`USE CATALOG`]: https://docs.databricks.com/sql/language-manual/sql-ref-syntax-ddl-use-catalog.html"
                  },
                  "disposition": {
                    "type": "string",
                    "description": "The fetch disposition provides two modes of fetching results: `INLINE` and `EXTERNAL_LINKS`. Statements executed with `INLINE` disposition will return result data inline, in `JSON_ARRAY` format, in a series of chunks. If a given statement produces a result set with a size larger than 25 MiB, that statement execution is aborted, and no result set will be available. **NOTE** Byte limits are computed based upon internal representations of the result set data, and might not match the sizes visible in JSON responses. Statements executed with `EXTERNAL_LINKS` disposition will return result data as external links: URLs that point to cloud storage internal to the workspace. Using `EXTERNAL_LINKS` disposition allows statements to generate arbitrarily sized result sets for fetching up to 100 GiB. The resulting links have two important properties: 1. They point to resources _external_ to the Databricks compute; therefore any associated authentication information (typically a personal access token, OAuth token, or similar) _must be removed_ when fetching from these links. 2. These are URLs with a specific expiration, indicated in the response. The behavior when attempting to use an expired link is cloud specific."
                  },
                  "format": {
                    "type": "string",
                    "description": "Statement execution supports three result formats: `JSON_ARRAY` (default), `ARROW_STREAM`, and `CSV`. Important: The formats `ARROW_STREAM` and `CSV` are supported only with `EXTERNAL_LINKS` disposition. `JSON_ARRAY` is supported in `INLINE` and `EXTERNAL_LINKS` disposition. When specifying `format=JSON_ARRAY`, result data will be formatted as an array of arrays of values, where each value is either the *string representation* of a value, or `null`. For example, the output of `SELECT concat('id-', id) AS strCol, id AS intCol, null AS nullCol FROM range(3)` would look like this: ``` [ [ \"id-1\", \"1\", null ], [ \"id-2\", \"2\", null ], [ \"id-3\", \"3\", null ], ] ``` When specifying `format=JSON_ARRAY` and `disposition=EXTERNAL_LINKS`, each chunk in the result contains compact JSON with no indentation or extra whitespace. When specifying `format=ARROW_STREAM` and `disposition=EXTERNAL_LINKS`, each chunk in the result will be formatted as Apache Arrow Stream. See the [Apache Arrow streaming format]. When specifying `format=CSV` and `disposition=EXTERNAL_LINKS`, each chunk in the result will be a CSV according to [RFC 4180] standard. All the columns values will have *string representation* similar to the `JSON_ARRAY` format, and `null` values will be encoded as \u201cnull\u201d. Only the first chunk in the result would contain a header row with column names. For example, the output of `SELECT concat('id-', id) AS strCol, id AS intCol, null as nullCol FROM range(3)` would look like this: ``` strCol,intCol,nullCol id-1,1,null id-2,2,null id-3,3,null ``` [Apache Arrow streaming format]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format [RFC 4180]: https://www.rfc-editor.org/rfc/rfc4180"
                  },
                  "on_wait_timeout": {
                    "type": "string",
                    "description": "When `wait_timeout > 0s`, the call will block up to the specified time. If the statement execution doesn't finish within this time, `on_wait_timeout` determines whether the execution should continue or be canceled. When set to `CONTINUE`, the statement execution continues asynchronously and the call returns a statement ID which can be used for polling with :method:statementexecution/getStatement. When set to `CANCEL`, the statement execution is canceled and the call returns with a `CANCELED` state."
                  },
                  "parameters": {
                    "type": "string",
                    "description": "A list of parameters to pass into a SQL statement containing parameter markers. A parameter consists of a name, a value, and optionally a type. To represent a NULL value, the `value` field may be omitted or set to `null` explicitly. If the `type` field is omitted, the value is interpreted as a string. If the type is given, parameters will be checked for type correctness according to the given type. A value is correct if the provided string can be converted to the requested type using the `cast` function. The exact semantics are described in the section [`cast` function] of the SQL language reference. For example, the following statement contains two parameters, `my_name` and `my_date`: ``` SELECT * FROM my_table WHERE name = :my_name AND date = :my_date ``` The parameters can be passed in the request body as follows: ` { ..., \"statement\": \"SELECT * FROM my_table WHERE name = :my_name AND date = :my_date\", \"parameters\": [ { \"name\": \"my_name\", \"value\": \"the name\" }, { \"name\": \"my_date\", \"value\": \"2020-01-01\", \"type\": \"DATE\" } ] } ` Currently, positional parameters denoted by a `?` marker are not supported by the Databricks SQL Statement Execution API. Also see the section [Parameter markers] of the SQL language reference. [Parameter markers]: https://docs.databricks.com/sql/language-manual/sql-ref-parameter-marker.html [`cast` function]: https://docs.databricks.com/sql/language-manual/functions/cast.html"
                  },
                  "query_tags": {
                    "type": "string",
                    "description": "An array of query tags to annotate a SQL statement. A query tag consists of a non-empty key and, optionally, a value. To represent a NULL value, either omit the `value` field or manually set it to `null` or white space. Refer to the SQL language reference for the format specification of query tags. There's no significance to the order of tags. Only one value per key will be recorded. A sequence in excess of 20 query tags will be coerced to 20. Example: { ..., \"query_tags\": [ { \"key\": \"team\", \"value\": \"eng\" }, { \"key\": \"some key only tag\" } ] }"
                  },
                  "row_limit": {
                    "type": "string",
                    "description": "Applies the given row limit to the statement's result set, but unlike the `LIMIT` clause in SQL, it also sets the `truncated` field in the response to indicate whether the result was trimmed due to the limit or not."
                  },
                  "schema": {
                    "type": "string",
                    "description": "Sets default schema for statement execution, similar to [`USE SCHEMA`] in SQL. [`USE SCHEMA`]: https://docs.databricks.com/sql/language-manual/sql-ref-syntax-ddl-use-schema.html"
                  },
                  "wait_timeout": {
                    "type": "string",
                    "description": "The time in seconds the call will wait for the statement's result set as `Ns`, where `N` can be set to 0 or to a value between 5 and 50. When set to `0s`, the statement will execute in asynchronous mode and the call will not wait for the execution to finish. In this case, the call returns directly with `PENDING` state and a statement ID which can be used for polling with :method:statementexecution/getStatement. When set between 5 and 50 seconds, the call will behave synchronously up to this timeout and wait for the statement execution to finish. If the execution finishes within this time, the call returns immediately with a manifest and result data (or a `FAILED` state in case of an execution error). If the statement takes longer to execute, `on_wait_timeout` determines what should happen after the timeout is reached."
                  }
                },
                "required": [
                  "statement",
                  "warehouse_id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatementResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/statements/{statement_id}": {
      "get": {
        "operationId": "statement_execution_get_statement",
        "summary": "This request can be used to poll for the statement's status. StatementResponse contains `statement_id`",
        "tags": [
          "sql",
          "statement_execution"
        ],
        "description": "This request can be used to poll for the statement's status. StatementResponse contains `statement_id`\nand `status`; other fields might be absent or present depending on context. When the `status.state`\nfield is `SUCCEEDED` it will also return the result manifest and the first chunk of the result data.\nWhen the statement is in the terminal states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200\nwith the state set. After at least 12 hours in terminal state, the statement is removed from the\nwarehouse and further calls will receive an HTTP 404 response.\n\n**NOTE** This call currently might take up to 5 seconds to get the latest status and result.\n\n:param statement_id: str\n  The statement ID is returned upon successfully submitting a SQL statement, and is a required\n  reference for all subsequent calls.\n\n:returns: :class:`StatementResponse`",
        "parameters": [
          {
            "name": "statement_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The statement ID is returned upon successfully submitting a SQL statement, and is a required reference for all subsequent calls."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatementResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/statements/{statement_id}/result/chunks/{chunk_index}": {
      "get": {
        "operationId": "statement_execution_get_statement_result_chunk_n",
        "summary": "After the statement execution has `SUCCEEDED`, this request can be used to fetch any chunk by index.",
        "tags": [
          "sql",
          "statement_execution"
        ],
        "description": "After the statement execution has `SUCCEEDED`, this request can be used to fetch any chunk by index.\nWhereas the first chunk with `chunk_index=0` is typically fetched with\n:method:statementexecution/executeStatement or :method:statementexecution/getStatement, this request\ncan be used to fetch subsequent chunks. The response structure is identical to the nested `result`\nelement described in the :method:statementexecution/getStatement request, and similarly includes the\n`next_chunk_index` and `next_chunk_internal_link` fields for simple iteration through the result set.\nDepending on `disposition`, the response returns chunks of data either inline, or as links.\n\n:param statement_id: str\n  The statement ID is returned upon successfully submitting a SQL statement, and is a required\n  reference for all subsequent calls.\n:param chunk_index: int\n\n:returns: :class:`ResultData`",
        "parameters": [
          {
            "name": "statement_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The statement ID is returned upon successfully submitting a SQL statement, and is a required reference for all subsequent calls."
          },
          {
            "name": "chunk_index",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": ":returns: :class:`ResultData`"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResultData"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/warehouses": {
      "post": {
        "operationId": "warehouses_create",
        "summary": "Creates a new SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Creates a new SQL warehouse.\n\n:param auto_stop_mins: int (optional)\n  The amount of time in minutes that a SQL warehouse must be idle (i.e., no RUNNING queries) before it\n  is automatically stopped.\n\n  Supported values: - Must be == 0 or >= 10 mins - 0 indicates no autostop.\n\n  Defaults to 120 mins\n:param channel: :class:`Channel` (optional)\n  Channel Details\n:param cluster_size: str (optional)\n  Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you\n  to run larger queries on it. If you want to increase the number of concurrent queries, please tune\n  max_num_clusters.\n\n  Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large -\n  4X-Large\n:param creator_name: str (optional)\n  warehouse creator name\n:param enable_photon: bool (optional)\n  Configures whether the warehouse should use Photon optimized clusters.\n\n  Defaults to false.\n:param enable_serverless_compute: bool (optional)\n  Configures whether the warehouse should use serverless compute\n:param instance_profile_arn: str (optional)\n  Deprecated. Instance profile used to pass IAM role to the cluster\n:param max_num_clusters: int (optional)\n  Maximum number of clusters that the autoscaler will create to handle concurrent queries.\n\n  Supported values: - Must be >= min_num_clusters - Must be <= 40.\n\n  Defaults to min_clusters if unset.\n:param min_num_clusters: int (optional)\n  Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this\n  will ensure that a larger number of clusters are always running and therefore may reduce the cold\n  start time for new queries. This is similar to reserved vs. revocable cores in a resource manager.\n\n  Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30)\n\n  Defaults to 1\n:param name: str (optional)\n  Logical name for the cluster.\n\n  Supported values: - Must be unique within an org. - Must be less than 100 characters.\n:param spot_instance_policy: :class:`SpotInstancePolicy` (optional)\n  Configurations whether the endpoint should use spot instances.\n:param tags: :class:`EndpointTags` (optional)\n  A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes)\n  associated with this SQL warehouse.\n\n  Supported values: - Number of tags < 45.\n:param warehouse_type: :class:`CreateWarehouseRequestWarehouseType` (optional)\n  Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and\n  also set the field `enable_serverless_compute` to `true`.\n\n:returns:\n  Long-running operation waiter for :class:`GetWarehouseResponse`.\n  See :method:wait_get_warehouse_running for more details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "auto_stop_mins": {
                    "type": "string",
                    "description": "The amount of time in minutes that a SQL warehouse must be idle (i.e., no RUNNING queries) before it is automatically stopped. Supported values: - Must be == 0 or >= 10 mins - 0 indicates no autostop. Defaults to 120 mins"
                  },
                  "channel": {
                    "type": "string",
                    "description": "Channel Details"
                  },
                  "cluster_size": {
                    "type": "string",
                    "description": "Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you to run larger queries on it. If you want to increase the number of concurrent queries, please tune max_num_clusters. Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large - 4X-Large"
                  },
                  "creator_name": {
                    "type": "string",
                    "description": "warehouse creator name"
                  },
                  "enable_photon": {
                    "type": "string",
                    "description": "Configures whether the warehouse should use Photon optimized clusters. Defaults to false."
                  },
                  "enable_serverless_compute": {
                    "type": "string",
                    "description": "Configures whether the warehouse should use serverless compute"
                  },
                  "instance_profile_arn": {
                    "type": "string",
                    "description": "Deprecated. Instance profile used to pass IAM role to the cluster"
                  },
                  "max_num_clusters": {
                    "type": "string",
                    "description": "Maximum number of clusters that the autoscaler will create to handle concurrent queries. Supported values: - Must be >= min_num_clusters - Must be <= 40. Defaults to min_clusters if unset."
                  },
                  "min_num_clusters": {
                    "type": "string",
                    "description": "Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this will ensure that a larger number of clusters are always running and therefore may reduce the cold start time for new queries. This is similar to reserved vs. revocable cores in a resource manager. Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30) Defaults to 1"
                  },
                  "name": {
                    "type": "string",
                    "description": "Logical name for the cluster. Supported values: - Must be unique within an org. - Must be less than 100 characters."
                  },
                  "spot_instance_policy": {
                    "type": "string",
                    "description": "Configurations whether the endpoint should use spot instances."
                  },
                  "tags": {
                    "type": "string",
                    "description": "A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes) associated with this SQL warehouse. Supported values: - Number of tags < 45."
                  },
                  "warehouse_type": {
                    "type": "string",
                    "description": "Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehouseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "warehouses_list",
        "summary": "Lists all SQL warehouses that a user has access to.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Lists all SQL warehouses that a user has access to.\n\n:param page_size: int (optional)\n  The max number of warehouses to return.\n:param page_token: str (optional)\n  A page token, received from a previous `ListWarehouses` call. Provide this to retrieve the\n  subsequent page; otherwise the first will be retrieved.\n\n  When paginating, all other parameters provided to `ListWarehouses` must match the call that provided\n  the page token.\n:param run_as_user_id: int (optional)\n  Service Principal which will be used to fetch the list of endpoints. If not specified, SQL Gateway\n  will use the user from the session header.\n\n:returns: Iterator over :class:`EndpointInfo`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The max number of warehouses to return."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "A page token, received from a previous `ListWarehouses` call. Provide this to retrieve the subsequent page; otherwise the first will be retrieved. When paginating, all other parameters provided to `ListWarehouses` must match the call that provided the page token."
          },
          {
            "name": "run_as_user_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Service Principal which will be used to fetch the list of endpoints. If not specified, SQL Gateway will use the user from the session header."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EndpointInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/warehouses/v1/default-warehouse-overrides": {
      "post": {
        "operationId": "warehouses_create_default_warehouse_override",
        "summary": "Creates a new default warehouse override for a user. Users can create their own override. Admins can",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Creates a new default warehouse override for a user. Users can create their own override. Admins can\ncreate overrides for any user.\n\n:param default_warehouse_override: :class:`DefaultWarehouseOverride`\n  Required. The default warehouse override to create.\n:param default_warehouse_override_id: str\n  Required. The ID to use for the override, which will become the final component of the override's\n  resource name. Can be a numeric user ID or the literal string \"me\" for the current user.\n\n:returns: :class:`DefaultWarehouseOverride`",
        "parameters": [
          {
            "name": "default_warehouse_override_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The ID to use for the override, which will become the final component of the override's resource name. Can be a numeric user ID or the literal string \"me\" for the current user."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "default_warehouse_override": {
                    "type": "string",
                    "description": "Required. The default warehouse override to create."
                  }
                },
                "required": [
                  "default_warehouse_override"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultWarehouseOverride"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "warehouses_list_default_warehouse_overrides",
        "summary": "Lists all default warehouse overrides in the workspace. Only workspace administrators can list all",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Lists all default warehouse overrides in the workspace. Only workspace administrators can list all\noverrides.\n\n:param page_size: int (optional)\n  The maximum number of overrides to return. The service may return fewer than this value. If\n  unspecified, at most 100 overrides will be returned. The maximum value is 1000; values above 1000\n  will be coerced to 1000.\n:param page_token: str (optional)\n  A page token, received from a previous `ListDefaultWarehouseOverrides` call. Provide this to\n  retrieve the subsequent page.\n\n  When paginating, all other parameters provided to `ListDefaultWarehouseOverrides` must match the\n  call that provided the page token.\n\n:returns: Iterator over :class:`DefaultWarehouseOverride`",
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "The maximum number of overrides to return. The service may return fewer than this value. If unspecified, at most 100 overrides will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "A page token, received from a previous `ListDefaultWarehouseOverrides` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListDefaultWarehouseOverrides` must match the call that provided the page token."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultWarehouseOverride"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/warehouses/{id}": {
      "delete": {
        "operationId": "warehouses_delete",
        "summary": "Deletes a SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Deletes a SQL warehouse.\n\n:param id: str\n  Required. Id of the SQL warehouse.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Id of the SQL warehouse."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "warehouses_get",
        "summary": "Gets the information for a single SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Gets the information for a single SQL warehouse.\n\n:param id: str\n  Required. Id of the SQL warehouse.\n\n:returns: :class:`GetWarehouseResponse`",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Id of the SQL warehouse."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehouseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/warehouses/v1/{name}": {
      "delete": {
        "operationId": "warehouses_delete_default_warehouse_override",
        "summary": "Deletes the default warehouse override for a user. Users can delete their own override. Admins can",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Deletes the default warehouse override for a user. Users can delete their own override. Admins can\ndelete overrides for any user. After deletion, the workspace default warehouse will be used.\n\n:param name: str\n  Required. The resource name of the default warehouse override to delete. Format:\n  default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be\n  a numeric user ID or the literal string \"me\" for the current user.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The resource name of the default warehouse override to delete. Format: default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be a numeric user ID or the literal string \"me\" for the current user."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "get": {
        "operationId": "warehouses_get_default_warehouse_override",
        "summary": "Returns the default warehouse override for a user. Users can fetch their own override. Admins can",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Returns the default warehouse override for a user. Users can fetch their own override. Admins can\nfetch overrides for any user. If no override exists, the UI will fallback to the workspace default\nwarehouse.\n\n:param name: str\n  Required. The resource name of the default warehouse override to retrieve. Format:\n  default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be\n  a numeric user ID or the literal string \"me\" for the current user.\n\n:returns: :class:`DefaultWarehouseOverride`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. The resource name of the default warehouse override to retrieve. Format: default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be a numeric user ID or the literal string \"me\" for the current user."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultWarehouseOverride"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "warehouses_update_default_warehouse_override",
        "summary": "Updates an existing default warehouse override for a user. Users can update their own override. Admins",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Updates an existing default warehouse override for a user. Users can update their own override. Admins\ncan update overrides for any user.\n\n:param name: str\n  The resource name of the default warehouse override. Format:\n  default-warehouse-overrides/{default_warehouse_override_id}\n:param default_warehouse_override: :class:`DefaultWarehouseOverride`\n  Required. The default warehouse override to update. The name field must be set in the format:\n  default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be\n  a numeric user ID or the literal string \"me\" for the current user.\n:param update_mask: FieldMask\n  Required. Field mask specifying which fields to update. Only the fields specified in the mask will\n  be updated. Use \"*\" to update all fields. When allow_missing is true, this field is ignored and all\n  fields are applied.\n:param allow_missing: bool (optional)\n  If set to true, and the override is not found, a new override will be created. In this situation,\n  `update_mask` is ignored and all fields are applied. Defaults to false.\n\n:returns: :class:`DefaultWarehouseOverride`",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The resource name of the default warehouse override. Format: default-warehouse-overrides/{default_warehouse_override_id}"
          },
          {
            "name": "update_mask",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Field mask specifying which fields to update. Only the fields specified in the mask will be updated. Use \"*\" to update all fields. When allow_missing is true, this field is ignored and all fields are applied."
          },
          {
            "name": "allow_missing",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "If set to true, and the override is not found, a new override will be created. In this situation, `update_mask` is ignored and all fields are applied. Defaults to false."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "default_warehouse_override": {
                    "type": "string",
                    "description": "Required. The default warehouse override to update. The name field must be set in the format: default-warehouse-overrides/{default_warehouse_override_id} The default_warehouse_override_id can be a numeric user ID or the literal string \"me\" for the current user."
                  }
                },
                "required": [
                  "default_warehouse_override"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultWarehouseOverride"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/warehouses/{id}/edit": {
      "post": {
        "operationId": "warehouses_edit",
        "summary": "Updates the configuration for a SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Updates the configuration for a SQL warehouse.\n\n:param id: str\n  Required. Id of the warehouse to configure.\n:param auto_stop_mins: int (optional)\n  The amount of time in minutes that a SQL warehouse must be idle (i.e., no RUNNING queries) before it\n  is automatically stopped.\n\n  Supported values: - Must be == 0 or >= 10 mins - 0 indicates no autostop.\n\n  Defaults to 120 mins\n:param channel: :class:`Channel` (optional)\n  Channel Details\n:param cluster_size: str (optional)\n  Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you\n  to run larger queries on it. If you want to increase the number of concurrent queries, please tune\n  max_num_clusters.\n\n  Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large -\n  4X-Large\n:param creator_name: str (optional)\n  warehouse creator name\n:param enable_photon: bool (optional)\n  Configures whether the warehouse should use Photon optimized clusters.\n\n  Defaults to false.\n:param enable_serverless_compute: bool (optional)\n  Configures whether the warehouse should use serverless compute\n:param instance_profile_arn: str (optional)\n  Deprecated. Instance profile used to pass IAM role to the cluster\n:param max_num_clusters: int (optional)\n  Maximum number of clusters that the autoscaler will create to handle concurrent queries.\n\n  Supported values: - Must be >= min_num_clusters - Must be <= 40.\n\n  Defaults to min_clusters if unset.\n:param min_num_clusters: int (optional)\n  Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this\n  will ensure that a larger number of clusters are always running and therefore may reduce the cold\n  start time for new queries. This is similar to reserved vs. revocable cores in a resource manager.\n\n  Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30)\n\n  Defaults to 1\n:param name: str (optional)\n  Logical name for the cluster.\n\n  Supported values: - Must be unique within an org. - Must be less than 100 characters.\n:param spot_instance_policy: :class:`SpotInstancePolicy` (optional)\n  Configurations whether the endpoint should use spot instances.\n:param tags: :class:`EndpointTags` (optional)\n  A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes)\n  associated with this SQL warehouse.\n\n  Supported values: - Number of tags < 45.\n:param warehouse_type: :class:`EditWarehouseRequestWarehouseType` (optional)\n  Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and\n  also set the field `enable_serverless_compute` to `true`.\n\n:returns:\n  Long-running operation waiter for :class:`GetWarehouseResponse`.\n  See :method:wait_get_warehouse_running for more details.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Id of the warehouse to configure."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "auto_stop_mins": {
                    "type": "string",
                    "description": "The amount of time in minutes that a SQL warehouse must be idle (i.e., no RUNNING queries) before it is automatically stopped. Supported values: - Must be == 0 or >= 10 mins - 0 indicates no autostop. Defaults to 120 mins"
                  },
                  "channel": {
                    "type": "string",
                    "description": "Channel Details"
                  },
                  "cluster_size": {
                    "type": "string",
                    "description": "Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you to run larger queries on it. If you want to increase the number of concurrent queries, please tune max_num_clusters. Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large - 4X-Large"
                  },
                  "creator_name": {
                    "type": "string",
                    "description": "warehouse creator name"
                  },
                  "enable_photon": {
                    "type": "string",
                    "description": "Configures whether the warehouse should use Photon optimized clusters. Defaults to false."
                  },
                  "enable_serverless_compute": {
                    "type": "string",
                    "description": "Configures whether the warehouse should use serverless compute"
                  },
                  "instance_profile_arn": {
                    "type": "string",
                    "description": "Deprecated. Instance profile used to pass IAM role to the cluster"
                  },
                  "max_num_clusters": {
                    "type": "string",
                    "description": "Maximum number of clusters that the autoscaler will create to handle concurrent queries. Supported values: - Must be >= min_num_clusters - Must be <= 40. Defaults to min_clusters if unset."
                  },
                  "min_num_clusters": {
                    "type": "string",
                    "description": "Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this will ensure that a larger number of clusters are always running and therefore may reduce the cold start time for new queries. This is similar to reserved vs. revocable cores in a resource manager. Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30) Defaults to 1"
                  },
                  "name": {
                    "type": "string",
                    "description": "Logical name for the cluster. Supported values: - Must be unique within an org. - Must be less than 100 characters."
                  },
                  "spot_instance_policy": {
                    "type": "string",
                    "description": "Configurations whether the endpoint should use spot instances."
                  },
                  "tags": {
                    "type": "string",
                    "description": "A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes) associated with this SQL warehouse. Supported values: - Number of tags < 45."
                  },
                  "warehouse_type": {
                    "type": "string",
                    "description": "Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehouseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/warehouses/{warehouse_id}/permissionLevels": {
      "get": {
        "operationId": "warehouses_get_permission_levels",
        "summary": "Gets the permission levels that a user can have on an object.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Gets the permission levels that a user can have on an object.\n\n:param warehouse_id: str\n  The SQL warehouse for which to get or manage permissions.\n\n:returns: :class:`GetWarehousePermissionLevelsResponse`",
        "parameters": [
          {
            "name": "warehouse_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The SQL warehouse for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehousePermissionLevelsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/permissions/warehouses/{warehouse_id}": {
      "get": {
        "operationId": "warehouses_get_permissions",
        "summary": "Gets the permissions of a SQL warehouse. SQL warehouses can inherit permissions from their root",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Gets the permissions of a SQL warehouse. SQL warehouses can inherit permissions from their root\nobject.\n\n:param warehouse_id: str\n  The SQL warehouse for which to get or manage permissions.\n\n:returns: :class:`WarehousePermissions`",
        "parameters": [
          {
            "name": "warehouse_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The SQL warehouse for which to get or manage permissions."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WarehousePermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "warehouses_set_permissions",
        "summary": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct\npermissions if none are specified. Objects can inherit permissions from their root object.\n\n:param warehouse_id: str\n  The SQL warehouse for which to get or manage permissions.\n:param access_control_list: List[:class:`WarehouseAccessControlRequest`] (optional)\n\n:returns: :class:`WarehousePermissions`",
        "parameters": [
          {
            "name": "warehouse_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The SQL warehouse for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`WarehousePermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WarehousePermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "operationId": "warehouses_update_permissions",
        "summary": "Updates the permissions on a SQL warehouse. SQL warehouses can inherit permissions from their root",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Updates the permissions on a SQL warehouse. SQL warehouses can inherit permissions from their root\nobject.\n\n:param warehouse_id: str\n  The SQL warehouse for which to get or manage permissions.\n:param access_control_list: List[:class:`WarehouseAccessControlRequest`] (optional)\n\n:returns: :class:`WarehousePermissions`",
        "parameters": [
          {
            "name": "warehouse_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The SQL warehouse for which to get or manage permissions."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_control_list": {
                    "type": "string",
                    "description": ":returns: :class:`WarehousePermissions`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WarehousePermissions"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/config/warehouses": {
      "get": {
        "operationId": "warehouses_get_workspace_warehouse_config",
        "summary": "Gets the workspace level configuration that is shared by all SQL warehouses in a workspace.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Gets the workspace level configuration that is shared by all SQL warehouses in a workspace.\n\n\n:returns: :class:`GetWorkspaceWarehouseConfigResponse`",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkspaceWarehouseConfigResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "operationId": "warehouses_set_workspace_warehouse_config",
        "summary": "Sets the workspace level configuration that is shared by all SQL warehouses in a workspace.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Sets the workspace level configuration that is shared by all SQL warehouses in a workspace.\n\n:param channel: :class:`Channel` (optional)\n  Optional: Channel selection details\n:param config_param: :class:`RepeatedEndpointConfPairs` (optional)\n  Deprecated: Use sql_configuration_parameters\n:param data_access_config: List[:class:`EndpointConfPair`] (optional)\n  Spark confs for external hive metastore configuration JSON serialized size must be less than <= 512K\n:param enable_serverless_compute: bool (optional)\n  Enable Serverless compute for SQL warehouses\n:param enabled_warehouse_types: List[:class:`WarehouseTypePair`] (optional)\n  List of Warehouse Types allowed in this workspace (limits allowed value of the type field in\n  CreateWarehouse and EditWarehouse). Note: Some types cannot be disabled, they don't need to be\n  specified in SetWorkspaceWarehouseConfig. Note: Disabling a type may cause existing warehouses to be\n  converted to another type. Used by frontend to save specific type availability in the warehouse\n  create and edit form UI.\n:param global_param: :class:`RepeatedEndpointConfPairs` (optional)\n  Deprecated: Use sql_configuration_parameters\n:param google_service_account: str (optional)\n  GCP only: Google Service Account used to pass to cluster to access Google Cloud Storage\n:param instance_profile_arn: str (optional)\n  AWS Only: The instance profile used to pass an IAM role to the SQL warehouses. This configuration is\n  also applied to the workspace's serverless compute for notebooks and jobs.\n:param security_policy: :class:`SetWorkspaceWarehouseConfigRequestSecurityPolicy` (optional)\n  Security policy for warehouses\n:param sql_configuration_parameters: :class:`RepeatedEndpointConfPairs` (optional)\n  SQL configuration parameters",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "channel": {
                    "type": "string",
                    "description": "Optional: Channel selection details"
                  },
                  "config_param": {
                    "type": "string",
                    "description": "Deprecated: Use sql_configuration_parameters"
                  },
                  "data_access_config": {
                    "type": "string",
                    "description": "Spark confs for external hive metastore configuration JSON serialized size must be less than <= 512K"
                  },
                  "enable_serverless_compute": {
                    "type": "string",
                    "description": "Enable Serverless compute for SQL warehouses"
                  },
                  "enabled_warehouse_types": {
                    "type": "string",
                    "description": "List of Warehouse Types allowed in this workspace (limits allowed value of the type field in CreateWarehouse and EditWarehouse). Note: Some types cannot be disabled, they don't need to be specified in SetWorkspaceWarehouseConfig. Note: Disabling a type may cause existing warehouses to be converted to another type. Used by frontend to save specific type availability in the warehouse create and edit form UI."
                  },
                  "global_param": {
                    "type": "string",
                    "description": "Deprecated: Use sql_configuration_parameters"
                  },
                  "google_service_account": {
                    "type": "string",
                    "description": "GCP only: Google Service Account used to pass to cluster to access Google Cloud Storage"
                  },
                  "instance_profile_arn": {
                    "type": "string",
                    "description": "AWS Only: The instance profile used to pass an IAM role to the SQL warehouses. This configuration is also applied to the workspace's serverless compute for notebooks and jobs."
                  },
                  "security_policy": {
                    "type": "string",
                    "description": "Security policy for warehouses"
                  },
                  "sql_configuration_parameters": {
                    "type": "string",
                    "description": "SQL configuration parameters"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/warehouses/{id}/start": {
      "post": {
        "operationId": "warehouses_start",
        "summary": "Starts a SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Starts a SQL warehouse.\n\n:param id: str\n  Required. Id of the SQL warehouse.\n\n:returns:\n  Long-running operation waiter for :class:`GetWarehouseResponse`.\n  See :method:wait_get_warehouse_running for more details.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Id of the SQL warehouse."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehouseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/2.0/sql/warehouses/{id}/stop": {
      "post": {
        "operationId": "warehouses_stop",
        "summary": "Stops a SQL warehouse.",
        "tags": [
          "sql",
          "warehouses"
        ],
        "description": "Stops a SQL warehouse.\n\n:param id: str\n  Required. Id of the SQL warehouse.\n\n:returns:\n  Long-running operation waiter for :class:`GetWarehouseResponse`.\n  See :method:wait_get_warehouse_stopped for more details.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Id of the SQL warehouse."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWarehouseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AccessControl": {
        "type": "object",
        "properties": {
          "group_name": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/PermissionLevel",
            "description": "* `CAN_VIEW`: Can view the query * `CAN_RUN`: Can run the query * `CAN_EDIT`: Can edit the query * `CAN_MANAGE`: Can manage the query"
          },
          "user_name": {
            "type": "string"
          }
        }
      },
      "Alert": {
        "type": "object",
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/AlertCondition"
          },
          "create_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was created."
          },
          "custom_body": {
            "type": "string",
            "description": "Custom body of alert notification, if it exists. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "custom_subject": {
            "type": "string",
            "description": "Custom subject of alert notification, if it exists. This can include email subject entries and Slack notification headers, for example. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "display_name": {
            "type": "string",
            "description": "The display name of the alert."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the alert."
          },
          "lifecycle_state": {
            "$ref": "#/components/schemas/LifecycleState",
            "description": "The workspace state of the alert. Used for tracking trashed status."
          },
          "notify_on_ok": {
            "type": "boolean",
            "description": "Whether to notify alert subscribers when alert returns back to normal."
          },
          "owner_user_name": {
            "type": "string",
            "description": "The owner's username. This field is set to \"Unavailable\" if the user has been deleted."
          },
          "parent_path": {
            "type": "string",
            "description": "The workspace path of the folder containing the alert."
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query attached to the alert."
          },
          "seconds_to_retrigger": {
            "type": "integer",
            "description": "Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again."
          },
          "state": {
            "$ref": "#/components/schemas/AlertState",
            "description": "Current state of the alert's trigger status. This field is set to UNKNOWN if the alert has not yet been evaluated or ran into an error during the last evaluation."
          },
          "trigger_time": {
            "type": "string",
            "description": "Timestamp when the alert was last triggered, if the alert has been triggered before."
          },
          "update_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was updated."
          }
        }
      },
      "AlertCondition": {
        "type": "object",
        "properties": {
          "empty_result_state": {
            "$ref": "#/components/schemas/AlertState"
          },
          "op": {
            "$ref": "#/components/schemas/AlertOperator",
            "description": "Operator used for comparison in alert evaluation."
          },
          "operand": {
            "$ref": "#/components/schemas/AlertConditionOperand",
            "description": "Name of the column from the query result to use for comparison in alert evaluation."
          },
          "threshold": {
            "$ref": "#/components/schemas/AlertConditionThreshold",
            "description": "Threshold value used for comparison in alert evaluation."
          }
        }
      },
      "AlertConditionOperand": {
        "type": "object",
        "properties": {
          "column": {
            "$ref": "#/components/schemas/AlertOperandColumn"
          }
        }
      },
      "AlertConditionThreshold": {
        "type": "object",
        "properties": {
          "value": {
            "$ref": "#/components/schemas/AlertOperandValue"
          }
        }
      },
      "AlertOperandColumn": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "AlertOperandValue": {
        "type": "object",
        "properties": {
          "bool_value": {
            "type": "boolean"
          },
          "double_value": {
            "type": "number"
          },
          "string_value": {
            "type": "string"
          }
        }
      },
      "AlertOptions": {
        "type": "object",
        "properties": {
          "column": {
            "type": "string",
            "description": "Name of column in the query result to compare in alert evaluation."
          },
          "op": {
            "type": "string",
            "description": "Operator used to compare in alert evaluation: `>`, `>=`, `<`, `<=`, `==`, `!=`"
          },
          "value": {
            "type": "object",
            "description": "Value used to compare in alert evaluation. Supported types include strings (eg. 'foobar'), floats (eg. 123.4), and booleans (true)."
          },
          "custom_body": {
            "type": "string",
            "description": "Custom body of alert notification, if it exists. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "custom_subject": {
            "type": "string",
            "description": "Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "empty_result_state": {
            "$ref": "#/components/schemas/AlertOptionsEmptyResultState",
            "description": "State that alert evaluates to when query result is empty."
          },
          "muted": {
            "type": "boolean",
            "description": "Whether or not the alert is muted. If an alert is muted, it will not notify users and notification destinations when triggered."
          }
        },
        "required": [
          "column",
          "op",
          "value"
        ],
        "description": "Alert configuration options."
      },
      "AlertQuery": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "string"
          },
          "data_source_id": {
            "type": "string",
            "description": "Data source ID maps to the ID of the data source used by the resource and is distinct from the warehouse ID. [Learn more] [Learn more]: https://docs.databricks.com/api/workspace/datasources/list"
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "id": {
            "type": "string",
            "description": "Query ID."
          },
          "is_archived": {
            "type": "boolean",
            "description": "Indicates whether the query is trashed. Trashed queries can't be used in dashboards, or appear in search results. If this boolean is `true`, the `options` property for this query includes a `moved_to_trash_at` timestamp. Trashed queries are permanently deleted after 30 days."
          },
          "is_draft": {
            "type": "boolean",
            "description": "Whether the query is a draft. Draft queries only appear in list views for their owners. Visualizations from draft queries cannot appear on dashboards."
          },
          "is_safe": {
            "type": "boolean",
            "description": "Text parameter types are not safe from SQL injection for all types of data source. Set this Boolean parameter to `true` if a query either does not use any text type parameters or uses a data source type where text type parameters are handled safely."
          },
          "name": {
            "type": "string",
            "description": "The title of this query that appears in list views, widget headings, and on the query page."
          },
          "options": {
            "$ref": "#/components/schemas/QueryOptions"
          },
          "query": {
            "type": "string",
            "description": "The text of the query to be run."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "updated_at": {
            "type": "string",
            "description": "The timestamp at which this query was last updated."
          },
          "user_id": {
            "type": "integer",
            "description": "The ID of the user who owns the query."
          }
        }
      },
      "AlertV2": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string"
          },
          "query_text": {
            "type": "string",
            "description": "Text of the query to be run."
          },
          "warehouse_id": {
            "type": "string",
            "description": "ID of the SQL warehouse attached to the alert."
          },
          "evaluation": {
            "$ref": "#/components/schemas/AlertV2Evaluation"
          },
          "schedule": {
            "$ref": "#/components/schemas/CronSchedule"
          },
          "create_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was created."
          },
          "custom_description": {
            "type": "string",
            "description": "Custom description for the alert. support mustache template."
          },
          "custom_summary": {
            "type": "string",
            "description": "Custom summary for the alert. support mustache template."
          },
          "effective_run_as": {
            "$ref": "#/components/schemas/AlertV2RunAs",
            "description": "The actual identity that will be used to execute the alert. This is an output-only field that shows the resolved run-as identity after applying permissions and defaults."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the alert."
          },
          "lifecycle_state": {
            "$ref": "#/components/schemas/AlertLifecycleState",
            "description": "Indicates whether the query is trashed."
          },
          "owner_user_name": {
            "type": "string",
            "description": "The owner's username. This field is set to \"Unavailable\" if the user has been deleted."
          },
          "parent_path": {
            "type": "string",
            "description": "The workspace path of the folder containing the alert. Can only be set on create, and cannot be updated."
          },
          "run_as": {
            "$ref": "#/components/schemas/AlertV2RunAs",
            "description": "Specifies the identity that will be used to run the alert. This field allows you to configure alerts to run as a specific user or service principal. - For user identity: Set `user_name` to the email of an active workspace user. Users can only set this to their own email. - For service principal: Set `service_principal_name` to the application ID. Requires the `servicePrincipal/user` role. If not specified, the alert will run as the request user."
          },
          "run_as_user_name": {
            "type": "string",
            "description": "The run as username or application ID of service principal. On Create and Update, this field can be set to application ID of an active service principal. Setting this field requires the servicePrincipal/user role. Deprecated: Use `run_as` field instead. This field will be removed in a future release."
          },
          "update_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was updated."
          }
        },
        "required": [
          "display_name",
          "query_text",
          "warehouse_id",
          "evaluation",
          "schedule"
        ]
      },
      "AlertV2Evaluation": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/AlertV2OperandColumn"
          },
          "comparison_operator": {
            "$ref": "#/components/schemas/ComparisonOperator",
            "description": "Operator used for comparison in alert evaluation."
          },
          "empty_result_state": {
            "$ref": "#/components/schemas/AlertEvaluationState",
            "description": "Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated."
          },
          "last_evaluated_at": {
            "type": "string",
            "description": "Timestamp of the last evaluation."
          },
          "notification": {
            "$ref": "#/components/schemas/AlertV2Notification",
            "description": "User or Notification Destination to notify when alert is triggered."
          },
          "state": {
            "$ref": "#/components/schemas/AlertEvaluationState",
            "description": "Latest state of alert evaluation."
          },
          "threshold": {
            "$ref": "#/components/schemas/AlertV2Operand",
            "description": "Threshold to user for alert evaluation, can be a column or a value."
          }
        },
        "required": [
          "source",
          "comparison_operator"
        ]
      },
      "AlertV2Notification": {
        "type": "object",
        "properties": {
          "notify_on_ok": {
            "type": "boolean"
          },
          "retrigger_seconds": {
            "type": "integer",
            "description": "Number of seconds an alert waits after being triggered before it is allowed to send another notification. If set to 0 or omitted, the alert will not send any further notifications after the first trigger Setting this value to 1 allows the alert to send a notification on every evaluation where the condition is met, effectively making it always retrigger for notification purposes."
          },
          "subscriptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AlertV2Subscription"
            }
          }
        }
      },
      "AlertV2Operand": {
        "type": "object",
        "properties": {
          "column": {
            "$ref": "#/components/schemas/AlertV2OperandColumn"
          },
          "value": {
            "$ref": "#/components/schemas/AlertV2OperandValue"
          }
        }
      },
      "AlertV2OperandColumn": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "aggregation": {
            "$ref": "#/components/schemas/Aggregation",
            "description": "If not set, the behavior is equivalent to using `First row` in the UI."
          },
          "display": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "AlertV2OperandValue": {
        "type": "object",
        "properties": {
          "bool_value": {
            "type": "boolean"
          },
          "double_value": {
            "type": "number"
          },
          "string_value": {
            "type": "string"
          }
        }
      },
      "AlertV2RunAs": {
        "type": "object",
        "properties": {
          "service_principal_name": {
            "type": "string"
          },
          "user_name": {
            "type": "string",
            "description": "The email of an active workspace user. Can only set this field to their own email."
          }
        }
      },
      "AlertV2Subscription": {
        "type": "object",
        "properties": {
          "destination_id": {
            "type": "string"
          },
          "user_email": {
            "type": "string"
          }
        }
      },
      "BaseChunkInfo": {
        "type": "object",
        "properties": {
          "byte_count": {
            "type": "integer"
          },
          "chunk_index": {
            "type": "integer",
            "description": "The position within the sequence of result set chunks."
          },
          "row_count": {
            "type": "integer",
            "description": "The number of rows within the result chunk."
          },
          "row_offset": {
            "type": "integer",
            "description": "The starting row offset within the result set."
          }
        }
      },
      "Channel": {
        "type": "object",
        "properties": {
          "dbsql_version": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/ChannelName"
          }
        },
        "description": "Configures the channel name and DBSQL version of the warehouse. CHANNEL_NAME_CUSTOM should be\n    chosen only when `dbsql_version` is specified."
      },
      "ChannelInfo": {
        "type": "object",
        "properties": {
          "dbsql_version": {
            "type": "string",
            "description": "DB SQL Version the Channel is mapped to."
          },
          "name": {
            "$ref": "#/components/schemas/ChannelName",
            "description": "Name of the channel"
          }
        },
        "description": "Details about a Channel."
      },
      "ClientConfig": {
        "type": "object",
        "properties": {
          "allow_custom_js_visualizations": {
            "type": "boolean"
          },
          "allow_downloads": {
            "type": "boolean"
          },
          "allow_external_shares": {
            "type": "boolean"
          },
          "allow_subscriptions": {
            "type": "boolean"
          },
          "date_format": {
            "type": "string"
          },
          "date_time_format": {
            "type": "string"
          },
          "disable_publish": {
            "type": "boolean"
          },
          "enable_legacy_autodetect_types": {
            "type": "boolean"
          },
          "feature_show_permissions_control": {
            "type": "boolean"
          },
          "hide_plotly_mode_bar": {
            "type": "boolean"
          }
        }
      },
      "ColumnInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "position": {
            "type": "integer",
            "description": "The ordinal position of the column (starting at position 0)."
          },
          "type_interval_type": {
            "type": "string",
            "description": "The format of the interval type."
          },
          "type_name": {
            "$ref": "#/components/schemas/ColumnInfoTypeName",
            "description": "The name of the base data type. This doesn't include details for complex types such as STRUCT, MAP or ARRAY."
          },
          "type_precision": {
            "type": "integer",
            "description": "Specifies the number of digits in a number. This applies to the DECIMAL type."
          },
          "type_scale": {
            "type": "integer",
            "description": "Specifies the number of digits to the right of the decimal point in a number. This applies to the DECIMAL type."
          },
          "type_text": {
            "type": "string",
            "description": "The full SQL type specification."
          }
        }
      },
      "CreateAlertRequestAlert": {
        "type": "object",
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/AlertCondition"
          },
          "custom_body": {
            "type": "string",
            "description": "Custom body of alert notification, if it exists. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "custom_subject": {
            "type": "string",
            "description": "Custom subject of alert notification, if it exists. This can include email subject entries and Slack notification headers, for example. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "display_name": {
            "type": "string",
            "description": "The display name of the alert."
          },
          "notify_on_ok": {
            "type": "boolean",
            "description": "Whether to notify alert subscribers when alert returns back to normal."
          },
          "parent_path": {
            "type": "string",
            "description": "The workspace path of the folder containing the alert."
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query attached to the alert."
          },
          "seconds_to_retrigger": {
            "type": "integer",
            "description": "Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again."
          }
        }
      },
      "CreateQueryRequestQuery": {
        "type": "object",
        "properties": {
          "apply_auto_limit": {
            "type": "boolean"
          },
          "catalog": {
            "type": "string",
            "description": "Name of the catalog where this query will be executed."
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the query that appears in list views, widget headings, and on the query page."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryParameter"
            },
            "description": "List of query parameter definitions."
          },
          "parent_path": {
            "type": "string",
            "description": "Workspace path of the workspace folder containing the object."
          },
          "query_text": {
            "type": "string",
            "description": "Text of the query to be run."
          },
          "run_as_mode": {
            "$ref": "#/components/schemas/RunAsMode",
            "description": "Sets the \"Run as\" role for the object."
          },
          "schema": {
            "type": "string",
            "description": "Name of the schema where this query will be executed."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "warehouse_id": {
            "type": "string",
            "description": "ID of the SQL warehouse attached to the query."
          }
        }
      },
      "CreateVisualizationRequestVisualization": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string"
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query that the visualization is attached to."
          },
          "serialized_options": {
            "type": "string",
            "description": "The visualization options varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization options directly."
          },
          "serialized_query_plan": {
            "type": "string",
            "description": "The visualization query plan varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying the visualization query plan directly."
          },
          "type": {
            "type": "string",
            "description": "The type of visualization: counter, table, funnel, and so on."
          }
        }
      },
      "CreateWarehouseResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          }
        }
      },
      "CronSchedule": {
        "type": "object",
        "properties": {
          "quartz_cron_schedule": {
            "type": "string"
          },
          "timezone_id": {
            "type": "string",
            "description": "A Java timezone id. The schedule will be resolved using this timezone. This will be combined with the quartz_cron_schedule to determine the schedule. See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details."
          },
          "pause_status": {
            "$ref": "#/components/schemas/SchedulePauseStatus",
            "description": "Indicate whether this schedule is paused or not."
          }
        },
        "required": [
          "quartz_cron_schedule",
          "timezone_id"
        ]
      },
      "Dashboard": {
        "type": "object",
        "properties": {
          "can_edit": {
            "type": "boolean",
            "description": "Whether the authenticated user can edit the query definition."
          },
          "created_at": {
            "type": "string",
            "description": "Timestamp when this dashboard was created."
          },
          "dashboard_filters_enabled": {
            "type": "boolean",
            "description": "In the web application, query filters that share a name are coupled to a single selection box if this value is `true`."
          },
          "id": {
            "type": "string",
            "description": "The ID for this dashboard."
          },
          "is_archived": {
            "type": "boolean",
            "description": "Indicates whether a dashboard is trashed. Trashed dashboards won't appear in list views. If this boolean is `true`, the `options` property for this dashboard includes a `moved_to_trash_at` timestamp. Items in trash are permanently deleted after 30 days."
          },
          "is_draft": {
            "type": "boolean",
            "description": "Whether a dashboard is a draft. Draft dashboards only appear in list views for their owners."
          },
          "is_favorite": {
            "type": "boolean",
            "description": "Indicates whether this query object appears in the current user's favorites list. This flag determines whether the star icon for favorites is selected."
          },
          "name": {
            "type": "string",
            "description": "The title of the dashboard that appears in list views and at the top of the dashboard page."
          },
          "options": {
            "$ref": "#/components/schemas/DashboardOptions"
          },
          "parent": {
            "type": "string",
            "description": "The identifier of the workspace folder containing the object."
          },
          "permission_tier": {
            "$ref": "#/components/schemas/PermissionLevel",
            "description": "* `CAN_VIEW`: Can view the query * `CAN_RUN`: Can run the query * `CAN_EDIT`: Can edit the query * `CAN_MANAGE`: Can manage the query"
          },
          "slug": {
            "type": "string",
            "description": "URL slug. Usually mirrors the query name with dashes (`-`) instead of spaces. Appears in the URL for this query."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "updated_at": {
            "type": "string",
            "description": "Timestamp when this dashboard was last updated."
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "user_id": {
            "type": "integer",
            "description": "The ID of the user who owns the dashboard."
          },
          "widgets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Widget"
            }
          }
        },
        "description": "A JSON representing a dashboard containing widgets of visualizations and text boxes."
      },
      "DashboardOptions": {
        "type": "object",
        "properties": {
          "moved_to_trash_at": {
            "type": "string"
          }
        }
      },
      "DataSource": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Data source ID maps to the ID of the data source used by the resource and is distinct from the warehouse ID. [Learn more] [Learn more]: https://docs.databricks.com/api/workspace/datasources/list"
          },
          "name": {
            "type": "string",
            "description": "The string name of this data source / SQL warehouse as it appears in the Databricks SQL web application."
          },
          "pause_reason": {
            "type": "string",
            "description": "Reserved for internal use."
          },
          "paused": {
            "type": "integer",
            "description": "Reserved for internal use."
          },
          "supports_auto_limit": {
            "type": "boolean",
            "description": "Reserved for internal use."
          },
          "syntax": {
            "type": "string",
            "description": "Reserved for internal use."
          },
          "type": {
            "type": "string",
            "description": "The type of data source. For SQL warehouses, this will be `databricks_internal`."
          },
          "view_only": {
            "type": "boolean",
            "description": "Reserved for internal use."
          },
          "warehouse_id": {
            "type": "string",
            "description": "The ID of the associated SQL warehouse, if this data source is backed by a SQL warehouse."
          }
        },
        "description": "A JSON object representing a DBSQL data source / SQL warehouse."
      },
      "DateRange": {
        "type": "object",
        "properties": {
          "start": {
            "type": "string"
          },
          "end": {
            "type": "string"
          }
        },
        "required": [
          "start",
          "end"
        ]
      },
      "DateRangeValue": {
        "type": "object",
        "properties": {
          "date_range_value": {
            "$ref": "#/components/schemas/DateRange"
          },
          "dynamic_date_range_value": {
            "$ref": "#/components/schemas/DateRangeValueDynamicDateRange",
            "description": "Dynamic date-time range value based on current date-time."
          },
          "precision": {
            "$ref": "#/components/schemas/DatePrecision",
            "description": "Date-time precision to format the value into when the query is run. Defaults to DAY_PRECISION (YYYY-MM-DD)."
          },
          "start_day_of_week": {
            "type": "integer"
          }
        }
      },
      "DateValue": {
        "type": "object",
        "properties": {
          "date_value": {
            "type": "string"
          },
          "dynamic_date_value": {
            "$ref": "#/components/schemas/DateValueDynamicDate",
            "description": "Dynamic date-time value based on current date-time."
          },
          "precision": {
            "$ref": "#/components/schemas/DatePrecision",
            "description": "Date-time precision to format the value into when the query is run. Defaults to DAY_PRECISION (YYYY-MM-DD)."
          }
        }
      },
      "DefaultWarehouseOverride": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/DefaultWarehouseOverrideType",
            "description": "The type of override behavior."
          },
          "default_warehouse_override_id": {
            "type": "string",
            "description": "The ID component of the resource name (user ID)."
          },
          "name": {
            "type": "string",
            "description": "The resource name of the default warehouse override. Format: default-warehouse-overrides/{default_warehouse_override_id}"
          },
          "warehouse_id": {
            "type": "string",
            "description": "The specific warehouse ID when type is CUSTOM. Not set for LAST_SELECTED type."
          }
        },
        "required": [
          "type"
        ],
        "description": "Represents a per-user default warehouse override configuration. This resource allows users or\n    administrators to customize how a user's default warehouse is selected for SQL operations. If no\n    override exists for a user, the workspace default warehouse will be used."
      },
      "DeleteResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteWarehouseResponse": {
        "type": "object",
        "properties": {}
      },
      "EditWarehouseResponse": {
        "type": "object",
        "properties": {}
      },
      "Empty": {
        "type": "object",
        "properties": {},
        "description": "Represents an empty message, similar to google.protobuf.Empty, which is not available in the\n    firm right now."
      },
      "EndpointConfPair": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "EndpointHealth": {
        "type": "object",
        "properties": {
          "details": {
            "type": "string"
          },
          "failure_reason": {
            "$ref": "#/components/schemas/TerminationReason",
            "description": "The reason for failure to bring up clusters for this warehouse. This is available when status is 'FAILED' and sometimes when it is DEGRADED."
          },
          "message": {
            "type": "string",
            "description": "Deprecated. split into summary and details for security"
          },
          "status": {
            "$ref": "#/components/schemas/Status",
            "description": "Health status of the endpoint."
          },
          "summary": {
            "type": "string",
            "description": "A short summary of the health status in case of degraded/failed warehouses."
          }
        }
      },
      "EndpointInfo": {
        "type": "object",
        "properties": {
          "auto_stop_mins": {
            "type": "integer"
          },
          "channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "Channel Details"
          },
          "cluster_size": {
            "type": "string",
            "description": "Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you to run larger queries on it. If you want to increase the number of concurrent queries, please tune max_num_clusters. Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large - 4X-Large"
          },
          "creator_name": {
            "type": "string",
            "description": "warehouse creator name"
          },
          "enable_photon": {
            "type": "boolean",
            "description": "Configures whether the warehouse should use Photon optimized clusters. Defaults to false."
          },
          "enable_serverless_compute": {
            "type": "boolean",
            "description": "Configures whether the warehouse should use serverless compute"
          },
          "health": {
            "$ref": "#/components/schemas/EndpointHealth",
            "description": "Optional health status. Assume the warehouse is healthy if this field is not set."
          },
          "id": {
            "type": "string",
            "description": "unique identifier for warehouse"
          },
          "instance_profile_arn": {
            "type": "string",
            "description": "Deprecated. Instance profile used to pass IAM role to the cluster"
          },
          "jdbc_url": {
            "type": "string",
            "description": "the jdbc connection string for this warehouse"
          },
          "max_num_clusters": {
            "type": "integer",
            "description": "Maximum number of clusters that the autoscaler will create to handle concurrent queries. Supported values: - Must be >= min_num_clusters - Must be <= 40. Defaults to min_clusters if unset."
          },
          "min_num_clusters": {
            "type": "integer",
            "description": "Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this will ensure that a larger number of clusters are always running and therefore may reduce the cold start time for new queries. This is similar to reserved vs. revocable cores in a resource manager. Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30) Defaults to 1"
          },
          "name": {
            "type": "string",
            "description": "Logical name for the cluster. Supported values: - Must be unique within an org. - Must be less than 100 characters."
          },
          "num_active_sessions": {
            "type": "integer",
            "description": "Deprecated. current number of active sessions for the warehouse"
          },
          "num_clusters": {
            "type": "integer",
            "description": "current number of clusters running for the service"
          },
          "odbc_params": {
            "$ref": "#/components/schemas/OdbcParams",
            "description": "ODBC parameters for the SQL warehouse"
          },
          "spot_instance_policy": {
            "$ref": "#/components/schemas/SpotInstancePolicy",
            "description": "Configurations whether the endpoint should use spot instances."
          },
          "state": {
            "$ref": "#/components/schemas/State",
            "description": "state of the endpoint"
          },
          "tags": {
            "$ref": "#/components/schemas/EndpointTags",
            "description": "A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes) associated with this SQL warehouse. Supported values: - Number of tags < 45."
          },
          "warehouse_type": {
            "$ref": "#/components/schemas/EndpointInfoWarehouseType",
            "description": "Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`."
          }
        }
      },
      "EndpointTagPair": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "EndpointTags": {
        "type": "object",
        "properties": {
          "custom_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EndpointTagPair"
            }
          }
        }
      },
      "EnumValue": {
        "type": "object",
        "properties": {
          "enum_options": {
            "type": "string"
          },
          "multi_values_options": {
            "$ref": "#/components/schemas/MultiValuesOptions",
            "description": "If specified, allows multiple values to be selected for this parameter."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of selected query parameter values."
          }
        }
      },
      "ExternalLink": {
        "type": "object",
        "properties": {
          "byte_count": {
            "type": "integer"
          },
          "chunk_index": {
            "type": "integer",
            "description": "The position within the sequence of result set chunks."
          },
          "expiration": {
            "type": "string",
            "description": "Indicates the date-time that the given external link will expire and becomes invalid, after which point a new `external_link` must be requested."
          },
          "external_link": {
            "type": "string",
            "description": "A URL pointing to a chunk of result data, hosted by an external service, with a short expiration time (<= 15 minutes). As this URL contains a temporary credential, it should be considered sensitive and the client should not expose this URL in a log."
          },
          "http_headers": {
            "type": "object",
            "description": "HTTP headers that must be included with a GET request to the `external_link`. Each header is provided as a key-value pair. Headers are typically used to pass a decryption key to the external service. The values of these headers should be considered sensitive and the client should not expose these values in a log."
          },
          "next_chunk_index": {
            "type": "integer",
            "description": "When fetching, provides the `chunk_index` for the _next_ chunk. If absent, indicates there are no more chunks. The next chunk can be fetched with a :method:statementexecution/getstatementresultchunkn request."
          },
          "next_chunk_internal_link": {
            "type": "string",
            "description": "When fetching, provides a link to fetch the _next_ chunk. If absent, indicates there are no more chunks. This link is an absolute `path` to be joined with your `$DATABRICKS_HOST`, and should be treated as an opaque link. This is an alternative to using `next_chunk_index`."
          },
          "row_count": {
            "type": "integer",
            "description": "The number of rows within the result chunk."
          },
          "row_offset": {
            "type": "integer",
            "description": "The starting row offset within the result set."
          }
        }
      },
      "ExternalQuerySource": {
        "type": "object",
        "properties": {
          "alert_id": {
            "type": "string"
          },
          "dashboard_id": {
            "type": "string",
            "description": "The canonical identifier for this Lakeview dashboard"
          },
          "genie_space_id": {
            "type": "string",
            "description": "The canonical identifier for this Genie space"
          },
          "job_info": {
            "$ref": "#/components/schemas/ExternalQuerySourceJobInfo"
          },
          "legacy_dashboard_id": {
            "type": "string",
            "description": "The canonical identifier for this legacy dashboard"
          },
          "notebook_id": {
            "type": "string",
            "description": "The canonical identifier for this notebook"
          },
          "sql_query_id": {
            "type": "string",
            "description": "The canonical identifier for this SQL query"
          }
        }
      },
      "ExternalQuerySourceJobInfo": {
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "job_run_id": {
            "type": "string",
            "description": "The canonical identifier of the run. This ID is unique across all runs of all jobs."
          },
          "job_task_run_id": {
            "type": "string",
            "description": "The canonical identifier of the task run."
          }
        }
      },
      "GetResponse": {
        "type": "object",
        "properties": {
          "access_control_list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControl"
            }
          },
          "object_id": {
            "type": "string",
            "description": "An object's type and UUID, separated by a forward slash (/) character."
          },
          "object_type": {
            "$ref": "#/components/schemas/ObjectType",
            "description": "A singular noun object type."
          }
        }
      },
      "GetWarehousePermissionLevelsResponse": {
        "type": "object",
        "properties": {
          "permission_levels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WarehousePermissionsDescription"
            }
          }
        }
      },
      "GetWarehouseResponse": {
        "type": "object",
        "properties": {
          "auto_stop_mins": {
            "type": "integer"
          },
          "channel": {
            "$ref": "#/components/schemas/Channel",
            "description": "Channel Details"
          },
          "cluster_size": {
            "type": "string",
            "description": "Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you to run larger queries on it. If you want to increase the number of concurrent queries, please tune max_num_clusters. Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large - 4X-Large"
          },
          "creator_name": {
            "type": "string",
            "description": "warehouse creator name"
          },
          "enable_photon": {
            "type": "boolean",
            "description": "Configures whether the warehouse should use Photon optimized clusters. Defaults to false."
          },
          "enable_serverless_compute": {
            "type": "boolean",
            "description": "Configures whether the warehouse should use serverless compute"
          },
          "health": {
            "$ref": "#/components/schemas/EndpointHealth",
            "description": "Optional health status. Assume the warehouse is healthy if this field is not set."
          },
          "id": {
            "type": "string",
            "description": "unique identifier for warehouse"
          },
          "instance_profile_arn": {
            "type": "string",
            "description": "Deprecated. Instance profile used to pass IAM role to the cluster"
          },
          "jdbc_url": {
            "type": "string",
            "description": "the jdbc connection string for this warehouse"
          },
          "max_num_clusters": {
            "type": "integer",
            "description": "Maximum number of clusters that the autoscaler will create to handle concurrent queries. Supported values: - Must be >= min_num_clusters - Must be <= 40. Defaults to min_clusters if unset."
          },
          "min_num_clusters": {
            "type": "integer",
            "description": "Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this will ensure that a larger number of clusters are always running and therefore may reduce the cold start time for new queries. This is similar to reserved vs. revocable cores in a resource manager. Supported values: - Must be > 0 - Must be <= min(max_num_clusters, 30) Defaults to 1"
          },
          "name": {
            "type": "string",
            "description": "Logical name for the cluster. Supported values: - Must be unique within an org. - Must be less than 100 characters."
          },
          "num_active_sessions": {
            "type": "integer",
            "description": "Deprecated. current number of active sessions for the warehouse"
          },
          "num_clusters": {
            "type": "integer",
            "description": "current number of clusters running for the service"
          },
          "odbc_params": {
            "$ref": "#/components/schemas/OdbcParams",
            "description": "ODBC parameters for the SQL warehouse"
          },
          "spot_instance_policy": {
            "$ref": "#/components/schemas/SpotInstancePolicy",
            "description": "Configurations whether the endpoint should use spot instances."
          },
          "state": {
            "$ref": "#/components/schemas/State",
            "description": "state of the endpoint"
          },
          "tags": {
            "$ref": "#/components/schemas/EndpointTags",
            "description": "A set of key-value pairs that will be tagged on all resources (e.g., AWS instances and EBS volumes) associated with this SQL warehouse. Supported values: - Number of tags < 45."
          },
          "warehouse_type": {
            "$ref": "#/components/schemas/GetWarehouseResponseWarehouseType",
            "description": "Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`."
          }
        }
      },
      "GetWorkspaceWarehouseConfigResponse": {
        "type": "object",
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/Channel"
          },
          "config_param": {
            "$ref": "#/components/schemas/RepeatedEndpointConfPairs",
            "description": "Deprecated: Use sql_configuration_parameters"
          },
          "data_access_config": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EndpointConfPair"
            },
            "description": "Spark confs for external hive metastore configuration JSON serialized size must be less than <= 512K"
          },
          "enable_serverless_compute": {
            "type": "boolean",
            "description": "Enable Serverless compute for SQL warehouses"
          },
          "enabled_warehouse_types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WarehouseTypePair"
            },
            "description": "List of Warehouse Types allowed in this workspace (limits allowed value of the type field in CreateWarehouse and EditWarehouse). Note: Some types cannot be disabled, they don't need to be specified in SetWorkspaceWarehouseConfig. Note: Disabling a type may cause existing warehouses to be converted to another type. Used by frontend to save specific type availability in the warehouse create and edit form UI."
          },
          "global_param": {
            "$ref": "#/components/schemas/RepeatedEndpointConfPairs",
            "description": "Deprecated: Use sql_configuration_parameters"
          },
          "google_service_account": {
            "type": "string",
            "description": "GCP only: Google Service Account used to pass to cluster to access Google Cloud Storage"
          },
          "instance_profile_arn": {
            "type": "string",
            "description": "AWS Only: The instance profile used to pass an IAM role to the SQL warehouses. This configuration is also applied to the workspace's serverless compute for notebooks and jobs."
          },
          "security_policy": {
            "$ref": "#/components/schemas/GetWorkspaceWarehouseConfigResponseSecurityPolicy",
            "description": "Security policy for warehouses"
          },
          "sql_configuration_parameters": {
            "$ref": "#/components/schemas/RepeatedEndpointConfPairs",
            "description": "SQL configuration parameters"
          }
        }
      },
      "LegacyAlert": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "Alert ID."
          },
          "last_triggered_at": {
            "type": "string",
            "description": "Timestamp when the alert was last triggered."
          },
          "name": {
            "type": "string",
            "description": "Name of the alert."
          },
          "options": {
            "$ref": "#/components/schemas/AlertOptions",
            "description": "Alert configuration options."
          },
          "parent": {
            "type": "string",
            "description": "The identifier of the workspace folder containing the object."
          },
          "query": {
            "$ref": "#/components/schemas/AlertQuery"
          },
          "rearm": {
            "type": "integer",
            "description": "Number of seconds after being triggered before the alert rearms itself and can be triggered again. If `null`, alert will never be triggered again."
          },
          "state": {
            "$ref": "#/components/schemas/LegacyAlertState",
            "description": "State of the alert. Possible values are: `unknown` (yet to be evaluated), `triggered` (evaluated and fulfilled trigger conditions), or `ok` (evaluated and did not fulfill trigger conditions)."
          },
          "updated_at": {
            "type": "string",
            "description": "Timestamp when the alert was last updated."
          },
          "user": {
            "$ref": "#/components/schemas/User"
          }
        }
      },
      "LegacyQuery": {
        "type": "object",
        "properties": {
          "can_edit": {
            "type": "boolean"
          },
          "created_at": {
            "type": "string",
            "description": "The timestamp when this query was created."
          },
          "data_source_id": {
            "type": "string",
            "description": "Data source ID maps to the ID of the data source used by the resource and is distinct from the warehouse ID. [Learn more] [Learn more]: https://docs.databricks.com/api/workspace/datasources/list"
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "id": {
            "type": "string",
            "description": "Query ID."
          },
          "is_archived": {
            "type": "boolean",
            "description": "Indicates whether the query is trashed. Trashed queries can't be used in dashboards, or appear in search results. If this boolean is `true`, the `options` property for this query includes a `moved_to_trash_at` timestamp. Trashed queries are permanently deleted after 30 days."
          },
          "is_draft": {
            "type": "boolean",
            "description": "Whether the query is a draft. Draft queries only appear in list views for their owners. Visualizations from draft queries cannot appear on dashboards."
          },
          "is_favorite": {
            "type": "boolean",
            "description": "Whether this query object appears in the current user's favorites list. This flag determines whether the star icon for favorites is selected."
          },
          "is_safe": {
            "type": "boolean",
            "description": "Text parameter types are not safe from SQL injection for all types of data source. Set this Boolean parameter to `true` if a query either does not use any text type parameters or uses a data source type where text type parameters are handled safely."
          },
          "last_modified_by": {
            "$ref": "#/components/schemas/User"
          },
          "last_modified_by_id": {
            "type": "integer",
            "description": "The ID of the user who last saved changes to this query."
          },
          "latest_query_data_id": {
            "type": "string",
            "description": "If there is a cached result for this query and user, this field includes the query result ID. If this query uses parameters, this field is always null."
          },
          "name": {
            "type": "string",
            "description": "The title of this query that appears in list views, widget headings, and on the query page."
          },
          "options": {
            "$ref": "#/components/schemas/QueryOptions"
          },
          "parent": {
            "type": "string",
            "description": "The identifier of the workspace folder containing the object."
          },
          "permission_tier": {
            "$ref": "#/components/schemas/PermissionLevel",
            "description": "* `CAN_VIEW`: Can view the query * `CAN_RUN`: Can run the query * `CAN_EDIT`: Can edit the query * `CAN_MANAGE`: Can manage the query"
          },
          "query": {
            "type": "string",
            "description": "The text of the query to be run."
          },
          "query_hash": {
            "type": "string",
            "description": "A SHA-256 hash of the query text along with the authenticated user ID."
          },
          "run_as_role": {
            "$ref": "#/components/schemas/RunAsRole",
            "description": "Sets the **Run as** role for the object. Must be set to one of `\"viewer\"` (signifying \"run as viewer\" behavior) or `\"owner\"` (signifying \"run as owner\" behavior)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "updated_at": {
            "type": "string",
            "description": "The timestamp at which this query was last updated."
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "user_id": {
            "type": "integer",
            "description": "The ID of the user who owns the query."
          },
          "visualizations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LegacyVisualization"
            }
          }
        }
      },
      "LegacyVisualization": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "description": "A short description of this visualization. This is not displayed in the UI."
          },
          "id": {
            "type": "string",
            "description": "The UUID for this visualization."
          },
          "name": {
            "type": "string",
            "description": "The name of the visualization that appears on dashboards and the query screen."
          },
          "options": {
            "type": "object",
            "description": "The options object varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization settings in JSON."
          },
          "query": {
            "$ref": "#/components/schemas/LegacyQuery"
          },
          "type": {
            "type": "string",
            "description": "The type of visualization: chart, table, pivot table, and so on."
          },
          "updated_at": {
            "type": "string"
          }
        },
        "description": "The visualization description API changes frequently and is unsupported. You can duplicate a\n    visualization by copying description objects received _from the API_ and then using them to\n    create a new one with a POST request to the same endpoint. Databricks does not recommend\n    constructing ad-hoc visualizations entirely in JSON."
      },
      "ListAlertsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ListAlertsResponseAlert"
            }
          }
        }
      },
      "ListAlertsResponseAlert": {
        "type": "object",
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/AlertCondition"
          },
          "create_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was created."
          },
          "custom_body": {
            "type": "string",
            "description": "Custom body of alert notification, if it exists. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "custom_subject": {
            "type": "string",
            "description": "Custom subject of alert notification, if it exists. This can include email subject entries and Slack notification headers, for example. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "display_name": {
            "type": "string",
            "description": "The display name of the alert."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the alert."
          },
          "lifecycle_state": {
            "$ref": "#/components/schemas/LifecycleState",
            "description": "The workspace state of the alert. Used for tracking trashed status."
          },
          "notify_on_ok": {
            "type": "boolean",
            "description": "Whether to notify alert subscribers when alert returns back to normal."
          },
          "owner_user_name": {
            "type": "string",
            "description": "The owner's username. This field is set to \"Unavailable\" if the user has been deleted."
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query attached to the alert."
          },
          "seconds_to_retrigger": {
            "type": "integer",
            "description": "Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again."
          },
          "state": {
            "$ref": "#/components/schemas/AlertState",
            "description": "Current state of the alert's trigger status. This field is set to UNKNOWN if the alert has not yet been evaluated or ran into an error during the last evaluation."
          },
          "trigger_time": {
            "type": "string",
            "description": "Timestamp when the alert was last triggered, if the alert has been triggered before."
          },
          "update_time": {
            "type": "string",
            "description": "The timestamp indicating when the alert was updated."
          }
        }
      },
      "ListAlertsV2Response": {
        "type": "object",
        "properties": {
          "alerts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AlertV2"
            }
          },
          "next_page_token": {
            "type": "string"
          }
        }
      },
      "ListDefaultWarehouseOverridesResponse": {
        "type": "object",
        "properties": {
          "default_warehouse_overrides": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DefaultWarehouseOverride"
            },
            "description": "The default warehouse overrides in the workspace."
          },
          "next_page_token": {
            "type": "string",
            "description": "A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages."
          }
        },
        "description": "Response message for ListDefaultWarehouseOverrides."
      },
      "ListQueriesResponse": {
        "type": "object",
        "properties": {
          "has_next_page": {
            "type": "boolean"
          },
          "next_page_token": {
            "type": "string",
            "description": "A token that can be used to get the next page of results."
          },
          "res": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryInfo"
            }
          }
        }
      },
      "ListQueryObjectsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ListQueryObjectsResponseQuery"
            }
          }
        }
      },
      "ListQueryObjectsResponseQuery": {
        "type": "object",
        "properties": {
          "apply_auto_limit": {
            "type": "boolean"
          },
          "catalog": {
            "type": "string",
            "description": "Name of the catalog where this query will be executed."
          },
          "create_time": {
            "type": "string",
            "description": "Timestamp when this query was created."
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the query that appears in list views, widget headings, and on the query page."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the query."
          },
          "last_modifier_user_name": {
            "type": "string",
            "description": "Username of the user who last saved changes to this query."
          },
          "lifecycle_state": {
            "$ref": "#/components/schemas/LifecycleState",
            "description": "Indicates whether the query is trashed."
          },
          "owner_user_name": {
            "type": "string",
            "description": "Username of the user that owns the query."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryParameter"
            },
            "description": "List of query parameter definitions."
          },
          "query_text": {
            "type": "string",
            "description": "Text of the query to be run."
          },
          "run_as_mode": {
            "$ref": "#/components/schemas/RunAsMode",
            "description": "Sets the \"Run as\" role for the object."
          },
          "schema": {
            "type": "string",
            "description": "Name of the schema where this query will be executed."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "update_time": {
            "type": "string",
            "description": "Timestamp when this query was last updated."
          },
          "warehouse_id": {
            "type": "string",
            "description": "ID of the SQL warehouse attached to the query."
          }
        }
      },
      "ListResponse": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer"
          },
          "page": {
            "type": "integer",
            "description": "The current page being displayed."
          },
          "page_size": {
            "type": "integer",
            "description": "The number of dashboards per page."
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Dashboard"
            },
            "description": "List of dashboards returned."
          }
        }
      },
      "ListVisualizationsForQueryResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Visualization"
            }
          }
        }
      },
      "ListWarehousesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "warehouses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EndpointInfo"
            },
            "description": "A list of warehouses and their configurations."
          }
        }
      },
      "MultiValuesOptions": {
        "type": "object",
        "properties": {
          "prefix": {
            "type": "string"
          },
          "separator": {
            "type": "string",
            "description": "Character that separates each selected parameter value. Defaults to a comma."
          },
          "suffix": {
            "type": "string",
            "description": "Character that suffixes each selected parameter value."
          }
        }
      },
      "NumericValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number"
          }
        }
      },
      "OdbcParams": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "port": {
            "type": "integer"
          },
          "protocol": {
            "type": "string"
          }
        }
      },
      "Parameter": {
        "type": "object",
        "properties": {
          "enum_options": {
            "type": "string"
          },
          "multi_values_options": {
            "$ref": "#/components/schemas/MultiValuesOptions",
            "description": "If specified, allows multiple values to be selected for this parameter. Only applies to dropdown list and query-based dropdown list parameters."
          },
          "name": {
            "type": "string",
            "description": "The literal parameter marker that appears between double curly braces in the query text."
          },
          "query_id": {
            "type": "string",
            "description": "The UUID of the query that provides the parameter values. Only applies for query-based dropdown list parameters."
          },
          "title": {
            "type": "string",
            "description": "The text displayed in a parameter picking widget."
          },
          "type": {
            "$ref": "#/components/schemas/ParameterType",
            "description": "Parameters can have several different types."
          },
          "value": {
            "type": "object",
            "description": "The default value for this parameter."
          }
        }
      },
      "Query": {
        "type": "object",
        "properties": {
          "apply_auto_limit": {
            "type": "boolean"
          },
          "catalog": {
            "type": "string",
            "description": "Name of the catalog where this query will be executed."
          },
          "create_time": {
            "type": "string",
            "description": "Timestamp when this query was created."
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the query that appears in list views, widget headings, and on the query page."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the query."
          },
          "last_modifier_user_name": {
            "type": "string",
            "description": "Username of the user who last saved changes to this query."
          },
          "lifecycle_state": {
            "$ref": "#/components/schemas/LifecycleState",
            "description": "Indicates whether the query is trashed."
          },
          "owner_user_name": {
            "type": "string",
            "description": "Username of the user that owns the query."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryParameter"
            },
            "description": "List of query parameter definitions."
          },
          "parent_path": {
            "type": "string",
            "description": "Workspace path of the workspace folder containing the object."
          },
          "query_text": {
            "type": "string",
            "description": "Text of the query to be run."
          },
          "run_as_mode": {
            "$ref": "#/components/schemas/RunAsMode",
            "description": "Sets the \"Run as\" role for the object."
          },
          "schema": {
            "type": "string",
            "description": "Name of the schema where this query will be executed."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "update_time": {
            "type": "string",
            "description": "Timestamp when this query was last updated."
          },
          "warehouse_id": {
            "type": "string",
            "description": "ID of the SQL warehouse attached to the query."
          }
        }
      },
      "QueryBackedValue": {
        "type": "object",
        "properties": {
          "multi_values_options": {
            "$ref": "#/components/schemas/MultiValuesOptions"
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query that provides the parameter values."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of selected query parameter values."
          }
        }
      },
      "QueryFilter": {
        "type": "object",
        "properties": {
          "query_start_time_range": {
            "$ref": "#/components/schemas/TimeRange"
          },
          "statement_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of statement IDs."
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryStatus"
            },
            "description": "A list of statuses (QUEUED, RUNNING, CANCELED, FAILED, FINISHED) to match query results. Corresponds to the `status` field in the response. Filtering for multiple statuses is not recommended. Instead, opt to filter by a single status multiple times and then combine the results."
          },
          "user_ids": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "A list of user IDs who ran the queries."
          },
          "warehouse_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of warehouse IDs."
          }
        }
      },
      "QueryInfo": {
        "type": "object",
        "properties": {
          "cache_query_id": {
            "type": "string"
          },
          "channel_used": {
            "$ref": "#/components/schemas/ChannelInfo",
            "description": "SQL Warehouse channel information at the time of query execution"
          },
          "client_application": {
            "type": "string",
            "description": "Client application that ran the statement. For example: Databricks SQL Editor, Tableau, and Power BI. This field is derived from information provided by client applications. While values are expected to remain static over time, this cannot be guaranteed."
          },
          "duration": {
            "type": "integer",
            "description": "Total time of the statement execution. This value does not include the time taken to retrieve the results, which can result in a discrepancy between this value and the start-to-finish wall-clock time."
          },
          "endpoint_id": {
            "type": "string",
            "description": "Alias for `warehouse_id`."
          },
          "error_message": {
            "type": "string",
            "description": "Message describing why the query could not complete."
          },
          "executed_as_user_id": {
            "type": "integer",
            "description": "The ID of the user whose credentials were used to run the query."
          },
          "executed_as_user_name": {
            "type": "string",
            "description": "The email address or username of the user whose credentials were used to run the query."
          },
          "execution_end_time_ms": {
            "type": "integer",
            "description": "The time execution of the query ended."
          },
          "is_final": {
            "type": "boolean",
            "description": "Whether more updates for the query are expected."
          },
          "lookup_key": {
            "type": "string",
            "description": "A key that can be used to look up query details."
          },
          "metrics": {
            "$ref": "#/components/schemas/QueryMetrics",
            "description": "Metrics about query execution."
          },
          "plans_state": {
            "$ref": "#/components/schemas/PlansState",
            "description": "Whether plans exist for the execution, or the reason why they are missing"
          },
          "query_end_time_ms": {
            "type": "integer",
            "description": "The time the query ended."
          },
          "query_id": {
            "type": "string",
            "description": "The query ID."
          },
          "query_source": {
            "$ref": "#/components/schemas/ExternalQuerySource",
            "description": "A struct that contains key-value pairs representing Databricks entities that were involved in the execution of this statement, such as jobs, notebooks, or dashboards. This field only records Databricks entities."
          },
          "query_start_time_ms": {
            "type": "integer",
            "description": "The time the query started."
          },
          "query_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryTag"
            },
            "description": "A query execution can be optionally annotated with query tags"
          },
          "query_text": {
            "type": "string",
            "description": "The text of the query."
          },
          "rows_produced": {
            "type": "integer",
            "description": "The number of results returned by the query."
          },
          "session_id": {
            "type": "string",
            "description": "The spark session UUID that query ran on. This is either the Spark Connect, DBSQL, or SDP session ID."
          },
          "spark_ui_url": {
            "type": "string",
            "description": "URL to the Spark UI query plan."
          },
          "statement_type": {
            "$ref": "#/components/schemas/QueryStatementType",
            "description": "Type of statement for this query"
          },
          "status": {
            "$ref": "#/components/schemas/QueryStatus",
            "description": "Query status with one the following values: - `QUEUED`: Query has been received and queued. - `RUNNING`: Query has started. - `CANCELED`: Query has been cancelled by the user. - `FAILED`: Query has failed. - `FINISHED`: Query has completed."
          },
          "user_id": {
            "type": "integer",
            "description": "The ID of the user who ran the query."
          },
          "user_name": {
            "type": "string",
            "description": "The email address or username of the user who ran the query."
          },
          "warehouse_id": {
            "type": "string",
            "description": "Warehouse ID."
          }
        }
      },
      "QueryList": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer"
          },
          "page": {
            "type": "integer",
            "description": "The page number that is currently displayed."
          },
          "page_size": {
            "type": "integer",
            "description": "The number of queries per page."
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LegacyQuery"
            },
            "description": "List of queries returned."
          }
        }
      },
      "QueryMetrics": {
        "type": "object",
        "properties": {
          "compilation_time_ms": {
            "type": "integer",
            "description": "Time spent loading metadata and optimizing the query, in milliseconds."
          },
          "execution_time_ms": {
            "type": "integer",
            "description": "Time spent executing the query, in milliseconds."
          },
          "network_sent_bytes": {
            "type": "integer",
            "description": "Total amount of data sent over the network between executor nodes during shuffle, in bytes."
          },
          "overloading_queue_start_timestamp": {
            "type": "integer",
            "description": "Timestamp of when the query was enqueued waiting while the warehouse was at max load. This field is optional and will not appear if the query skipped the overloading queue."
          },
          "photon_total_time_ms": {
            "type": "integer",
            "description": "Total execution time for all individual Photon query engine tasks in the query, in milliseconds."
          },
          "projected_remaining_task_total_time_ms": {
            "type": "integer",
            "description": "projected remaining work to be done aggregated across all stages in the query, in milliseconds"
          },
          "projected_remaining_wallclock_time_ms": {
            "type": "integer",
            "description": "projected lower bound on remaining total task time based on projected_remaining_task_total_time_ms / maximum concurrency"
          },
          "provisioning_queue_start_timestamp": {
            "type": "integer",
            "description": "Timestamp of when the query was enqueued waiting for a cluster to be provisioned for the warehouse. This field is optional and will not appear if the query skipped the provisioning queue."
          },
          "pruned_bytes": {
            "type": "integer",
            "description": "Total number of file bytes in all tables not read due to pruning"
          },
          "pruned_files_count": {
            "type": "integer",
            "description": "Total number of files from all tables not read due to pruning"
          },
          "query_compilation_start_timestamp": {
            "type": "integer",
            "description": "Timestamp of when the underlying compute started compilation of the query."
          },
          "read_bytes": {
            "type": "integer",
            "description": "Total size of data read by the query, in bytes."
          },
          "read_cache_bytes": {
            "type": "integer",
            "description": "Size of persistent data read from the cache, in bytes."
          },
          "read_files_bytes": {
            "type": "integer",
            "description": "Total number of file bytes in all tables read"
          },
          "read_files_count": {
            "type": "integer",
            "description": "Number of files read after pruning"
          },
          "read_partitions_count": {
            "type": "integer",
            "description": "Number of partitions read after pruning."
          },
          "read_remote_bytes": {
            "type": "integer",
            "description": "Size of persistent data read from cloud object storage on your cloud tenant, in bytes."
          },
          "remaining_task_count": {
            "type": "integer",
            "description": "number of remaining tasks to complete this is based on the current status and could be bigger or smaller in the future based on future updates"
          },
          "result_fetch_time_ms": {
            "type": "integer",
            "description": "Time spent fetching the query results after the execution finished, in milliseconds."
          },
          "result_from_cache": {
            "type": "boolean",
            "description": "`true` if the query result was fetched from cache, `false` otherwise."
          },
          "rows_produced_count": {
            "type": "integer",
            "description": "Total number of rows returned by the query."
          },
          "rows_read_count": {
            "type": "integer",
            "description": "Total number of rows read by the query."
          },
          "runnable_tasks": {
            "type": "integer",
            "description": "number of remaining tasks to complete, calculated by autoscaler StatementAnalysis.scala deprecated: use remaining_task_count instead"
          },
          "spill_to_disk_bytes": {
            "type": "integer",
            "description": "Size of data temporarily written to disk while executing the query, in bytes."
          },
          "task_time_over_time_range": {
            "$ref": "#/components/schemas/TaskTimeOverRange",
            "description": "sum of task times completed in a range of wall clock time, approximated to a configurable number of points aggregated over all stages and jobs in the query (based on task_total_time_ms)"
          },
          "task_total_time_ms": {
            "type": "integer",
            "description": "Sum of execution time for all of the query\u2019s tasks, in milliseconds."
          },
          "total_time_ms": {
            "type": "integer",
            "description": "Total execution time of the query from the client\u2019s point of view, in milliseconds."
          },
          "work_to_be_done": {
            "type": "integer",
            "description": "remaining work to be done across all stages in the query, calculated by autoscaler StatementAnalysis.scala, in milliseconds deprecated: using projected_remaining_task_total_time_ms instead"
          },
          "write_remote_bytes": {
            "type": "integer",
            "description": "Size pf persistent data written to cloud object storage in your cloud tenant, in bytes."
          }
        },
        "description": "A query metric that encapsulates a set of measurements for a single query. Metrics come from the\n    driver and are stored in the history service database."
      },
      "QueryOptions": {
        "type": "object",
        "properties": {
          "catalog": {
            "type": "string"
          },
          "moved_to_trash_at": {
            "type": "string",
            "description": "The timestamp when this query was moved to trash. Only present when the `is_archived` property is `true`. Trashed items are deleted after thirty days."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Parameter"
            }
          },
          "schema": {
            "type": "string",
            "description": "The name of the schema to execute this query in."
          }
        }
      },
      "QueryParameter": {
        "type": "object",
        "properties": {
          "date_range_value": {
            "$ref": "#/components/schemas/DateRangeValue"
          },
          "date_value": {
            "$ref": "#/components/schemas/DateValue",
            "description": "Date query parameter value. Can only specify one of `dynamic_date_value` or `date_value`."
          },
          "enum_value": {
            "$ref": "#/components/schemas/EnumValue",
            "description": "Dropdown query parameter value."
          },
          "name": {
            "type": "string",
            "description": "Literal parameter marker that appears between double curly braces in the query text."
          },
          "numeric_value": {
            "$ref": "#/components/schemas/NumericValue",
            "description": "Numeric query parameter value."
          },
          "query_backed_value": {
            "$ref": "#/components/schemas/QueryBackedValue",
            "description": "Query-based dropdown query parameter value."
          },
          "text_value": {
            "$ref": "#/components/schemas/TextValue",
            "description": "Text query parameter value."
          },
          "title": {
            "type": "string",
            "description": "Text displayed in the user-facing parameter widget in the UI."
          }
        }
      },
      "QueryTag": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "key"
        ],
        "description": "* A query execution can be annotated with an optional key-value pair to allow users to attribute\n    the executions by key and optional value to filter by. QueryTag is the user-facing\n    representation."
      },
      "RepeatedEndpointConfPairs": {
        "type": "object",
        "properties": {
          "config_pair": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EndpointConfPair"
            }
          },
          "configuration_pairs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EndpointConfPair"
            }
          }
        }
      },
      "RestoreResponse": {
        "type": "object",
        "properties": {}
      },
      "ResultData": {
        "type": "object",
        "properties": {
          "byte_count": {
            "type": "integer",
            "description": "The number of bytes in the result chunk. This field is not available when using `INLINE` disposition."
          },
          "chunk_index": {
            "type": "integer",
            "description": "The position within the sequence of result set chunks."
          },
          "data_array": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "description": "The `JSON_ARRAY` format is an array of arrays of values, where each non-null value is formatted as a string. Null values are encoded as JSON `null`."
          },
          "external_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalLink"
            }
          },
          "next_chunk_index": {
            "type": "integer",
            "description": "When fetching, provides the `chunk_index` for the _next_ chunk. If absent, indicates there are no more chunks. The next chunk can be fetched with a :method:statementexecution/getstatementresultchunkn request."
          },
          "next_chunk_internal_link": {
            "type": "string",
            "description": "When fetching, provides a link to fetch the _next_ chunk. If absent, indicates there are no more chunks. This link is an absolute `path` to be joined with your `$DATABRICKS_HOST`, and should be treated as an opaque link. This is an alternative to using `next_chunk_index`."
          },
          "row_count": {
            "type": "integer",
            "description": "The number of rows within the result chunk."
          },
          "row_offset": {
            "type": "integer",
            "description": "The starting row offset within the result set."
          }
        },
        "description": "Contains the result data of a single chunk when using `INLINE` disposition. When using\n    `EXTERNAL_LINKS` disposition, the array `external_links` is used instead to provide URLs to the\n    result data in cloud storage. Exactly one of these alternatives is used. (While the\n    `external_links` array prepares the API to return multiple links in a single response. Currently\n    only a single link is returned.)"
      },
      "ResultManifest": {
        "type": "object",
        "properties": {
          "chunks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BaseChunkInfo"
            },
            "description": "Array of result set chunk metadata."
          },
          "format": {
            "$ref": "#/components/schemas/Format"
          },
          "schema": {
            "$ref": "#/components/schemas/ResultSchema"
          },
          "total_byte_count": {
            "type": "integer",
            "description": "The total number of bytes in the result set. This field is not available when using `INLINE` disposition."
          },
          "total_chunk_count": {
            "type": "integer",
            "description": "The total number of chunks that the result set has been divided into."
          },
          "total_row_count": {
            "type": "integer",
            "description": "The total number of rows in the result set."
          },
          "truncated": {
            "type": "boolean",
            "description": "Indicates whether the result is truncated due to `row_limit` or `byte_limit`."
          }
        },
        "description": "The result manifest provides schema and metadata for the result set."
      },
      "ResultSchema": {
        "type": "object",
        "properties": {
          "column_count": {
            "type": "integer"
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            }
          }
        },
        "description": "The schema is an ordered list of column descriptions."
      },
      "ServiceError": {
        "type": "object",
        "properties": {
          "error_code": {
            "$ref": "#/components/schemas/ServiceErrorCode"
          },
          "message": {
            "type": "string",
            "description": "A brief summary of the error condition."
          }
        }
      },
      "SetResponse": {
        "type": "object",
        "properties": {
          "access_control_list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControl"
            }
          },
          "object_id": {
            "type": "string",
            "description": "An object's type and UUID, separated by a forward slash (/) character."
          },
          "object_type": {
            "$ref": "#/components/schemas/ObjectType",
            "description": "A singular noun object type."
          }
        }
      },
      "SetWorkspaceWarehouseConfigResponse": {
        "type": "object",
        "properties": {}
      },
      "StartWarehouseResponse": {
        "type": "object",
        "properties": {}
      },
      "StatementParameterListItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "type": "string",
            "description": "The data type, given as a string. For example: `INT`, `STRING`, `DECIMAL(10,2)`. If no type is given the type is assumed to be `STRING`. Complex types, such as `ARRAY`, `MAP`, and `STRUCT` are not supported. For valid types, refer to the section [Data types] of the SQL language reference. [Data types]: https://docs.databricks.com/sql/language-manual/functions/cast.html"
          },
          "value": {
            "type": "string",
            "description": "The value to substitute, represented as a string. If omitted, the value is interpreted as NULL."
          }
        },
        "required": [
          "name"
        ]
      },
      "StatementResponse": {
        "type": "object",
        "properties": {
          "manifest": {
            "$ref": "#/components/schemas/ResultManifest"
          },
          "result": {
            "$ref": "#/components/schemas/ResultData"
          },
          "statement_id": {
            "type": "string",
            "description": "The statement ID is returned upon successfully submitting a SQL statement, and is a required reference for all subsequent calls."
          },
          "status": {
            "$ref": "#/components/schemas/StatementStatus"
          }
        }
      },
      "StatementStatus": {
        "type": "object",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/ServiceError"
          },
          "state": {
            "$ref": "#/components/schemas/StatementState",
            "description": "Statement execution state: - `PENDING`: waiting for warehouse - `RUNNING`: running - `SUCCEEDED`: execution was successful, result data available for fetch - `FAILED`: execution failed; reason for failure described in accompanying error message - `CANCELED`: user canceled; can come from explicit cancel call, or timeout with `on_wait_timeout=CANCEL` - `CLOSED`: execution successful, and statement closed; result no longer available for fetch"
          }
        },
        "description": "The status response includes execution state and if relevant, error information."
      },
      "StopWarehouseResponse": {
        "type": "object",
        "properties": {}
      },
      "Success": {
        "type": "object",
        "properties": {
          "message": {
            "$ref": "#/components/schemas/SuccessMessage"
          }
        }
      },
      "TaskTimeOverRange": {
        "type": "object",
        "properties": {
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskTimeOverRangeEntry"
            }
          },
          "interval": {
            "type": "integer",
            "description": "interval length for all entries (difference in start time and end time of an entry range) the same for all entries start time of first interval is query_start_time_ms"
          }
        }
      },
      "TaskTimeOverRangeEntry": {
        "type": "object",
        "properties": {
          "task_completed_time_ms": {
            "type": "integer"
          }
        }
      },
      "TerminationReason": {
        "type": "object",
        "properties": {
          "code": {
            "$ref": "#/components/schemas/TerminationReasonCode"
          },
          "parameters": {
            "type": "object",
            "description": "list of parameters that provide additional information about why the cluster was terminated"
          },
          "type": {
            "$ref": "#/components/schemas/TerminationReasonType",
            "description": "type of the termination"
          }
        }
      },
      "TextValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "TimeRange": {
        "type": "object",
        "properties": {
          "end_time_ms": {
            "type": "integer"
          },
          "start_time_ms": {
            "type": "integer",
            "description": "The start time in milliseconds."
          }
        }
      },
      "TransferOwnershipObjectId": {
        "type": "object",
        "properties": {
          "new_owner": {
            "type": "string"
          }
        }
      },
      "UpdateAlertRequestAlert": {
        "type": "object",
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/AlertCondition"
          },
          "custom_body": {
            "type": "string",
            "description": "Custom body of alert notification, if it exists. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "custom_subject": {
            "type": "string",
            "description": "Custom subject of alert notification, if it exists. This can include email subject entries and Slack notification headers, for example. See [here] for custom templating instructions. [here]: https://docs.databricks.com/sql/user/alerts/index.html"
          },
          "display_name": {
            "type": "string",
            "description": "The display name of the alert."
          },
          "notify_on_ok": {
            "type": "boolean",
            "description": "Whether to notify alert subscribers when alert returns back to normal."
          },
          "owner_user_name": {
            "type": "string",
            "description": "The owner's username. This field is set to \"Unavailable\" if the user has been deleted."
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query attached to the alert."
          },
          "seconds_to_retrigger": {
            "type": "integer",
            "description": "Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again."
          }
        }
      },
      "UpdateQueryRequestQuery": {
        "type": "object",
        "properties": {
          "apply_auto_limit": {
            "type": "boolean"
          },
          "catalog": {
            "type": "string",
            "description": "Name of the catalog where this query will be executed."
          },
          "description": {
            "type": "string",
            "description": "General description that conveys additional information about this query such as usage notes."
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the query that appears in list views, widget headings, and on the query page."
          },
          "owner_user_name": {
            "type": "string",
            "description": "Username of the user that owns the query."
          },
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryParameter"
            },
            "description": "List of query parameter definitions."
          },
          "query_text": {
            "type": "string",
            "description": "Text of the query to be run."
          },
          "run_as_mode": {
            "$ref": "#/components/schemas/RunAsMode",
            "description": "Sets the \"Run as\" role for the object."
          },
          "schema": {
            "type": "string",
            "description": "Name of the schema where this query will be executed."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "warehouse_id": {
            "type": "string",
            "description": "ID of the SQL warehouse attached to the query."
          }
        }
      },
      "UpdateResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateVisualizationRequestVisualization": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string"
          },
          "serialized_options": {
            "type": "string",
            "description": "The visualization options varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization options directly."
          },
          "serialized_query_plan": {
            "type": "string",
            "description": "The visualization query plan varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying the visualization query plan directly."
          },
          "type": {
            "type": "string",
            "description": "The type of visualization: counter, table, funnel, and so on."
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string"
          },
          "id": {
            "type": "integer"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "Visualization": {
        "type": "object",
        "properties": {
          "create_time": {
            "type": "string"
          },
          "display_name": {
            "type": "string",
            "description": "The display name of the visualization."
          },
          "id": {
            "type": "string",
            "description": "UUID identifying the visualization."
          },
          "query_id": {
            "type": "string",
            "description": "UUID of the query that the visualization is attached to."
          },
          "serialized_options": {
            "type": "string",
            "description": "The visualization options varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying visualization options directly."
          },
          "serialized_query_plan": {
            "type": "string",
            "description": "The visualization query plan varies widely from one visualization type to the next and is unsupported. Databricks does not recommend modifying the visualization query plan directly."
          },
          "type": {
            "type": "string",
            "description": "The type of visualization: counter, table, funnel, and so on."
          },
          "update_time": {
            "type": "string",
            "description": "The timestamp indicating when the visualization was updated."
          }
        }
      },
      "WarehouseAccessControlRequest": {
        "type": "object",
        "properties": {
          "group_name": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/WarehousePermissionLevel"
          },
          "service_principal_name": {
            "type": "string",
            "description": "application ID of a service principal"
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "WarehouseAccessControlResponse": {
        "type": "object",
        "properties": {
          "all_permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WarehousePermission"
            }
          },
          "display_name": {
            "type": "string",
            "description": "Display name of the user or service principal."
          },
          "group_name": {
            "type": "string",
            "description": "name of the group"
          },
          "service_principal_name": {
            "type": "string",
            "description": "Name of the service principal."
          },
          "user_name": {
            "type": "string",
            "description": "name of the user"
          }
        }
      },
      "WarehousePermission": {
        "type": "object",
        "properties": {
          "inherited": {
            "type": "boolean"
          },
          "inherited_from_object": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "permission_level": {
            "$ref": "#/components/schemas/WarehousePermissionLevel"
          }
        }
      },
      "WarehousePermissions": {
        "type": "object",
        "properties": {
          "access_control_list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WarehouseAccessControlResponse"
            }
          },
          "object_id": {
            "type": "string"
          },
          "object_type": {
            "type": "string"
          }
        }
      },
      "WarehousePermissionsDescription": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "permission_level": {
            "$ref": "#/components/schemas/WarehousePermissionLevel"
          }
        }
      },
      "WarehouseTypePair": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set to false the specific warehouse type will not be be allowed as a value for warehouse_type in CreateWarehouse and EditWarehouse"
          },
          "warehouse_type": {
            "$ref": "#/components/schemas/WarehouseTypePairWarehouseType"
          }
        },
        "description": "* Configuration values to enable or disable the access to specific warehouse types in the\n    workspace."
      },
      "Widget": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "options": {
            "$ref": "#/components/schemas/WidgetOptions"
          },
          "visualization": {
            "$ref": "#/components/schemas/LegacyVisualization",
            "description": "The visualization description API changes frequently and is unsupported. You can duplicate a visualization by copying description objects received _from the API_ and then using them to create a new one with a POST request to the same endpoint. Databricks does not recommend constructing ad-hoc visualizations entirely in JSON."
          },
          "width": {
            "type": "integer",
            "description": "Unused field."
          }
        }
      },
      "WidgetOptions": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "description": "Custom description of the widget"
          },
          "is_hidden": {
            "type": "boolean",
            "description": "Whether this widget is hidden on the dashboard."
          },
          "parameter_mappings": {
            "type": "object",
            "description": "How parameters used by the visualization in this widget relate to other widgets on the dashboard. Databricks does not recommend modifying this definition in JSON."
          },
          "position": {
            "$ref": "#/components/schemas/WidgetPosition",
            "description": "Coordinates of this widget on a dashboard. This portion of the API changes frequently and is unsupported."
          },
          "title": {
            "type": "string",
            "description": "Custom title of the widget"
          },
          "updated_at": {
            "type": "string",
            "description": "Timestamp of the last time this object was updated."
          }
        }
      },
      "WidgetPosition": {
        "type": "object",
        "properties": {
          "auto_height": {
            "type": "boolean",
            "description": "reserved for internal use"
          },
          "col": {
            "type": "integer",
            "description": "column in the dashboard grid. Values start with 0"
          },
          "row": {
            "type": "integer",
            "description": "row in the dashboard grid. Values start with 0"
          },
          "size_x": {
            "type": "integer",
            "description": "width of the widget measured in dashboard grid cells"
          },
          "size_y": {
            "type": "integer",
            "description": "height of the widget measured in dashboard grid cells"
          }
        },
        "description": "Coordinates of this widget on a dashboard. This portion of the API changes frequently and is\n    unsupported."
      },
      "Aggregation": {
        "type": "string",
        "enum": [
          "AVG",
          "COUNT",
          "COUNT_DISTINCT",
          "MAX",
          "MEDIAN",
          "MIN",
          "STDDEV",
          "SUM"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "AlertEvaluationState": {
        "type": "string",
        "enum": [
          "ERROR",
          "OK",
          "TRIGGERED",
          "UNKNOWN"
        ],
        "description": "UNSPECIFIED - default unspecify value for proto enum, do not use it in the code UNKNOWN - alert\nnot yet evaluated TRIGGERED - alert is triggered OK - alert is not triggered ERROR - alert\nevaluation failed"
      },
      "AlertLifecycleState": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "DELETED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "AlertOperator": {
        "type": "string",
        "enum": [
          "EQUAL",
          "GREATER_THAN",
          "GREATER_THAN_OR_EQUAL",
          "IS_NULL",
          "LESS_THAN",
          "LESS_THAN_OR_EQUAL",
          "NOT_EQUAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "AlertOptionsEmptyResultState": {
        "type": "string",
        "enum": [
          "ok",
          "triggered",
          "unknown"
        ],
        "description": "State that alert evaluates to when query result is empty."
      },
      "AlertState": {
        "type": "string",
        "enum": [
          "OK",
          "TRIGGERED",
          "UNKNOWN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ChannelName": {
        "type": "string",
        "enum": [
          "CHANNEL_NAME_CURRENT",
          "CHANNEL_NAME_CUSTOM",
          "CHANNEL_NAME_PREVIEW",
          "CHANNEL_NAME_PREVIOUS"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ColumnInfoTypeName": {
        "type": "string",
        "enum": [
          "ARRAY",
          "BINARY",
          "BOOLEAN",
          "BYTE",
          "CHAR",
          "DATE",
          "DECIMAL",
          "DOUBLE",
          "FLOAT",
          "INT",
          "INTERVAL",
          "LONG",
          "MAP",
          "NULL",
          "SHORT",
          "STRING",
          "STRUCT",
          "TIMESTAMP",
          "USER_DEFINED_TYPE"
        ],
        "description": "The name of the base data type. This doesn't include details for complex types such as STRUCT,\nMAP or ARRAY."
      },
      "ComparisonOperator": {
        "type": "string",
        "enum": [
          "EQUAL",
          "GREATER_THAN",
          "GREATER_THAN_OR_EQUAL",
          "IS_NOT_NULL",
          "IS_NULL",
          "LESS_THAN",
          "LESS_THAN_OR_EQUAL",
          "NOT_EQUAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateWarehouseRequestWarehouseType": {
        "type": "string",
        "enum": [
          "CLASSIC",
          "PRO",
          "TYPE_UNSPECIFIED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DatePrecision": {
        "type": "string",
        "enum": [
          "DAY_PRECISION",
          "MINUTE_PRECISION",
          "SECOND_PRECISION"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DateRangeValueDynamicDateRange": {
        "type": "string",
        "enum": [
          "LAST_12_MONTHS",
          "LAST_14_DAYS",
          "LAST_24_HOURS",
          "LAST_30_DAYS",
          "LAST_60_DAYS",
          "LAST_7_DAYS",
          "LAST_8_HOURS",
          "LAST_90_DAYS",
          "LAST_HOUR",
          "LAST_MONTH",
          "LAST_WEEK",
          "LAST_YEAR",
          "THIS_MONTH",
          "THIS_WEEK",
          "THIS_YEAR",
          "TODAY",
          "YESTERDAY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DateValueDynamicDate": {
        "type": "string",
        "enum": [
          "NOW",
          "YESTERDAY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DefaultWarehouseOverrideType": {
        "type": "string",
        "enum": [
          "CUSTOM",
          "LAST_SELECTED"
        ],
        "description": "Type of default warehouse override behavior."
      },
      "Disposition": {
        "type": "string",
        "enum": [
          "EXTERNAL_LINKS",
          "INLINE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EditWarehouseRequestWarehouseType": {
        "type": "string",
        "enum": [
          "CLASSIC",
          "PRO",
          "TYPE_UNSPECIFIED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EndpointInfoWarehouseType": {
        "type": "string",
        "enum": [
          "CLASSIC",
          "PRO",
          "TYPE_UNSPECIFIED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ExecuteStatementRequestOnWaitTimeout": {
        "type": "string",
        "enum": [
          "CANCEL",
          "CONTINUE"
        ],
        "description": "When `wait_timeout > 0s`, the call will block up to the specified time. If the statement\nexecution doesn't finish within this time, `on_wait_timeout` determines whether the execution\nshould continue or be canceled. When set to `CONTINUE`, the statement execution continues\nasynchronously and the call returns a statement ID which can be used for polling with\n:method:statementexecution/getStatement. When set to `CANCEL`, the statement execution is\ncanceled and the call returns with a `CANCELED` state."
      },
      "Format": {
        "type": "string",
        "enum": [
          "ARROW_STREAM",
          "CSV",
          "JSON_ARRAY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "GetWarehouseResponseWarehouseType": {
        "type": "string",
        "enum": [
          "CLASSIC",
          "PRO",
          "TYPE_UNSPECIFIED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "GetWorkspaceWarehouseConfigResponseSecurityPolicy": {
        "type": "string",
        "enum": [
          "DATA_ACCESS_CONTROL",
          "NONE",
          "PASSTHROUGH"
        ],
        "description": "Security policy to be used for warehouses"
      },
      "LegacyAlertState": {
        "type": "string",
        "enum": [
          "ok",
          "triggered",
          "unknown"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "LifecycleState": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "TRASHED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ListOrder": {
        "type": "string",
        "enum": [
          "created_at",
          "name"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ObjectType": {
        "type": "string",
        "enum": [
          "alert",
          "dashboard",
          "data_source",
          "query"
        ],
        "description": "A singular noun object type."
      },
      "ObjectTypePlural": {
        "type": "string",
        "enum": [
          "alerts",
          "dashboards",
          "data_sources",
          "queries"
        ],
        "description": "Always a plural of the object type."
      },
      "OwnableObjectType": {
        "type": "string",
        "enum": [
          "alert",
          "dashboard",
          "query"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ParameterType": {
        "type": "string",
        "enum": [
          "datetime",
          "enum",
          "number",
          "query",
          "text"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PermissionLevel": {
        "type": "string",
        "enum": [
          "CAN_EDIT",
          "CAN_MANAGE",
          "CAN_RUN",
          "CAN_VIEW"
        ],
        "description": "* `CAN_VIEW`: Can view the query * `CAN_RUN`: Can run the query * `CAN_EDIT`: Can edit the query\n* `CAN_MANAGE`: Can manage the query"
      },
      "PlansState": {
        "type": "string",
        "enum": [
          "EMPTY",
          "EXISTS",
          "IGNORED_LARGE_PLANS_SIZE",
          "IGNORED_SMALL_DURATION",
          "IGNORED_SPARK_PLAN_TYPE",
          "UNKNOWN"
        ],
        "description": "Possible Reasons for which we have not saved plans in the database"
      },
      "QueryStatementType": {
        "type": "string",
        "enum": [
          "ALTER",
          "ANALYZE",
          "COPY",
          "CREATE",
          "DELETE",
          "DESCRIBE",
          "DROP",
          "EXPLAIN",
          "GRANT",
          "INSERT",
          "MERGE",
          "OPTIMIZE",
          "OTHER",
          "REFRESH",
          "REPLACE",
          "REVOKE",
          "SELECT",
          "SET",
          "SHOW",
          "TRUNCATE",
          "UPDATE",
          "USE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "QueryStatus": {
        "type": "string",
        "enum": [
          "CANCELED",
          "COMPILED",
          "COMPILING",
          "FAILED",
          "FINISHED",
          "QUEUED",
          "RUNNING",
          "STARTED"
        ],
        "description": "Statuses which are also used by OperationStatus in runtime"
      },
      "RunAsMode": {
        "type": "string",
        "enum": [
          "OWNER",
          "VIEWER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "RunAsRole": {
        "type": "string",
        "enum": [
          "owner",
          "viewer"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SchedulePauseStatus": {
        "type": "string",
        "enum": [
          "PAUSED",
          "UNPAUSED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ServiceErrorCode": {
        "type": "string",
        "enum": [
          "ABORTED",
          "ALREADY_EXISTS",
          "BAD_REQUEST",
          "CANCELLED",
          "DEADLINE_EXCEEDED",
          "INTERNAL_ERROR",
          "IO_ERROR",
          "NOT_FOUND",
          "RESOURCE_EXHAUSTED",
          "SERVICE_UNDER_MAINTENANCE",
          "TEMPORARILY_UNAVAILABLE",
          "UNAUTHENTICATED",
          "UNKNOWN",
          "WORKSPACE_TEMPORARILY_UNAVAILABLE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SetWorkspaceWarehouseConfigRequestSecurityPolicy": {
        "type": "string",
        "enum": [
          "DATA_ACCESS_CONTROL",
          "NONE",
          "PASSTHROUGH"
        ],
        "description": "Security policy to be used for warehouses"
      },
      "SpotInstancePolicy": {
        "type": "string",
        "enum": [
          "COST_OPTIMIZED",
          "POLICY_UNSPECIFIED",
          "RELIABILITY_OPTIMIZED"
        ],
        "description": "EndpointSpotInstancePolicy configures whether the endpoint should use spot instances.\n\nThe breakdown of how the EndpointSpotInstancePolicy converts to per cloud configurations is:\n\n+-------+--------------------------------------+--------------------------------+ | Cloud |\nCOST_OPTIMIZED | RELIABILITY_OPTIMIZED |\n+-------+--------------------------------------+--------------------------------+ | AWS | On\nDemand Driver with Spot Executors | On Demand Driver and Executors | | AZURE | On Demand Driver\nand Executors | On Demand Driver and Executors |\n+-------+--------------------------------------+--------------------------------+\n\nWhile including \"spot\" in the enum name may limit the the future extensibility of this field\nbecause it limits this enum to denoting \"spot or not\", this is the field that PM recommends\nafter discussion with customers per SC-48783."
      },
      "State": {
        "type": "string",
        "enum": [
          "DELETED",
          "DELETING",
          "RUNNING",
          "STARTING",
          "STOPPED",
          "STOPPING"
        ],
        "description": "* State of a warehouse."
      },
      "StatementState": {
        "type": "string",
        "enum": [
          "CANCELED",
          "CLOSED",
          "FAILED",
          "PENDING",
          "RUNNING",
          "SUCCEEDED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "Status": {
        "type": "string",
        "enum": [
          "DEGRADED",
          "FAILED",
          "HEALTHY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SuccessMessage": {
        "type": "string",
        "enum": [
          "Success"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "TerminationReasonCode": {
        "type": "string",
        "enum": [
          "ABUSE_DETECTED",
          "ACCESS_TOKEN_FAILURE",
          "ALLOCATION_TIMEOUT",
          "ALLOCATION_TIMEOUT_NODE_DAEMON_NOT_READY",
          "ALLOCATION_TIMEOUT_NO_HEALTHY_AND_WARMED_UP_CLUSTERS",
          "ALLOCATION_TIMEOUT_NO_HEALTHY_CLUSTERS",
          "ALLOCATION_TIMEOUT_NO_MATCHED_CLUSTERS",
          "ALLOCATION_TIMEOUT_NO_READY_CLUSTERS",
          "ALLOCATION_TIMEOUT_NO_UNALLOCATED_CLUSTERS",
          "ALLOCATION_TIMEOUT_NO_WARMED_UP_CLUSTERS",
          "ATTACH_PROJECT_FAILURE",
          "AWS_AUTHORIZATION_FAILURE",
          "AWS_INACCESSIBLE_KMS_KEY_FAILURE",
          "AWS_INSTANCE_PROFILE_UPDATE_FAILURE",
          "AWS_INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET_FAILURE",
          "AWS_INSUFFICIENT_INSTANCE_CAPACITY_FAILURE",
          "AWS_INVALID_KEY_PAIR",
          "AWS_INVALID_KMS_KEY_STATE",
          "AWS_MAX_SPOT_INSTANCE_COUNT_EXCEEDED_FAILURE",
          "AWS_REQUEST_LIMIT_EXCEEDED",
          "AWS_RESOURCE_QUOTA_EXCEEDED",
          "AWS_UNSUPPORTED_FAILURE",
          "AZURE_BYOK_KEY_PERMISSION_FAILURE",
          "AZURE_EPHEMERAL_DISK_FAILURE",
          "AZURE_INVALID_DEPLOYMENT_TEMPLATE",
          "AZURE_OPERATION_NOT_ALLOWED_EXCEPTION",
          "AZURE_PACKED_DEPLOYMENT_PARTIAL_FAILURE",
          "AZURE_QUOTA_EXCEEDED_EXCEPTION",
          "AZURE_RESOURCE_MANAGER_THROTTLING",
          "AZURE_RESOURCE_PROVIDER_THROTTLING",
          "AZURE_UNEXPECTED_DEPLOYMENT_TEMPLATE_FAILURE",
          "AZURE_VM_EXTENSION_FAILURE",
          "AZURE_VNET_CONFIGURATION_FAILURE",
          "BOOTSTRAP_TIMEOUT",
          "BOOTSTRAP_TIMEOUT_CLOUD_PROVIDER_EXCEPTION",
          "BOOTSTRAP_TIMEOUT_DUE_TO_MISCONFIG",
          "BUDGET_POLICY_LIMIT_ENFORCEMENT_ACTIVATED",
          "BUDGET_POLICY_RESOLUTION_FAILURE",
          "CLOUD_ACCOUNT_POD_QUOTA_EXCEEDED",
          "CLOUD_ACCOUNT_SETUP_FAILURE",
          "CLOUD_OPERATION_CANCELLED",
          "CLOUD_PROVIDER_DISK_SETUP_FAILURE",
          "CLOUD_PROVIDER_INSTANCE_NOT_LAUNCHED",
          "CLOUD_PROVIDER_LAUNCH_FAILURE",
          "CLOUD_PROVIDER_LAUNCH_FAILURE_DUE_TO_MISCONFIG",
          "CLOUD_PROVIDER_RESOURCE_STOCKOUT",
          "CLOUD_PROVIDER_RESOURCE_STOCKOUT_DUE_TO_MISCONFIG",
          "CLOUD_PROVIDER_SHUTDOWN",
          "CLUSTER_OPERATION_THROTTLED",
          "CLUSTER_OPERATION_TIMEOUT",
          "COMMUNICATION_LOST",
          "CONTAINER_LAUNCH_FAILURE",
          "CONTROL_PLANE_CONNECTION_FAILURE",
          "CONTROL_PLANE_CONNECTION_FAILURE_DUE_TO_MISCONFIG",
          "CONTROL_PLANE_REQUEST_FAILURE",
          "CONTROL_PLANE_REQUEST_FAILURE_DUE_TO_MISCONFIG",
          "DATABASE_CONNECTION_FAILURE",
          "DATA_ACCESS_CONFIG_CHANGED",
          "DBFS_COMPONENT_UNHEALTHY",
          "DBR_IMAGE_RESOLUTION_FAILURE",
          "DISASTER_RECOVERY_REPLICATION",
          "DNS_RESOLUTION_ERROR",
          "DOCKER_CONTAINER_CREATION_EXCEPTION",
          "DOCKER_IMAGE_PULL_FAILURE",
          "DOCKER_IMAGE_TOO_LARGE_FOR_INSTANCE_EXCEPTION",
          "DOCKER_INVALID_OS_EXCEPTION",
          "DRIVER_EVICTION",
          "DRIVER_LAUNCH_TIMEOUT",
          "DRIVER_NODE_UNREACHABLE",
          "DRIVER_OUT_OF_DISK",
          "DRIVER_OUT_OF_MEMORY",
          "DRIVER_POD_CREATION_FAILURE",
          "DRIVER_UNEXPECTED_FAILURE",
          "DRIVER_UNHEALTHY",
          "DRIVER_UNREACHABLE",
          "DRIVER_UNRESPONSIVE",
          "DYNAMIC_SPARK_CONF_SIZE_EXCEEDED",
          "EOS_SPARK_IMAGE",
          "EXECUTION_COMPONENT_UNHEALTHY",
          "EXECUTOR_POD_UNSCHEDULED",
          "GCP_API_RATE_QUOTA_EXCEEDED",
          "GCP_DENIED_BY_ORG_POLICY",
          "GCP_FORBIDDEN",
          "GCP_IAM_TIMEOUT",
          "GCP_INACCESSIBLE_KMS_KEY_FAILURE",
          "GCP_INSUFFICIENT_CAPACITY",
          "GCP_IP_SPACE_EXHAUSTED",
          "GCP_KMS_KEY_PERMISSION_DENIED",
          "GCP_NOT_FOUND",
          "GCP_QUOTA_EXCEEDED",
          "GCP_RESOURCE_QUOTA_EXCEEDED",
          "GCP_SERVICE_ACCOUNT_ACCESS_DENIED",
          "GCP_SERVICE_ACCOUNT_DELETED",
          "GCP_SERVICE_ACCOUNT_NOT_FOUND",
          "GCP_SUBNET_NOT_READY",
          "GCP_TRUSTED_IMAGE_PROJECTS_VIOLATED",
          "GKE_BASED_CLUSTER_TERMINATION",
          "GLOBAL_INIT_SCRIPT_FAILURE",
          "HIVE_METASTORE_PROVISIONING_FAILURE",
          "IMAGE_PULL_PERMISSION_DENIED",
          "INACTIVITY",
          "INIT_CONTAINER_NOT_FINISHED",
          "INIT_SCRIPT_FAILURE",
          "INSTANCE_POOL_CLUSTER_FAILURE",
          "INSTANCE_POOL_MAX_CAPACITY_REACHED",
          "INSTANCE_POOL_NOT_FOUND",
          "INSTANCE_UNREACHABLE",
          "INSTANCE_UNREACHABLE_DUE_TO_MISCONFIG",
          "INTERNAL_CAPACITY_FAILURE",
          "INTERNAL_ERROR",
          "INVALID_ARGUMENT",
          "INVALID_AWS_PARAMETER",
          "INVALID_INSTANCE_PLACEMENT_PROTOCOL",
          "INVALID_SPARK_IMAGE",
          "INVALID_WORKER_IMAGE_FAILURE",
          "IN_PENALTY_BOX",
          "IP_EXHAUSTION_FAILURE",
          "JOB_FINISHED",
          "K8S_ACTIVE_POD_QUOTA_EXCEEDED",
          "K8S_AUTOSCALING_FAILURE",
          "K8S_DBR_CLUSTER_LAUNCH_TIMEOUT",
          "LAZY_ALLOCATION_TIMEOUT",
          "MAINTENANCE_MODE",
          "METASTORE_COMPONENT_UNHEALTHY",
          "MTLS_PORT_CONNECTIVITY_FAILURE",
          "NEPHOS_RESOURCE_MANAGEMENT",
          "NETVISOR_SETUP_TIMEOUT",
          "NETWORK_CHECK_CONTROL_PLANE_FAILURE",
          "NETWORK_CHECK_CONTROL_PLANE_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CHECK_DNS_SERVER_FAILURE",
          "NETWORK_CHECK_DNS_SERVER_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CHECK_METADATA_ENDPOINT_FAILURE",
          "NETWORK_CHECK_METADATA_ENDPOINT_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CHECK_MULTIPLE_COMPONENTS_FAILURE",
          "NETWORK_CHECK_MULTIPLE_COMPONENTS_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CHECK_NIC_FAILURE",
          "NETWORK_CHECK_NIC_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CHECK_STORAGE_FAILURE",
          "NETWORK_CHECK_STORAGE_FAILURE_DUE_TO_MISCONFIG",
          "NETWORK_CONFIGURATION_FAILURE",
          "NFS_MOUNT_FAILURE",
          "NO_MATCHED_K8S",
          "NO_MATCHED_K8S_TESTING_TAG",
          "NPIP_TUNNEL_SETUP_FAILURE",
          "NPIP_TUNNEL_TOKEN_FAILURE",
          "POD_ASSIGNMENT_FAILURE",
          "POD_SCHEDULING_FAILURE",
          "RATE_LIMITED",
          "REQUEST_REJECTED",
          "REQUEST_THROTTLED",
          "RESOURCE_USAGE_BLOCKED",
          "SECRET_CREATION_FAILURE",
          "SECRET_PERMISSION_DENIED",
          "SECRET_RESOLUTION_ERROR",
          "SECURITY_DAEMON_REGISTRATION_EXCEPTION",
          "SELF_BOOTSTRAP_FAILURE",
          "SERVERLESS_LONG_RUNNING_TERMINATED",
          "SKIPPED_SLOW_NODES",
          "SLOW_IMAGE_DOWNLOAD",
          "SPARK_ERROR",
          "SPARK_IMAGE_DOWNLOAD_FAILURE",
          "SPARK_IMAGE_DOWNLOAD_THROTTLED",
          "SPARK_IMAGE_NOT_FOUND",
          "SPARK_STARTUP_FAILURE",
          "SPOT_INSTANCE_TERMINATION",
          "SSH_BOOTSTRAP_FAILURE",
          "STORAGE_DOWNLOAD_FAILURE",
          "STORAGE_DOWNLOAD_FAILURE_DUE_TO_MISCONFIG",
          "STORAGE_DOWNLOAD_FAILURE_SLOW",
          "STORAGE_DOWNLOAD_FAILURE_THROTTLED",
          "STS_CLIENT_SETUP_FAILURE",
          "SUBNET_EXHAUSTED_FAILURE",
          "TEMPORARILY_UNAVAILABLE",
          "TRIAL_EXPIRED",
          "UNEXPECTED_LAUNCH_FAILURE",
          "UNEXPECTED_POD_RECREATION",
          "UNKNOWN",
          "UNSUPPORTED_INSTANCE_TYPE",
          "UPDATE_INSTANCE_PROFILE_FAILURE",
          "USAGE_POLICY_ENTITLEMENT_DENIED",
          "USER_INITIATED_VM_TERMINATION",
          "USER_REQUEST",
          "WORKER_SETUP_FAILURE",
          "WORKSPACE_CANCELLED_ERROR",
          "WORKSPACE_CONFIGURATION_ERROR",
          "WORKSPACE_UPDATE"
        ],
        "description": "The status code indicating why the cluster was terminated"
      },
      "TerminationReasonType": {
        "type": "string",
        "enum": [
          "CLIENT_ERROR",
          "CLOUD_FAILURE",
          "SERVICE_FAULT",
          "SUCCESS"
        ],
        "description": "type of the termination"
      },
      "WarehousePermissionLevel": {
        "type": "string",
        "enum": [
          "CAN_MANAGE",
          "CAN_MONITOR",
          "CAN_USE",
          "CAN_VIEW",
          "IS_OWNER"
        ],
        "description": "Permission level"
      },
      "WarehouseTypePairWarehouseType": {
        "type": "string",
        "enum": [
          "CLASSIC",
          "PRO",
          "TYPE_UNSPECIFIED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      }
    }
  }
}