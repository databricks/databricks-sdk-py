{
  "openapi": "3.0.0",
  "info": {
    "title": "Databricks Catalog API (account)",
    "description": "OpenAPI specification for the Databricks catalog service (account-level APIs), generated from the Databricks Python SDK.",
    "version": "0.1.0",
    "x-stackql-sdk-version": "0.86.0",
    "x-stackql-date-generated": "2026-02-24",
    "x-stackql-sdk-namespace": "databricks.sdk.service.catalog"
  },
  "servers": [
    {
      "url": "https://accounts.cloud.databricks.com",
      "description": "Databricks account"
    }
  ],
  "paths": {
    "/api/2.0/accounts/{account_id}/workspaces/{workspace_id}/metastores/{metastore_id}": {
      "post": {
        "operationId": "account_metastore_assignments_create",
        "summary": "Creates an assignment to a metastore for a workspace",
        "tags": [
          "catalog",
          "account_metastore_assignments"
        ],
        "description": "Creates an assignment to a metastore for a workspace\n\n:param workspace_id: int\n  Workspace ID.\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param metastore_assignment: :class:`CreateMetastoreAssignment` (optional)\n\n:returns: :class:`AccountsCreateMetastoreAssignmentResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "Workspace ID."
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metastore_assignment": {
                    "type": "object",
                    "properties": {
                      "workspace_id": {
                        "type": "integer"
                      },
                      "metastore_id": {
                        "type": "string",
                        "description": "The unique ID of the metastore."
                      },
                      "default_catalog_name": {
                        "type": "string",
                        "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
                      }
                    },
                    "required": [
                      "workspace_id",
                      "metastore_id",
                      "default_catalog_name"
                    ],
                    "description": ":returns: :class:`AccountsCreateMetastoreAssignmentResponse`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsCreateMetastoreAssignmentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoreAssignmentsAPI"
      },
      "delete": {
        "operationId": "account_metastore_assignments_delete",
        "summary": "Deletes a metastore assignment to a workspace, leaving the workspace with no metastore.",
        "tags": [
          "catalog",
          "account_metastore_assignments"
        ],
        "description": "Deletes a metastore assignment to a workspace, leaving the workspace with no metastore.\n\n:param workspace_id: int\n  Workspace ID.\n:param metastore_id: str\n  Unity Catalog metastore ID\n\n:returns: :class:`AccountsDeleteMetastoreAssignmentResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "Workspace ID."
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsDeleteMetastoreAssignmentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoreAssignmentsAPI"
      },
      "put": {
        "operationId": "account_metastore_assignments_update",
        "summary": "Updates an assignment to a metastore for a workspace. Currently, only the default catalog may be",
        "tags": [
          "catalog",
          "account_metastore_assignments"
        ],
        "description": "Updates an assignment to a metastore for a workspace. Currently, only the default catalog may be\nupdated.\n\n:param workspace_id: int\n  Workspace ID.\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param metastore_assignment: :class:`UpdateMetastoreAssignment` (optional)\n\n:returns: :class:`AccountsUpdateMetastoreAssignmentResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "Workspace ID."
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metastore_assignment": {
                    "type": "object",
                    "properties": {
                      "workspace_id": {
                        "type": "integer"
                      },
                      "default_catalog_name": {
                        "type": "string",
                        "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
                      },
                      "metastore_id": {
                        "type": "string",
                        "description": "The unique ID of the metastore."
                      }
                    },
                    "required": [
                      "workspace_id"
                    ],
                    "description": ":returns: :class:`AccountsUpdateMetastoreAssignmentResponse`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsUpdateMetastoreAssignmentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoreAssignmentsAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/workspaces/{workspace_id}/metastore": {
      "get": {
        "operationId": "account_metastore_assignments_get",
        "summary": "Gets the metastore assignment, if any, for the workspace specified by ID. If the workspace is assigned",
        "tags": [
          "catalog",
          "account_metastore_assignments"
        ],
        "description": "Gets the metastore assignment, if any, for the workspace specified by ID. If the workspace is assigned\na metastore, the mapping will be returned. If no metastore is assigned to the workspace, the\nassignment will not be found and a 404 returned.\n\n:param workspace_id: int\n  Workspace ID.\n\n:returns: :class:`AccountsMetastoreAssignment`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workspace_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "Workspace ID."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsMetastoreAssignment"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoreAssignmentsAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/metastores/{metastore_id}/workspaces": {
      "get": {
        "operationId": "account_metastore_assignments_list",
        "summary": "Gets a list of all Databricks workspace IDs that have been assigned to given metastore.",
        "tags": [
          "catalog",
          "account_metastore_assignments"
        ],
        "description": "Gets a list of all Databricks workspace IDs that have been assigned to given metastore.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n\n:returns: Iterator over int",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetCatalogWorkspaceBindingsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoreAssignmentsAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/metastores": {
      "post": {
        "operationId": "account_metastores_create",
        "summary": "Creates a Unity Catalog metastore.",
        "tags": [
          "catalog",
          "account_metastores"
        ],
        "description": "Creates a Unity Catalog metastore.\n\n:param metastore_info: :class:`CreateAccountsMetastore` (optional)\n\n:returns: :class:`AccountsCreateMetastoreResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metastore_info": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "external_access_enabled": {
                        "type": "boolean",
                        "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
                      },
                      "region": {
                        "type": "string",
                        "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
                      },
                      "storage_root": {
                        "type": "string",
                        "description": "The storage root URL for metastore"
                      }
                    },
                    "required": [
                      "name"
                    ],
                    "description": ":returns: :class:`AccountsCreateMetastoreResponse`"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsCreateMetastoreResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoresAPI"
      },
      "get": {
        "operationId": "account_metastores_list",
        "summary": "Gets all Unity Catalog metastores associated with an account specified by ID.",
        "tags": [
          "catalog",
          "account_metastores"
        ],
        "description": "Gets all Unity Catalog metastores associated with an account specified by ID.\n\n\n:returns: Iterator over :class:`MetastoreInfo`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsListMetastoresResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoresAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/metastores/{metastore_id}": {
      "delete": {
        "operationId": "account_metastores_delete",
        "summary": "Deletes a Unity Catalog metastore for an account, both specified by ID.",
        "tags": [
          "catalog",
          "account_metastores"
        ],
        "description": "Deletes a Unity Catalog metastore for an account, both specified by ID.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param force: bool (optional)\n  Force deletion even if the metastore is not empty. Default is false.\n\n:returns: :class:`AccountsDeleteMetastoreResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "description": "Force deletion even if the metastore is not empty. Default is false."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsDeleteMetastoreResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoresAPI"
      },
      "get": {
        "operationId": "account_metastores_get",
        "summary": "Gets a Unity Catalog metastore from an account, both specified by ID.",
        "tags": [
          "catalog",
          "account_metastores"
        ],
        "description": "Gets a Unity Catalog metastore from an account, both specified by ID.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n\n:returns: :class:`AccountsGetMetastoreResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsGetMetastoreResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoresAPI"
      },
      "put": {
        "operationId": "account_metastores_update",
        "summary": "Updates an existing Unity Catalog metastore.",
        "tags": [
          "catalog",
          "account_metastores"
        ],
        "description": "Updates an existing Unity Catalog metastore.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param metastore_info: :class:`UpdateAccountsMetastore` (optional)\n  Properties of the metastore to change.\n\n:returns: :class:`AccountsUpdateMetastoreResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metastore_info": {
                    "type": "object",
                    "properties": {
                      "delta_sharing_organization_name": {
                        "type": "string"
                      },
                      "delta_sharing_recipient_token_lifetime_in_seconds": {
                        "type": "integer",
                        "description": "The lifetime of delta sharing recipient token in seconds."
                      },
                      "delta_sharing_scope": {
                        "type": "string",
                        "x-enum": [
                          "INTERNAL",
                          "INTERNAL_AND_EXTERNAL"
                        ],
                        "description": "The scope of Delta Sharing enabled for the metastore."
                      },
                      "external_access_enabled": {
                        "type": "boolean",
                        "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
                      },
                      "owner": {
                        "type": "string",
                        "description": "The owner of the metastore."
                      },
                      "privilege_model_version": {
                        "type": "string",
                        "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
                      },
                      "storage_root_credential_id": {
                        "type": "string",
                        "description": "UUID of storage credential to access the metastore storage_root."
                      }
                    },
                    "description": "Properties of the metastore to change."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsUpdateMetastoreResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountMetastoresAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/metastores/{metastore_id}/storage-credentials": {
      "post": {
        "operationId": "account_storage_credentials_create",
        "summary": "Creates a new storage credential. The request object is specific to the cloud: - **AwsIamRole** for",
        "tags": [
          "catalog",
          "account_storage_credentials"
        ],
        "description": "Creates a new storage credential. The request object is specific to the cloud: - **AwsIamRole** for\nAWS credentials - **AzureServicePrincipal** for Azure credentials - **GcpServiceAccountKey** for GCP\ncredentials\n\nThe caller must be a metastore admin and have the `CREATE_STORAGE_CREDENTIAL` privilege on the\nmetastore.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param credential_info: :class:`CreateAccountsStorageCredential` (optional)\n:param skip_validation: bool (optional)\n  Optional, default false. Supplying true to this argument skips validation of the created set of\n  credentials.\n\n:returns: :class:`AccountsCreateStorageCredentialInfo`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "credential_info": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "aws_iam_role": {
                        "type": "object",
                        "properties": {
                          "role_arn": {
                            "type": "string",
                            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
                          }
                        },
                        "required": [
                          "role_arn"
                        ],
                        "description": "The AWS IAM role configuration."
                      },
                      "azure_managed_identity": {
                        "type": "object",
                        "properties": {
                          "access_connector_id": {
                            "type": "string",
                            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
                          },
                          "managed_identity_id": {
                            "type": "string",
                            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
                          }
                        },
                        "required": [
                          "access_connector_id"
                        ],
                        "description": "The Azure managed identity configuration."
                      },
                      "azure_service_principal": {
                        "type": "object",
                        "properties": {
                          "directory_id": {
                            "type": "string",
                            "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
                          },
                          "application_id": {
                            "type": "string",
                            "description": "The application ID of the application registration within the referenced AAD tenant."
                          },
                          "client_secret": {
                            "type": "string",
                            "description": "The client secret generated for the above app ID in AAD."
                          }
                        },
                        "required": [
                          "directory_id",
                          "application_id",
                          "client_secret"
                        ],
                        "description": "The Azure service principal configuration."
                      },
                      "cloudflare_api_token": {
                        "type": "object",
                        "properties": {
                          "access_key_id": {
                            "type": "string",
                            "description": "The access key ID associated with the API token."
                          },
                          "secret_access_key": {
                            "type": "string",
                            "description": "The secret access token generated for the above access key ID."
                          },
                          "account_id": {
                            "type": "string",
                            "description": "The ID of the account associated with the API token."
                          }
                        },
                        "required": [
                          "access_key_id",
                          "secret_access_key"
                        ],
                        "description": "The Cloudflare API token configuration."
                      },
                      "comment": {
                        "type": "string",
                        "description": "Comment associated with the credential."
                      },
                      "databricks_gcp_service_account": {
                        "type": "object",
                        "properties": {},
                        "description": "The Databricks managed GCP service account configuration."
                      },
                      "read_only": {
                        "type": "boolean",
                        "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                      }
                    },
                    "required": [
                      "name"
                    ],
                    "description": ":param skip_validation: bool (optional) Optional, default false. Supplying true to this argument skips validation of the created set of credentials."
                  },
                  "skip_validation": {
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsCreateStorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountStorageCredentialsAPI"
      },
      "get": {
        "operationId": "account_storage_credentials_list",
        "summary": "Gets a list of all storage credentials that have been assigned to given metastore.",
        "tags": [
          "catalog",
          "account_storage_credentials"
        ],
        "description": "Gets a list of all storage credentials that have been assigned to given metastore.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n\n:returns: Iterator over :class:`StorageCredentialInfo`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAccountStorageCredentialsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountStorageCredentialsAPI"
      }
    },
    "/api/2.0/accounts/{account_id}/metastores/{metastore_id}/storage-credentials/{storage_credential_name}": {
      "delete": {
        "operationId": "account_storage_credentials_delete",
        "summary": "Deletes a storage credential from the metastore. The caller must be an owner of the storage",
        "tags": [
          "catalog",
          "account_storage_credentials"
        ],
        "description": "Deletes a storage credential from the metastore. The caller must be an owner of the storage\ncredential.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param storage_credential_name: str\n  Name of the storage credential.\n:param force: bool (optional)\n  Force deletion even if the Storage Credential is not empty. Default is false.\n\n:returns: :class:`AccountsDeleteStorageCredentialResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          },
          {
            "name": "storage_credential_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the storage credential."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "description": "Force deletion even if the Storage Credential is not empty. Default is false."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsDeleteStorageCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountStorageCredentialsAPI"
      },
      "get": {
        "operationId": "account_storage_credentials_get",
        "summary": "Gets a storage credential from the metastore. The caller must be a metastore admin, the owner of the",
        "tags": [
          "catalog",
          "account_storage_credentials"
        ],
        "description": "Gets a storage credential from the metastore. The caller must be a metastore admin, the owner of the\nstorage credential, or have a level of privilege on the storage credential.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param storage_credential_name: str\n  Required. Name of the storage credential.\n\n:returns: :class:`AccountsStorageCredentialInfo`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          },
          {
            "name": "storage_credential_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Required. Name of the storage credential."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsStorageCredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountStorageCredentialsAPI"
      },
      "put": {
        "operationId": "account_storage_credentials_update",
        "summary": "Updates a storage credential on the metastore. The caller must be the owner of the storage credential.",
        "tags": [
          "catalog",
          "account_storage_credentials"
        ],
        "description": "Updates a storage credential on the metastore. The caller must be the owner of the storage credential.\nIf the caller is a metastore admin, only the **owner** credential can be changed.\n\n:param metastore_id: str\n  Unity Catalog metastore ID\n:param storage_credential_name: str\n  Name of the storage credential.\n:param credential_info: :class:`UpdateAccountsStorageCredential` (optional)\n:param skip_validation: bool (optional)\n  Optional. Supplying true to this argument skips validation of the updated set of credentials.\n\n:returns: :class:`AccountsUpdateStorageCredentialResponse`",
        "parameters": [
          {
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "metastore_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Unity Catalog metastore ID"
          },
          {
            "name": "storage_credential_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the storage credential."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "credential_info": {
                    "type": "object",
                    "properties": {
                      "aws_iam_role": {
                        "type": "object",
                        "properties": {
                          "role_arn": {
                            "type": "string",
                            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
                          }
                        },
                        "required": [
                          "role_arn"
                        ],
                        "description": "The AWS IAM role configuration"
                      },
                      "azure_managed_identity": {
                        "type": "object",
                        "properties": {
                          "access_connector_id": {
                            "type": "string",
                            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
                          },
                          "credential_id": {
                            "type": "string",
                            "description": "The Databricks internal ID that represents this managed identity."
                          },
                          "managed_identity_id": {
                            "type": "string",
                            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
                          }
                        },
                        "required": [
                          "access_connector_id"
                        ],
                        "description": "The Azure managed identity configuration."
                      },
                      "azure_service_principal": {
                        "type": "object",
                        "properties": {
                          "directory_id": {
                            "type": "string",
                            "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
                          },
                          "application_id": {
                            "type": "string",
                            "description": "The application ID of the application registration within the referenced AAD tenant."
                          },
                          "client_secret": {
                            "type": "string",
                            "description": "The client secret generated for the above app ID in AAD."
                          }
                        },
                        "required": [
                          "directory_id",
                          "application_id",
                          "client_secret"
                        ],
                        "description": "The Azure service principal configuration."
                      },
                      "cloudflare_api_token": {
                        "type": "object",
                        "properties": {
                          "access_key_id": {
                            "type": "string",
                            "description": "The access key ID associated with the API token."
                          },
                          "secret_access_key": {
                            "type": "string",
                            "description": "The secret access token generated for the above access key ID."
                          },
                          "account_id": {
                            "type": "string",
                            "description": "The ID of the account associated with the API token."
                          }
                        },
                        "required": [
                          "access_key_id",
                          "secret_access_key"
                        ],
                        "description": "The Cloudflare API token configuration."
                      },
                      "comment": {
                        "type": "string",
                        "description": "Comment associated with the credential."
                      },
                      "databricks_gcp_service_account": {
                        "type": "object",
                        "properties": {},
                        "description": "The Databricks managed GCP service account configuration."
                      },
                      "isolation_mode": {
                        "type": "string",
                        "x-enum": [
                          "ISOLATION_MODE_ISOLATED",
                          "ISOLATION_MODE_OPEN"
                        ],
                        "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
                      },
                      "owner": {
                        "type": "string",
                        "description": "Username of current owner of credential."
                      },
                      "read_only": {
                        "type": "boolean",
                        "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                      }
                    },
                    "description": ":param skip_validation: bool (optional) Optional. Supplying true to this argument skips validation of the updated set of credentials."
                  },
                  "skip_validation": {
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsUpdateStorageCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "AccountStorageCredentialsAPI"
      }
    },
    "/api/2.1/unity-catalog/credentials": {
      "post": {
        "operationId": "credentials_create_credential",
        "summary": "Creates a new credential. The type of credential to be created is determined by the **purpose** field,",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Creates a new credential. The type of credential to be created is determined by the **purpose** field,\nwhich should be either **SERVICE** or **STORAGE**.\n\nThe caller must be a metastore admin or have the metastore privilege **CREATE_STORAGE_CREDENTIAL** for\nstorage credentials, or **CREATE_SERVICE_CREDENTIAL** for service credentials.\n\n:param name: str\n  The credential name. The name must be unique among storage and service credentials within the\n  metastore.\n:param aws_iam_role: :class:`AwsIamRole` (optional)\n  The AWS IAM role configuration.\n:param azure_managed_identity: :class:`AzureManagedIdentity` (optional)\n  The Azure managed identity configuration.\n:param azure_service_principal: :class:`AzureServicePrincipal` (optional)\n  The Azure service principal configuration.\n:param comment: str (optional)\n  Comment associated with the credential.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccount` (optional)\n  The Databricks managed GCP service account configuration.\n:param purpose: :class:`CredentialPurpose` (optional)\n  Indicates the purpose of the credential.\n:param read_only: bool (optional)\n  Whether the credential is usable only for read operations. Only applicable when purpose is\n  **STORAGE**.\n:param skip_validation: bool (optional)\n  Optional. Supplying true to this argument skips validation of the created set of credentials.\n\n:returns: :class:`CredentialInfo`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
                  },
                  "aws_iam_role": {
                    "type": "object",
                    "properties": {
                      "external_id": {
                        "type": "string",
                        "description": "The external ID used in role assumption to prevent the confused deputy problem."
                      },
                      "role_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
                      },
                      "unity_catalog_iam_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
                      }
                    },
                    "description": "The AWS IAM role configuration."
                  },
                  "azure_managed_identity": {
                    "type": "object",
                    "properties": {
                      "access_connector_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
                      },
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "managed_identity_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
                      }
                    },
                    "required": [
                      "access_connector_id"
                    ],
                    "description": "The Azure managed identity configuration."
                  },
                  "azure_service_principal": {
                    "type": "object",
                    "properties": {
                      "directory_id": {
                        "type": "string",
                        "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
                      },
                      "application_id": {
                        "type": "string",
                        "description": "The application ID of the application registration within the referenced AAD tenant."
                      },
                      "client_secret": {
                        "type": "string",
                        "description": "The client secret generated for the above app ID in AAD."
                      }
                    },
                    "required": [
                      "directory_id",
                      "application_id",
                      "client_secret"
                    ],
                    "description": "The Azure service principal configuration."
                  },
                  "comment": {
                    "type": "string",
                    "description": "Comment associated with the credential."
                  },
                  "databricks_gcp_service_account": {
                    "type": "object",
                    "properties": {
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "email": {
                        "type": "string",
                        "description": "The email of the service account."
                      },
                      "private_key_id": {
                        "type": "string",
                        "description": "The ID that represents the private key for this Service Account"
                      }
                    },
                    "description": "The Databricks managed GCP service account configuration."
                  },
                  "purpose": {
                    "type": "string",
                    "x-enum": [
                      "SERVICE",
                      "STORAGE"
                    ],
                    "description": "Indicates the purpose of the credential."
                  },
                  "read_only": {
                    "type": "boolean",
                    "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                  },
                  "skip_validation": {
                    "type": "boolean",
                    "description": "Optional. Supplying true to this argument skips validation of the created set of credentials."
                  }
                },
                "required": [
                  "name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      },
      "get": {
        "operationId": "credentials_list_credentials",
        "summary": "Gets an array of credentials (as __CredentialInfo__ objects).",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Gets an array of credentials (as __CredentialInfo__ objects).\n\nThe array is limited to only the credentials that the caller has permission to access. If the caller\nis a metastore admin, retrieval of credentials is unrestricted. There is no guarantee of a specific\nordering of the elements in the array.\n\nPAGINATION BEHAVIOR: The API is by default paginated, a page may contain zero results while still\nproviding a next_page_token. Clients must continue reading pages until next_page_token is absent,\nwhich is the only indication that the end of results has been reached.\n\n:param include_unbound: bool (optional)\n  Whether to include credentials not bound to the workspace. Effective only if the user has permission\n  to update the credential\u2013workspace binding.\n:param max_results: int (optional)\n  Maximum number of credentials to return. - If not set, the default max page size is used. - When set\n  to a value greater than 0, the page length is the minimum of this value and a server-configured\n  value. - When set to 0, the page length is set to a server-configured value (recommended). - When\n  set to a value less than 0, an invalid parameter error is returned.\n:param page_token: str (optional)\n  Opaque token to retrieve the next page of results.\n:param purpose: :class:`CredentialPurpose` (optional)\n  Return only credentials for the specified purpose.\n\n:returns: Iterator over :class:`CredentialInfo`",
        "parameters": [
          {
            "name": "include_unbound",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "description": "Whether to include credentials not bound to the workspace. Effective only if the user has permission to update the credential\u2013workspace binding."
          },
          {
            "name": "max_results",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer"
            },
            "description": "Maximum number of credentials to return. - If not set, the default max page size is used. - When set to a value greater than 0, the page length is the minimum of this value and a server-configured value. - When set to 0, the page length is set to a server-configured value (recommended). - When set to a value less than 0, an invalid parameter error is returned."
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Opaque token to retrieve the next page of results."
          },
          {
            "name": "purpose",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/CredentialPurpose"
            },
            "description": "Return only credentials for the specified purpose."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCredentialsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      }
    },
    "/api/2.1/unity-catalog/credentials/{name_arg}": {
      "delete": {
        "operationId": "credentials_delete_credential",
        "summary": "Deletes a service or storage credential from the metastore. The caller must be an owner of the",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Deletes a service or storage credential from the metastore. The caller must be an owner of the\ncredential.\n\n:param name_arg: str\n  Name of the credential.\n:param force: bool (optional)\n  Force an update even if there are dependent services (when purpose is **SERVICE**) or dependent\n  external locations and external tables (when purpose is **STORAGE**).",
        "parameters": [
          {
            "name": "name_arg",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the credential."
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "description": "Force an update even if there are dependent services (when purpose is **SERVICE**) or dependent external locations and external tables (when purpose is **STORAGE**)."
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      },
      "get": {
        "operationId": "credentials_get_credential",
        "summary": "Gets a service or storage credential from the metastore. The caller must be a metastore admin, the",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Gets a service or storage credential from the metastore. The caller must be a metastore admin, the\nowner of the credential, or have any permission on the credential.\n\n:param name_arg: str\n  Name of the credential.\n\n:returns: :class:`CredentialInfo`",
        "parameters": [
          {
            "name": "name_arg",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the credential."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      },
      "patch": {
        "operationId": "credentials_update_credential",
        "summary": "Updates a service or storage credential on the metastore.",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Updates a service or storage credential on the metastore.\n\nThe caller must be the owner of the credential or a metastore admin or have the `MANAGE` permission.\nIf the caller is a metastore admin, only the __owner__ field can be changed.\n\n:param name_arg: str\n  Name of the credential.\n:param aws_iam_role: :class:`AwsIamRole` (optional)\n  The AWS IAM role configuration.\n:param azure_managed_identity: :class:`AzureManagedIdentity` (optional)\n  The Azure managed identity configuration.\n:param azure_service_principal: :class:`AzureServicePrincipal` (optional)\n  The Azure service principal configuration.\n:param comment: str (optional)\n  Comment associated with the credential.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccount` (optional)\n  The Databricks managed GCP service account configuration.\n:param force: bool (optional)\n  Force an update even if there are dependent services (when purpose is **SERVICE**) or dependent\n  external locations and external tables (when purpose is **STORAGE**).\n:param isolation_mode: :class:`IsolationMode` (optional)\n  Whether the current securable is accessible from all workspaces or a specific set of workspaces.\n:param new_name: str (optional)\n  New name of credential.\n:param owner: str (optional)\n  Username of current owner of credential.\n:param read_only: bool (optional)\n  Whether the credential is usable only for read operations. Only applicable when purpose is\n  **STORAGE**.\n:param skip_validation: bool (optional)\n  Supply true to this argument to skip validation of the updated credential.\n\n:returns: :class:`CredentialInfo`",
        "parameters": [
          {
            "name": "name_arg",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the credential."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aws_iam_role": {
                    "type": "object",
                    "properties": {
                      "external_id": {
                        "type": "string",
                        "description": "The external ID used in role assumption to prevent the confused deputy problem."
                      },
                      "role_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
                      },
                      "unity_catalog_iam_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
                      }
                    },
                    "description": "The AWS IAM role configuration."
                  },
                  "azure_managed_identity": {
                    "type": "object",
                    "properties": {
                      "access_connector_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
                      },
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "managed_identity_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
                      }
                    },
                    "required": [
                      "access_connector_id"
                    ],
                    "description": "The Azure managed identity configuration."
                  },
                  "azure_service_principal": {
                    "type": "object",
                    "properties": {
                      "directory_id": {
                        "type": "string",
                        "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
                      },
                      "application_id": {
                        "type": "string",
                        "description": "The application ID of the application registration within the referenced AAD tenant."
                      },
                      "client_secret": {
                        "type": "string",
                        "description": "The client secret generated for the above app ID in AAD."
                      }
                    },
                    "required": [
                      "directory_id",
                      "application_id",
                      "client_secret"
                    ],
                    "description": "The Azure service principal configuration."
                  },
                  "comment": {
                    "type": "string",
                    "description": "Comment associated with the credential."
                  },
                  "databricks_gcp_service_account": {
                    "type": "object",
                    "properties": {
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "email": {
                        "type": "string",
                        "description": "The email of the service account."
                      },
                      "private_key_id": {
                        "type": "string",
                        "description": "The ID that represents the private key for this Service Account"
                      }
                    },
                    "description": "The Databricks managed GCP service account configuration."
                  },
                  "force": {
                    "type": "boolean",
                    "description": "Force an update even if there are dependent services (when purpose is **SERVICE**) or dependent external locations and external tables (when purpose is **STORAGE**)."
                  },
                  "isolation_mode": {
                    "type": "string",
                    "x-enum": [
                      "ISOLATION_MODE_ISOLATED",
                      "ISOLATION_MODE_OPEN"
                    ],
                    "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
                  },
                  "new_name": {
                    "type": "string",
                    "description": "New name of credential."
                  },
                  "owner": {
                    "type": "string",
                    "description": "Username of current owner of credential."
                  },
                  "read_only": {
                    "type": "boolean",
                    "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
                  },
                  "skip_validation": {
                    "type": "boolean",
                    "description": "Supply true to this argument to skip validation of the updated credential."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CredentialInfo"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      }
    },
    "/api/2.1/unity-catalog/temporary-service-credentials": {
      "post": {
        "operationId": "credentials_generate_temporary_service_credential",
        "summary": "Returns a set of temporary credentials generated using the specified service credential. The caller",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Returns a set of temporary credentials generated using the specified service credential. The caller\nmust be a metastore admin or have the metastore privilege **ACCESS** on the service credential.\n\n:param credential_name: str\n  The name of the service credential used to generate a temporary credential\n:param azure_options: :class:`GenerateTemporaryServiceCredentialAzureOptions` (optional)\n:param gcp_options: :class:`GenerateTemporaryServiceCredentialGcpOptions` (optional)\n\n:returns: :class:`TemporaryCredentials`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "credential_name": {
                    "type": "string",
                    "description": "The name of the service credential used to generate a temporary credential"
                  },
                  "azure_options": {
                    "type": "object",
                    "properties": {
                      "resources": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "description": "The resources to which the temporary Azure credential should apply. These resources are the scopes that are passed to the token provider (see https://learn.microsoft.com/python/api/azure-core/azure.core.credentials.tokencredential?view=azure-python)"
                      }
                    },
                    "description": ":param gcp_options: :class:`GenerateTemporaryServiceCredentialGcpOptions` (optional)"
                  },
                  "gcp_options": {
                    "type": "object",
                    "properties": {
                      "scopes": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "description": "The scopes to which the temporary GCP credential should apply. These resources are the scopes that are passed to the token provider (see https://google-auth.readthedocs.io/en/latest/reference/google.auth.html#google.auth.credentials.Credentials)"
                      }
                    },
                    "description": "The GCP cloud options to customize the requested temporary credential"
                  }
                },
                "required": [
                  "credential_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TemporaryCredentials"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      }
    },
    "/api/2.1/unity-catalog/validate-credentials": {
      "post": {
        "operationId": "credentials_validate_credential",
        "summary": "Validates a credential.",
        "tags": [
          "catalog",
          "credentials"
        ],
        "description": "Validates a credential.\n\nFor service credentials (purpose is **SERVICE**), either the __credential_name__ or the cloud-specific\ncredential must be provided.\n\nFor storage credentials (purpose is **STORAGE**), at least one of __external_location_name__ and\n__url__ need to be provided. If only one of them is provided, it will be used for validation. And if\nboth are provided, the __url__ will be used for validation, and __external_location_name__ will be\nignored when checking overlapping urls. Either the __credential_name__ or the cloud-specific\ncredential must be provided.\n\nThe caller must be a metastore admin or the credential owner or have the required permission on the\nmetastore and the credential (e.g., **CREATE_EXTERNAL_LOCATION** when purpose is **STORAGE**).\n\n:param aws_iam_role: :class:`AwsIamRole` (optional)\n:param azure_managed_identity: :class:`AzureManagedIdentity` (optional)\n:param credential_name: str (optional)\n  Required. The name of an existing credential or long-lived cloud credential to validate.\n:param databricks_gcp_service_account: :class:`DatabricksGcpServiceAccount` (optional)\n:param external_location_name: str (optional)\n  The name of an existing external location to validate. Only applicable for storage credentials\n  (purpose is **STORAGE**.)\n:param purpose: :class:`CredentialPurpose` (optional)\n  The purpose of the credential. This should only be used when the credential is specified.\n:param read_only: bool (optional)\n  Whether the credential is only usable for read operations. Only applicable for storage credentials\n  (purpose is **STORAGE**.)\n:param url: str (optional)\n  The external location url to validate. Only applicable when purpose is **STORAGE**.\n\n:returns: :class:`ValidateCredentialResponse`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aws_iam_role": {
                    "type": "object",
                    "properties": {
                      "external_id": {
                        "type": "string",
                        "description": "The external ID used in role assumption to prevent the confused deputy problem."
                      },
                      "role_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
                      },
                      "unity_catalog_iam_arn": {
                        "type": "string",
                        "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
                      }
                    },
                    "description": ":param azure_managed_identity: :class:`AzureManagedIdentity` (optional)"
                  },
                  "azure_managed_identity": {
                    "type": "object",
                    "properties": {
                      "access_connector_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
                      },
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "managed_identity_id": {
                        "type": "string",
                        "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
                      }
                    },
                    "required": [
                      "access_connector_id"
                    ],
                    "description": "The Azure managed identity configuration."
                  },
                  "credential_name": {
                    "type": "string",
                    "description": "Required. The name of an existing credential or long-lived cloud credential to validate."
                  },
                  "databricks_gcp_service_account": {
                    "type": "object",
                    "properties": {
                      "credential_id": {
                        "type": "string",
                        "description": "The Databricks internal ID that represents this managed identity."
                      },
                      "email": {
                        "type": "string",
                        "description": "The email of the service account."
                      },
                      "private_key_id": {
                        "type": "string",
                        "description": "The ID that represents the private key for this Service Account"
                      }
                    },
                    "description": ":param external_location_name: str (optional) The name of an existing external location to validate. Only applicable for storage credentials (purpose is **STORAGE**.)"
                  },
                  "external_location_name": {
                    "type": "string"
                  },
                  "purpose": {
                    "type": "string",
                    "x-enum": [
                      "SERVICE",
                      "STORAGE"
                    ],
                    "description": "The purpose of the credential. This should only be used when the credential is specified."
                  },
                  "read_only": {
                    "type": "boolean",
                    "description": "Whether the credential is only usable for read operations. Only applicable for storage credentials (purpose is **STORAGE**.)"
                  },
                  "url": {
                    "type": "string",
                    "description": "The external location url to validate. Only applicable when purpose is **STORAGE**."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateCredentialResponse"
                }
              }
            }
          },
          "default": {
            "description": "Error response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-stackql-sdk-source": "CredentialsAPI"
      }
    }
  },
  "components": {
    "schemas": {
      "AccessRequestDestinations": {
        "type": "object",
        "properties": {
          "securable": {
            "$ref": "#/components/schemas/Securable"
          },
          "are_any_destinations_hidden": {
            "type": "boolean",
            "description": "Indicates whether any destinations are hidden from the caller due to a lack of permissions. This value is true if the caller does not have permission to see all destinations."
          },
          "destination_source_securable": {
            "$ref": "#/components/schemas/Securable",
            "description": "The source securable from which the destinations are inherited. Either the same value as securable (if destination is set directly on the securable) or the nearest parent securable with destinations set."
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationDestination"
            },
            "description": "The access request destinations for the securable."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the securable. Redundant with the name in the securable object, but necessary for Terraform integration"
          },
          "securable_type": {
            "type": "string",
            "description": "The type of the securable. Redundant with the type in the securable object, but necessary for Terraform integration"
          }
        },
        "required": [
          "securable"
        ]
      },
      "AccountsCreateMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully created."
      },
      "AccountsCreateMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        }
      },
      "AccountsCreateStorageCredentialInfo": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        }
      },
      "AccountsDeleteMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully deleted."
      },
      "AccountsDeleteMetastoreResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore was successfully deleted."
      },
      "AccountsDeleteStorageCredentialResponse": {
        "type": "object",
        "properties": {},
        "description": "The storage credential was successfully deleted."
      },
      "AccountsGetMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        },
        "description": "The metastore was successfully returned."
      },
      "AccountsListMetastoresResponse": {
        "type": "object",
        "properties": {
          "metastores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetastoreInfo"
            },
            "description": "An array of metastore information objects."
          }
        },
        "description": "Metastores were returned successfully."
      },
      "AccountsMetastoreAssignment": {
        "type": "object",
        "properties": {
          "metastore_assignment": {
            "$ref": "#/components/schemas/MetastoreAssignment"
          }
        },
        "description": "The workspace metastore assignment was successfully returned."
      },
      "AccountsStorageCredentialInfo": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        },
        "description": "The storage credential was successfully retrieved."
      },
      "AccountsUpdateMetastoreAssignmentResponse": {
        "type": "object",
        "properties": {},
        "description": "The metastore assignment was successfully updated."
      },
      "AccountsUpdateMetastoreResponse": {
        "type": "object",
        "properties": {
          "metastore_info": {
            "$ref": "#/components/schemas/MetastoreInfo"
          }
        },
        "description": "The metastore update request succeeded."
      },
      "AccountsUpdateStorageCredentialResponse": {
        "type": "object",
        "properties": {
          "credential_info": {
            "$ref": "#/components/schemas/StorageCredentialInfo"
          }
        },
        "description": "The storage credential was successfully updated."
      },
      "ArtifactAllowlistInfo": {
        "type": "object",
        "properties": {
          "artifact_matchers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArtifactMatcher"
            }
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this artifact allowlist was set, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of the user who set the artifact allowlist."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          }
        }
      },
      "ArtifactMatcher": {
        "type": "object",
        "properties": {
          "artifact": {
            "type": "string"
          },
          "match_type": {
            "$ref": "#/components/schemas/MatchType",
            "description": "The pattern matching type of the artifact"
          }
        },
        "required": [
          "artifact",
          "match_type"
        ]
      },
      "AssignResponse": {
        "type": "object",
        "properties": {}
      },
      "AwsCredentials": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID that identifies the temporary credentials."
          },
          "access_point": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the S3 access point for temporary credentials related the external location."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access key that can be used to sign AWS API requests."
          },
          "session_token": {
            "type": "string",
            "description": "The token that users must pass to AWS API to use the temporary credentials."
          }
        },
        "description": "AWS temporary credentials for API authentication. Read more at\n    https://docs.aws.amazon.com/STS/latest/APIReference/API_Credentials.html."
      },
      "AwsIamRole": {
        "type": "object",
        "properties": {
          "external_id": {
            "type": "string",
            "description": "The external ID used in role assumption to prevent the confused deputy problem."
          },
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          },
          "unity_catalog_iam_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
          }
        },
        "description": "The AWS IAM role configuration"
      },
      "AwsIamRoleRequest": {
        "type": "object",
        "properties": {
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          }
        },
        "required": [
          "role_arn"
        ],
        "description": "The AWS IAM role configuration"
      },
      "AwsIamRoleResponse": {
        "type": "object",
        "properties": {
          "role_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM role used to vend temporary credentials."
          },
          "external_id": {
            "type": "string",
            "description": "The external ID used in role assumption to prevent the confused deputy problem."
          },
          "unity_catalog_iam_arn": {
            "type": "string",
            "description": "The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role."
          }
        },
        "required": [
          "role_arn"
        ],
        "description": "The AWS IAM role configuration"
      },
      "AwsSqsQueue": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "queue_url": {
            "type": "string",
            "description": "The AQS queue url in the format https://sqs.{region}.amazonaws.com/{account id}/{queue name}. Only required for provided_sqs."
          }
        }
      },
      "AzureActiveDirectoryToken": {
        "type": "object",
        "properties": {
          "aad_token": {
            "type": "string",
            "description": "Opaque token that contains claims that you can use in Azure Active Directory to access cloud services."
          }
        },
        "description": "Azure Active Directory token, essentially the Oauth token for Azure Service Principal or Managed\n    Identity. Read more at\n    https://learn.microsoft.com/en-us/azure/databricks/dev-tools/api/latest/aad/service-prin-aad-token"
      },
      "AzureManagedIdentity": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureManagedIdentityRequest": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureManagedIdentityResponse": {
        "type": "object",
        "properties": {
          "access_connector_id": {
            "type": "string",
            "description": "The Azure resource ID of the Azure Databricks Access Connector. Use the format `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.Databricks/accessConnectors/{connector-name}`."
          },
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "managed_identity_id": {
            "type": "string",
            "description": "The Azure resource ID of the managed identity. Use the format, `/subscriptions/{guid}/resourceGroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identity-name}` This is only available for user-assgined identities. For system-assigned identities, the access_connector_id is used to identify the identity. If this field is not provided, then we assume the AzureManagedIdentity is using the system-assigned identity."
          }
        },
        "required": [
          "access_connector_id"
        ],
        "description": "The Azure managed identity configuration."
      },
      "AzureQueueStorage": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "queue_url": {
            "type": "string",
            "description": "The AQS queue url in the format https://{storage account}.queue.core.windows.net/{queue name} Only required for provided_aqs."
          },
          "resource_group": {
            "type": "string",
            "description": "Optional resource group for the queue, event grid subscription, and external location storage account. Only required for locations with a service principal storage credential"
          },
          "subscription_id": {
            "type": "string",
            "description": "Optional subscription id for the queue, event grid subscription, and external location storage account. Required for locations with a service principal storage credential"
          }
        }
      },
      "AzureServicePrincipal": {
        "type": "object",
        "properties": {
          "directory_id": {
            "type": "string",
            "description": "The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application."
          },
          "application_id": {
            "type": "string",
            "description": "The application ID of the application registration within the referenced AAD tenant."
          },
          "client_secret": {
            "type": "string",
            "description": "The client secret generated for the above app ID in AAD."
          }
        },
        "required": [
          "directory_id",
          "application_id",
          "client_secret"
        ],
        "description": "The Azure service principal configuration. Only applicable when purpose is **STORAGE**."
      },
      "AzureUserDelegationSas": {
        "type": "object",
        "properties": {
          "sas_token": {
            "type": "string",
            "description": "The signed URI (SAS Token) used to access blob services for a given path"
          }
        },
        "description": "Azure temporary credentials for API authentication. Read more at\n    https://docs.microsoft.com/en-us/rest/api/storageservices/create-user-delegation-sas"
      },
      "BatchCreateAccessRequestsResponse": {
        "type": "object",
        "properties": {
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateAccessRequestResponse"
            }
          }
        }
      },
      "CancelRefreshResponse": {
        "type": "object",
        "properties": {}
      },
      "CatalogInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "catalog_type": {
            "$ref": "#/components/schemas/CatalogType"
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "connection_name": {
            "type": "string",
            "description": "The name of the connection to an external data source."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this catalog was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of catalog creator."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization",
            "description": "Whether predictive optimization should be enabled for this object and objects under it."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the catalog. Corresponds with the name field."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/CatalogIsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of catalog."
          },
          "options": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of catalog."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "provider_name": {
            "type": "string",
            "description": "The name of delta sharing provider. A Delta Sharing catalog is a catalog that is based on a Delta share on a remote sharing server."
          },
          "provisioning_info": {
            "$ref": "#/components/schemas/ProvisioningInfo"
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType"
          },
          "share_name": {
            "type": "string",
            "description": "The name of the share under the share provider."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage Location URL (full path) for managed tables within catalog."
          },
          "storage_root": {
            "type": "string",
            "description": "Storage root URL for managed tables within catalog."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this catalog was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified catalog."
          }
        }
      },
      "CloudflareApiToken": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID associated with the API token."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access token generated for the above access key ID."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account associated with the API token."
          }
        },
        "required": [
          "access_key_id",
          "secret_access_key"
        ],
        "description": "The Cloudflare API token configuration. Read more at\n    https://developers.cloudflare.com/r2/api/s3/tokens/"
      },
      "ColumnInfo": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "string"
          },
          "mask": {
            "$ref": "#/components/schemas/ColumnMask"
          },
          "name": {
            "type": "string",
            "description": "Name of Column."
          },
          "nullable": {
            "type": "boolean",
            "description": "Whether field may be Null (default: true)."
          },
          "partition_index": {
            "type": "integer",
            "description": "Partition index for column."
          },
          "position": {
            "type": "integer",
            "description": "Ordinal position of column (starting at position 0)."
          },
          "type_interval_type": {
            "type": "string",
            "description": "Format of IntervalType."
          },
          "type_json": {
            "type": "string",
            "description": "Full data type specification, JSON-serialized."
          },
          "type_name": {
            "$ref": "#/components/schemas/ColumnTypeName"
          },
          "type_precision": {
            "type": "integer",
            "description": "Digits of precision; required for DecimalTypes."
          },
          "type_scale": {
            "type": "integer",
            "description": "Digits to right of decimal; Required for DecimalTypes."
          },
          "type_text": {
            "type": "string",
            "description": "Full data type specification as SQL/catalogString text."
          }
        }
      },
      "ColumnMask": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "using_column_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of additional table columns to be passed as input to the column mask function. The first arg of the mask function should be of the type of the column being masked and the types of the rest of the args should match the types of columns in 'using_column_names'."
          }
        }
      },
      "ColumnMaskOptions": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "on_column": {
            "type": "string",
            "description": "The alias of the column to be masked. The alias must refer to one of matched columns. The values of the column is passed to the column mask function as the first argument. Required on create and update."
          },
          "using": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionArgument"
            },
            "description": "Optional list of column aliases or constant literals to be passed as additional arguments to the column mask function. The type of each column should match the positional argument of the column mask function."
          }
        },
        "required": [
          "function_name",
          "on_column"
        ]
      },
      "ColumnRelationship": {
        "type": "object",
        "properties": {
          "source": {
            "type": "string"
          },
          "target": {
            "type": "string"
          }
        }
      },
      "ConnectionDependency": {
        "type": "object",
        "properties": {
          "connection_name": {
            "type": "string",
            "description": "Full name of the dependent connection, in the form of __connection_name__."
          }
        },
        "description": "A connection that is dependent on a SQL object."
      },
      "ConnectionInfo": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "connection_id": {
            "type": "string",
            "description": "Unique identifier of the Connection."
          },
          "connection_type": {
            "$ref": "#/components/schemas/ConnectionType",
            "description": "The type of connection."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this connection was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of connection creator."
          },
          "credential_type": {
            "$ref": "#/components/schemas/CredentialType",
            "description": "The type of credential."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of connection."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of the connection."
          },
          "options": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of the connection."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "provisioning_info": {
            "$ref": "#/components/schemas/ProvisioningInfo"
          },
          "read_only": {
            "type": "boolean",
            "description": "If the connection is read only."
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType"
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this connection was updated, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified connection."
          },
          "url": {
            "type": "string",
            "description": "URL of the remote data source, extracted from options."
          }
        },
        "description": "Next ID: 24"
      },
      "ContinuousUpdateStatus": {
        "type": "object",
        "properties": {
          "initial_pipeline_sync_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Progress of the initial data synchronization."
          },
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may not be completely synced to the online table yet."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the ONLINE_CONTINUOUS_UPDATE\n    or the ONLINE_UPDATING_PIPELINE_RESOURCES state."
      },
      "CreateAccessRequest": {
        "type": "object",
        "properties": {
          "behalf_of": {
            "$ref": "#/components/schemas/Principal"
          },
          "comment": {
            "type": "string",
            "description": "Optional. Comment associated with the request. At most 200 characters, can only contain lowercase/uppercase letters (a-z, A-Z), numbers (0-9), punctuation, and spaces."
          },
          "securable_permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SecurablePermissions"
            },
            "description": "List of securables and their corresponding requested UC privileges. At most 30 securables can be requested for a principal per batched call. Each securable can only be requested once per principal."
          }
        }
      },
      "CreateAccessRequestResponse": {
        "type": "object",
        "properties": {
          "behalf_of": {
            "$ref": "#/components/schemas/Principal"
          },
          "request_destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessRequestDestinations"
            },
            "description": "The access request destinations for all the securables the principal requested."
          }
        }
      },
      "CreateAccountsMetastore": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateAccountsStorageCredential": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleRequest",
            "description": "The AWS IAM role configuration."
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityRequest",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountRequest",
            "description": "The Databricks managed GCP service account configuration."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent Catalog."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent Schema relative to its parent Catalog."
          },
          "input_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Function input parameters."
          },
          "data_type": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Scalar function return data type."
          },
          "full_data_type": {
            "type": "string",
            "description": "Pretty printed function data type."
          },
          "routine_body": {
            "$ref": "#/components/schemas/CreateFunctionRoutineBody",
            "description": "Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the **external_language** field, and the **return_params** of the function cannot be used (as **TABLE** return type is not supported), and the **sql_data_access** field must be **NO_SQL**."
          },
          "routine_definition": {
            "type": "string",
            "description": "Function body."
          },
          "parameter_style": {
            "$ref": "#/components/schemas/CreateFunctionParameterStyle",
            "description": "Function parameter style. **S** is the value for SQL."
          },
          "is_deterministic": {
            "type": "boolean",
            "description": "Whether the function is deterministic."
          },
          "sql_data_access": {
            "$ref": "#/components/schemas/CreateFunctionSqlDataAccess",
            "description": "Function SQL data access."
          },
          "is_null_call": {
            "type": "boolean",
            "description": "Function null call."
          },
          "security_type": {
            "$ref": "#/components/schemas/CreateFunctionSecurityType",
            "description": "Function security type."
          },
          "specific_name": {
            "type": "string",
            "description": "Specific name of the function; Reserved for future use."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "external_language": {
            "type": "string",
            "description": "External function language."
          },
          "external_name": {
            "type": "string",
            "description": "External function name."
          },
          "properties": {
            "type": "string",
            "description": "JSON-serialized key-value pair map, encoded (escaped) as a string."
          },
          "return_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Table function return parameters."
          },
          "routine_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "function dependencies."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          }
        },
        "required": [
          "name",
          "catalog_name",
          "schema_name",
          "input_params",
          "data_type",
          "full_data_type",
          "routine_body",
          "routine_definition",
          "parameter_style",
          "is_deterministic",
          "sql_data_access",
          "is_null_call",
          "security_type",
          "specific_name"
        ]
      },
      "CreateMetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          }
        },
        "required": [
          "workspace_id",
          "metastore_id",
          "default_catalog_name"
        ]
      },
      "CreateRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "CredentialDependency": {
        "type": "object",
        "properties": {
          "credential_name": {
            "type": "string",
            "description": "Full name of the dependent credential, in the form of __credential_name__."
          }
        },
        "description": "A credential that is dependent on a SQL object."
      },
      "CredentialInfo": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRole"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentity",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this credential was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of credential creator."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccount",
            "description": "The Databricks managed GCP service account configuration."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the credential."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the credential."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of the parent metastore."
          },
          "name": {
            "type": "string",
            "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "purpose": {
            "$ref": "#/components/schemas/CredentialPurpose",
            "description": "Indicates the purpose of the credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this credential was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the credential."
          },
          "used_for_managed_storage": {
            "type": "boolean",
            "description": "Whether this credential is the current metastore's root storage credential. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "CredentialValidationResult": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "result": {
            "$ref": "#/components/schemas/ValidateCredentialResult",
            "description": "The results of the tested operation."
          }
        }
      },
      "DatabricksGcpServiceAccount": {
        "type": "object",
        "properties": {
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "email": {
            "type": "string",
            "description": "The email of the service account."
          },
          "private_key_id": {
            "type": "string",
            "description": "The ID that represents the private key for this Service Account"
          }
        },
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DatabricksGcpServiceAccountRequest": {
        "type": "object",
        "properties": {},
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DatabricksGcpServiceAccountResponse": {
        "type": "object",
        "properties": {
          "credential_id": {
            "type": "string",
            "description": "The Databricks internal ID that represents this managed identity."
          },
          "email": {
            "type": "string",
            "description": "The email of the service account."
          }
        },
        "description": "GCP long-lived credential. Databricks-created Google Cloud Storage service account."
      },
      "DeleteCredentialResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteMonitorResponse": {
        "type": "object",
        "properties": {}
      },
      "DeletePolicyResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "DeleteResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteTableConstraintResponse": {
        "type": "object",
        "properties": {}
      },
      "DeltaRuntimePropertiesKvPairs": {
        "type": "object",
        "properties": {
          "delta_runtime_properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          }
        },
        "required": [
          "delta_runtime_properties"
        ],
        "description": "Properties pertaining to the current state of the delta table as given by the commit server.\n    This does not contain **delta.*** (input) properties in __TableInfo.properties__."
      },
      "Dependency": {
        "type": "object",
        "properties": {
          "connection": {
            "$ref": "#/components/schemas/ConnectionDependency"
          },
          "credential": {
            "$ref": "#/components/schemas/CredentialDependency"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionDependency"
          },
          "table": {
            "$ref": "#/components/schemas/TableDependency"
          }
        },
        "description": "A dependency of a SQL object. One of the following fields must be defined: __table__,\n    __function__, __connection__, or __credential__."
      },
      "DependencyList": {
        "type": "object",
        "properties": {
          "dependencies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Dependency"
            },
            "description": "Array of dependencies."
          }
        },
        "description": "A list of dependencies."
      },
      "DisableResponse": {
        "type": "object",
        "properties": {}
      },
      "EffectivePermissionsList": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EffectivePrivilegeAssignment"
            },
            "description": "The privileges conveyed to each principal (either directly or via inheritance)"
          }
        }
      },
      "EffectivePredictiveOptimizationFlag": {
        "type": "object",
        "properties": {
          "value": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization"
          },
          "inherited_from_name": {
            "type": "string",
            "description": "The name of the object from which the flag was inherited. If there was no inheritance, this field is left blank."
          },
          "inherited_from_type": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlagInheritedFromType",
            "description": "The type of the object from which the flag was inherited. If there was no inheritance, this field is left blank."
          }
        },
        "required": [
          "value"
        ]
      },
      "EffectivePrivilege": {
        "type": "object",
        "properties": {
          "inherited_from_name": {
            "type": "string"
          },
          "inherited_from_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "The type of the object that conveys this privilege via inheritance. This field is omitted when privilege is not inherited (it's assigned to the securable itself)."
          },
          "privilege": {
            "$ref": "#/components/schemas/Privilege",
            "description": "The privilege assigned to the principal."
          }
        }
      },
      "EffectivePrivilegeAssignment": {
        "type": "object",
        "properties": {
          "principal": {
            "type": "string"
          },
          "privileges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EffectivePrivilege"
            },
            "description": "The privileges conveyed to the principal (either directly or via inheritance)."
          }
        }
      },
      "EnableResponse": {
        "type": "object",
        "properties": {}
      },
      "EncryptionDetails": {
        "type": "object",
        "properties": {
          "sse_encryption_details": {
            "$ref": "#/components/schemas/SseEncryptionDetails",
            "description": "Server-Side Encryption properties for clients communicating with AWS s3."
          }
        },
        "description": "Encryption options that apply to clients connecting to cloud storage."
      },
      "EntityTagAssignment": {
        "type": "object",
        "properties": {
          "entity_name": {
            "type": "string",
            "description": "The fully qualified name of the entity to which the tag is assigned"
          },
          "tag_key": {
            "type": "string",
            "description": "The key of the tag"
          },
          "entity_type": {
            "type": "string",
            "description": "The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes."
          },
          "tag_value": {
            "type": "string",
            "description": "The value of the tag"
          }
        },
        "required": [
          "entity_name",
          "tag_key",
          "entity_type"
        ],
        "description": "Represents a tag assignment to an entity"
      },
      "ExternalLineageExternalMetadata": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "ExternalLineageExternalMetadataInfo": {
        "type": "object",
        "properties": {
          "entity_type": {
            "type": "string",
            "description": "Type of entity represented by the external metadata object."
          },
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "name": {
            "type": "string",
            "description": "Name of the external metadata object."
          },
          "system_type": {
            "$ref": "#/components/schemas/SystemType",
            "description": "Type of external system."
          }
        },
        "description": "Represents the external metadata object in the lineage event."
      },
      "ExternalLineageFileInfo": {
        "type": "object",
        "properties": {
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "path": {
            "type": "string",
            "description": "URL of the path."
          },
          "securable_name": {
            "type": "string",
            "description": "The full name of the securable on the path."
          },
          "securable_type": {
            "type": "string",
            "description": "The securable type of the securable on the path."
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location associated with securable on the path."
          }
        },
        "description": "Represents the path information in the lineage event."
      },
      "ExternalLineageInfo": {
        "type": "object",
        "properties": {
          "external_lineage_info": {
            "$ref": "#/components/schemas/ExternalLineageRelationshipInfo",
            "description": "Information about the edge metadata of the external lineage relationship."
          },
          "external_metadata_info": {
            "$ref": "#/components/schemas/ExternalLineageExternalMetadataInfo",
            "description": "Information about external metadata involved in the lineage relationship."
          },
          "file_info": {
            "$ref": "#/components/schemas/ExternalLineageFileInfo",
            "description": "Information about the file involved in the lineage relationship."
          },
          "model_info": {
            "$ref": "#/components/schemas/ExternalLineageModelVersionInfo",
            "description": "Information about the model version involved in the lineage relationship."
          },
          "table_info": {
            "$ref": "#/components/schemas/ExternalLineageTableInfo",
            "description": "Information about the table involved in the lineage relationship."
          }
        },
        "description": "Lineage response containing lineage information of a data asset."
      },
      "ExternalLineageModelVersion": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        }
      },
      "ExternalLineageModelVersionInfo": {
        "type": "object",
        "properties": {
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "model_name": {
            "type": "string",
            "description": "Name of the model."
          },
          "version": {
            "type": "integer",
            "description": "Version number of the model."
          }
        },
        "description": "Represents the model version information in the lineage event."
      },
      "ExternalLineageObject": {
        "type": "object",
        "properties": {
          "external_metadata": {
            "$ref": "#/components/schemas/ExternalLineageExternalMetadata"
          },
          "model_version": {
            "$ref": "#/components/schemas/ExternalLineageModelVersion"
          },
          "path": {
            "$ref": "#/components/schemas/ExternalLineagePath"
          },
          "table": {
            "$ref": "#/components/schemas/ExternalLineageTable"
          }
        }
      },
      "ExternalLineagePath": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "ExternalLineageRelationship": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "ExternalLineageRelationshipInfo": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "ExternalLineageTable": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "ExternalLineageTableInfo": {
        "type": "object",
        "properties": {
          "catalog_name": {
            "type": "string",
            "description": "Name of Catalog."
          },
          "event_time": {
            "type": "string",
            "description": "Timestamp of the lineage event."
          },
          "name": {
            "type": "string",
            "description": "Name of Table."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of Schema."
          }
        },
        "description": "Represents the table information in the lineage event."
      },
      "ExternalLocationInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this external location was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of external location creator."
          },
          "credential_id": {
            "type": "string",
            "description": "Unique ID of the location's storage credential."
          },
          "credential_name": {
            "type": "string",
            "description": "Name of the storage credential used with this location."
          },
          "enable_file_events": {
            "type": "boolean",
            "description": "Whether to enable file events on this external location. Default to `true`. Set to `false` to disable file events."
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "fallback": {
            "type": "boolean",
            "description": "Indicates whether fallback mode is enabled for this external location. When fallback mode is enabled, the access to the location falls back to cluster credentials if UC credentials are not sufficient."
          },
          "file_event_queue": {
            "$ref": "#/components/schemas/FileEventQueue",
            "description": "File event queue settings. If `enable_file_events` is not `false`, must be defined and have exactly one of the documented properties."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode"
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore hosting the external location."
          },
          "name": {
            "type": "string",
            "description": "Name of the external location."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the external location."
          },
          "read_only": {
            "type": "boolean",
            "description": "Indicates whether the external location is read-only."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which external location this was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the external location."
          },
          "url": {
            "type": "string",
            "description": "Path URL of the external location."
          }
        }
      },
      "ExternalMetadata": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "system_type": {
            "$ref": "#/components/schemas/SystemType",
            "description": "Type of external system."
          },
          "entity_type": {
            "type": "string",
            "description": "Type of entity within the external system."
          },
          "columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of columns associated with the external metadata object."
          },
          "create_time": {
            "type": "string",
            "description": "Time at which this external metadata object was created."
          },
          "created_by": {
            "type": "string",
            "description": "Username of external metadata object creator."
          },
          "description": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external metadata object."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "owner": {
            "type": "string",
            "description": "Owner of the external metadata object."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the external metadata object."
          },
          "update_time": {
            "type": "string",
            "description": "Time at which this external metadata object was last modified."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified external metadata object."
          },
          "url": {
            "type": "string",
            "description": "URL associated with the external metadata object."
          }
        },
        "required": [
          "name",
          "system_type",
          "entity_type"
        ]
      },
      "FailedStatus": {
        "type": "object",
        "properties": {
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may only be partially synced to the online table. Only populated if the table is still online and available for serving."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table. Only populated if the table is still online and available for serving."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the OFFLINE_FAILED or the\n    ONLINE_PIPELINE_FAILED state."
      },
      "FileEventQueue": {
        "type": "object",
        "properties": {
          "managed_aqs": {
            "$ref": "#/components/schemas/AzureQueueStorage"
          },
          "managed_pubsub": {
            "$ref": "#/components/schemas/GcpPubsub"
          },
          "managed_sqs": {
            "$ref": "#/components/schemas/AwsSqsQueue"
          },
          "provided_aqs": {
            "$ref": "#/components/schemas/AzureQueueStorage"
          },
          "provided_pubsub": {
            "$ref": "#/components/schemas/GcpPubsub"
          },
          "provided_sqs": {
            "$ref": "#/components/schemas/AwsSqsQueue"
          }
        }
      },
      "ForeignKeyConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "child_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "parent_table": {
            "type": "string",
            "description": "The full name of the parent constraint."
          },
          "parent_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "rely": {
            "type": "boolean",
            "description": "True if the constraint is RELY, false or unset if NORELY."
          }
        },
        "required": [
          "name",
          "child_columns",
          "parent_table",
          "parent_columns"
        ]
      },
      "FunctionArgument": {
        "type": "object",
        "properties": {
          "alias": {
            "type": "string"
          },
          "constant": {
            "type": "string",
            "description": "A constant literal."
          }
        }
      },
      "FunctionDependency": {
        "type": "object",
        "properties": {
          "function_full_name": {
            "type": "string",
            "description": "Full name of the dependent function, in the form of __catalog_name__.__schema_name__.__function_name__."
          }
        },
        "required": [
          "function_full_name"
        ],
        "description": "A function that is dependent on a SQL object."
      },
      "FunctionInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean"
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent Catalog."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this function was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of function creator."
          },
          "data_type": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Scalar function return data type."
          },
          "external_language": {
            "type": "string",
            "description": "External function language."
          },
          "external_name": {
            "type": "string",
            "description": "External function name."
          },
          "full_data_type": {
            "type": "string",
            "description": "Pretty printed function data type."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of Function, in form of **catalog_name**.**schema_name**.**function_name**"
          },
          "function_id": {
            "type": "string",
            "description": "Id of Function, relative to parent schema."
          },
          "input_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Function input parameters."
          },
          "is_deterministic": {
            "type": "boolean",
            "description": "Whether the function is deterministic."
          },
          "is_null_call": {
            "type": "boolean",
            "description": "Function null call."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of function, relative to parent schema."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of the function."
          },
          "parameter_style": {
            "$ref": "#/components/schemas/FunctionInfoParameterStyle",
            "description": "Function parameter style. **S** is the value for SQL."
          },
          "properties": {
            "type": "string",
            "description": "JSON-serialized key-value pair map, encoded (escaped) as a string."
          },
          "return_params": {
            "$ref": "#/components/schemas/FunctionParameterInfos",
            "description": "Table function return parameters."
          },
          "routine_body": {
            "$ref": "#/components/schemas/FunctionInfoRoutineBody",
            "description": "Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the **external_language** field, and the **return_params** of the function cannot be used (as **TABLE** return type is not supported), and the **sql_data_access** field must be **NO_SQL**."
          },
          "routine_definition": {
            "type": "string",
            "description": "Function body."
          },
          "routine_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "function dependencies."
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent Schema relative to its parent Catalog."
          },
          "security_type": {
            "$ref": "#/components/schemas/FunctionInfoSecurityType",
            "description": "Function security type."
          },
          "specific_name": {
            "type": "string",
            "description": "Specific name of the function; Reserved for future use."
          },
          "sql_data_access": {
            "$ref": "#/components/schemas/FunctionInfoSqlDataAccess",
            "description": "Function SQL data access."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this function was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the function."
          }
        }
      },
      "FunctionParameterInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type_text": {
            "type": "string",
            "description": "Full data type spec, SQL/catalogString text."
          },
          "type_name": {
            "$ref": "#/components/schemas/ColumnTypeName",
            "description": "Name of type (INT, STRUCT, MAP, etc.)"
          },
          "position": {
            "type": "integer",
            "description": "Ordinal position of column (starting at position 0)."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "parameter_default": {
            "type": "string",
            "description": "Default value of the parameter."
          },
          "parameter_mode": {
            "$ref": "#/components/schemas/FunctionParameterMode",
            "description": "Function parameter mode."
          },
          "parameter_type": {
            "$ref": "#/components/schemas/FunctionParameterType",
            "description": "Function parameter type."
          },
          "type_interval_type": {
            "type": "string",
            "description": "Format of IntervalType."
          },
          "type_json": {
            "type": "string",
            "description": "Full data type spec, JSON-serialized."
          },
          "type_precision": {
            "type": "integer",
            "description": "Digits of precision; required on Create for DecimalTypes."
          },
          "type_scale": {
            "type": "integer",
            "description": "Digits to right of decimal; Required on Create for DecimalTypes."
          }
        },
        "required": [
          "name",
          "type_text",
          "type_name",
          "position"
        ]
      },
      "FunctionParameterInfos": {
        "type": "object",
        "properties": {
          "parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionParameterInfo"
            }
          }
        }
      },
      "GcpOauthToken": {
        "type": "object",
        "properties": {
          "oauth_token": {
            "type": "string"
          }
        },
        "description": "GCP temporary credentials for API authentication. Read more at\n    https://developers.google.com/identity/protocols/oauth2/service-account"
      },
      "GcpPubsub": {
        "type": "object",
        "properties": {
          "managed_resource_id": {
            "type": "string"
          },
          "subscription_name": {
            "type": "string",
            "description": "The Pub/Sub subscription name in the format projects/{project}/subscriptions/{subscription name}. Only required for provided_pubsub."
          }
        }
      },
      "GenerateTemporaryPathCredentialResponse": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "azure_user_delegation_sas": {
            "$ref": "#/components/schemas/AzureUserDelegationSas"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          },
          "r2_temp_credentials": {
            "$ref": "#/components/schemas/R2Credentials"
          },
          "url": {
            "type": "string",
            "description": "The URL of the storage path accessible by the temporary credential."
          }
        }
      },
      "GenerateTemporaryServiceCredentialAzureOptions": {
        "type": "object",
        "properties": {
          "resources": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The resources to which the temporary Azure credential should apply. These resources are the scopes that are passed to the token provider (see https://learn.microsoft.com/python/api/azure-core/azure.core.credentials.tokencredential?view=azure-python)"
          }
        },
        "description": "The Azure cloud options to customize the requested temporary credential"
      },
      "GenerateTemporaryServiceCredentialGcpOptions": {
        "type": "object",
        "properties": {
          "scopes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The scopes to which the temporary GCP credential should apply. These resources are the scopes that are passed to the token provider (see https://google-auth.readthedocs.io/en/latest/reference/google.auth.html#google.auth.credentials.Credentials)"
          }
        },
        "description": "The GCP cloud options to customize the requested temporary credential"
      },
      "GenerateTemporaryTableCredentialResponse": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "azure_user_delegation_sas": {
            "$ref": "#/components/schemas/AzureUserDelegationSas"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          },
          "r2_temp_credentials": {
            "$ref": "#/components/schemas/R2Credentials"
          },
          "url": {
            "type": "string",
            "description": "The URL of the storage path accessible by the temporary credential."
          }
        }
      },
      "GetCatalogWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "workspaces": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "GetMetastoreSummaryResponse": {
        "type": "object",
        "properties": {
          "cloud": {
            "type": "string"
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this metastore was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of metastore creator."
          },
          "default_data_access_config_id": {
            "type": "string",
            "description": "Unique identifier of the metastore's (Default) Data Access Configuration."
          },
          "delta_sharing_organization_name": {
            "type": "string",
            "description": "The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta Sharing as the official name."
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "global_metastore_id": {
            "type": "string",
            "description": "Globally unique metastore ID across clouds and regions, of the form `cloud:region:metastore_id`."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore."
          },
          "name": {
            "type": "string",
            "description": "The user-specified name of the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          },
          "storage_root_credential_name": {
            "type": "string",
            "description": "Name of the storage credential to access the metastore storage_root."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the metastore was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the metastore."
          }
        }
      },
      "GetPermissionsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PrivilegeAssignment"
            },
            "description": "The privileges assigned to each principal"
          }
        }
      },
      "GetQuotaResponse": {
        "type": "object",
        "properties": {
          "quota_info": {
            "$ref": "#/components/schemas/QuotaInfo"
          }
        }
      },
      "GetWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkspaceBinding"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListAccountMetastoreAssignmentsResponse": {
        "type": "object",
        "properties": {
          "workspace_ids": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "description": "The metastore assignments were successfully returned."
      },
      "ListAccountStorageCredentialsResponse": {
        "type": "object",
        "properties": {
          "storage_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorageCredentialInfo"
            },
            "description": "An array of metastore storage credentials."
          }
        },
        "description": "The metastore storage credentials were successfully returned."
      },
      "ListCatalogsResponse": {
        "type": "object",
        "properties": {
          "catalogs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CatalogInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListConnectionsResponse": {
        "type": "object",
        "properties": {
          "connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListCredentialsResponse": {
        "type": "object",
        "properties": {
          "credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CredentialInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListEntityTagAssignmentsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tag_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityTagAssignment"
            },
            "description": "The list of tag assignments"
          }
        }
      },
      "ListExternalLineageRelationshipsResponse": {
        "type": "object",
        "properties": {
          "external_lineage_relationships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalLineageInfo"
            }
          },
          "next_page_token": {
            "type": "string"
          }
        }
      },
      "ListExternalLocationsResponse": {
        "type": "object",
        "properties": {
          "external_locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalLocationInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListExternalMetadataResponse": {
        "type": "object",
        "properties": {
          "external_metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalMetadata"
            }
          },
          "next_page_token": {
            "type": "string"
          }
        }
      },
      "ListFunctionsResponse": {
        "type": "object",
        "properties": {
          "functions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListMetastoresResponse": {
        "type": "object",
        "properties": {
          "metastores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetastoreInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListModelVersionsResponse": {
        "type": "object",
        "properties": {
          "model_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelVersionInfo"
            }
          },
          "next_page_token": {
            "type": "string",
            "description": "Opaque token to retrieve the next page of results. Absent if there are no more pages. __page_token__ should be set to this value for the next request (for the next page of results)."
          }
        }
      },
      "ListPoliciesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "policies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PolicyInfo"
            },
            "description": "The list of retrieved policies."
          }
        }
      },
      "ListQuotasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "quotas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuotaInfo"
            },
            "description": "An array of returned QuotaInfos."
          }
        }
      },
      "ListRegisteredModelsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "registered_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelInfo"
            }
          }
        }
      },
      "ListSchemasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SchemaInfo"
            },
            "description": "An array of schema information objects."
          }
        }
      },
      "ListStorageCredentialsResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "storage_credentials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorageCredentialInfo"
            }
          }
        }
      },
      "ListSystemSchemasResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SystemSchemaInfo"
            },
            "description": "An array of system schema information objects."
          }
        }
      },
      "ListTableSummariesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableSummary"
            },
            "description": "List of table summaries."
          }
        }
      },
      "ListTablesResponse": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "tables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableInfo"
            },
            "description": "An array of table information objects."
          }
        }
      },
      "ListVolumesResponseContent": {
        "type": "object",
        "properties": {
          "next_page_token": {
            "type": "string"
          },
          "volumes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VolumeInfo"
            }
          }
        }
      },
      "MatchColumn": {
        "type": "object",
        "properties": {
          "alias": {
            "type": "string"
          },
          "condition": {
            "type": "string",
            "description": "The condition expression used to match a table column."
          }
        }
      },
      "MetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          }
        },
        "required": [
          "workspace_id",
          "metastore_id"
        ]
      },
      "MetastoreInfo": {
        "type": "object",
        "properties": {
          "cloud": {
            "type": "string"
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this metastore was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of metastore creator."
          },
          "default_data_access_config_id": {
            "type": "string",
            "description": "Unique identifier of the metastore's (Default) Data Access Configuration."
          },
          "delta_sharing_organization_name": {
            "type": "string",
            "description": "The organization name of a Delta Sharing entity, to be used in Databricks-to-Databricks Delta Sharing as the official name."
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "global_metastore_id": {
            "type": "string",
            "description": "Globally unique metastore ID across clouds and regions, of the form `cloud:region:metastore_id`."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of metastore."
          },
          "name": {
            "type": "string",
            "description": "The user-specified name of the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "region": {
            "type": "string",
            "description": "Cloud region which the metastore serves (e.g., `us-west-2`, `westus`)."
          },
          "storage_root": {
            "type": "string",
            "description": "The storage root URL for metastore"
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          },
          "storage_root_credential_name": {
            "type": "string",
            "description": "Name of the storage credential to access the metastore storage_root."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the metastore was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the metastore."
          }
        }
      },
      "ModelVersionInfo": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelAlias"
            }
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog containing the model version"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the model version"
          },
          "created_at": {
            "type": "integer"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the model version"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the model version"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore containing the model version"
          },
          "model_name": {
            "type": "string",
            "description": "The name of the parent registered model of the model version, relative to parent schema"
          },
          "model_version_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "Model version dependencies, for feature-store packaged models"
          },
          "run_id": {
            "type": "string",
            "description": "MLflow run ID used when creating the model version, if ``source`` was generated by an experiment run stored in an MLflow tracking server"
          },
          "run_workspace_id": {
            "type": "integer",
            "description": "ID of the Databricks workspace containing the MLflow run that generated this model version, if applicable"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema containing the model version, relative to parent catalog"
          },
          "source": {
            "type": "string",
            "description": "URI indicating the location of the source artifacts (files) for the model version"
          },
          "status": {
            "$ref": "#/components/schemas/ModelVersionInfoStatus",
            "description": "Current status of the model version. Newly created model versions start in PENDING_REGISTRATION status, then move to READY status once the model version files are uploaded and the model version is finalized. Only model versions in READY status can be loaded for inference or served."
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud under which model version data files are stored"
          },
          "updated_at": {
            "type": "integer"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the model version last time"
          },
          "version": {
            "type": "integer",
            "description": "Integer model version number, used to reference the model version in API requests."
          }
        }
      },
      "MonitorCronSchedule": {
        "type": "object",
        "properties": {
          "quartz_cron_expression": {
            "type": "string"
          },
          "timezone_id": {
            "type": "string",
            "description": "The timezone id (e.g., ``PST``) in which to evaluate the quartz expression."
          },
          "pause_status": {
            "$ref": "#/components/schemas/MonitorCronSchedulePauseStatus",
            "description": "Read only field that indicates whether a schedule is paused or not."
          }
        },
        "required": [
          "quartz_cron_expression",
          "timezone_id"
        ]
      },
      "MonitorDataClassificationConfig": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether to enable data classification."
          }
        },
        "description": "Data classification related configuration."
      },
      "MonitorDestination": {
        "type": "object",
        "properties": {
          "email_addresses": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MonitorInferenceLog": {
        "type": "object",
        "properties": {
          "problem_type": {
            "$ref": "#/components/schemas/MonitorInferenceLogProblemType"
          },
          "timestamp_col": {
            "type": "string",
            "description": "Column for the timestamp."
          },
          "granularities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of granularities to use when aggregating data into time windows based on their timestamp."
          },
          "prediction_col": {
            "type": "string",
            "description": "Column for the prediction."
          },
          "model_id_col": {
            "type": "string",
            "description": "Column for the model identifier."
          },
          "label_col": {
            "type": "string",
            "description": "Column for the label."
          },
          "prediction_proba_col": {
            "type": "string",
            "description": "Column for prediction probabilities"
          }
        },
        "required": [
          "problem_type",
          "timestamp_col",
          "granularities",
          "prediction_col",
          "model_id_col"
        ]
      },
      "MonitorInfo": {
        "type": "object",
        "properties": {
          "output_schema_name": {
            "type": "string"
          },
          "table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] UC table to monitor. Format: `catalog.schema.table_name`"
          },
          "status": {
            "$ref": "#/components/schemas/MonitorInfoStatus",
            "description": "[Create:ERR Update:IGN] The monitor status."
          },
          "profile_metrics_table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] Table that stores profile metrics data. Format: `catalog.schema.table_name`."
          },
          "drift_metrics_table_name": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] Table that stores drift metrics data. Format: `catalog.schema.table_name`."
          },
          "monitor_version": {
            "type": "integer",
            "description": "[Create:ERR Update:IGN] Represents the current monitor configuration version in use. The version will be represented in a numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted monitor_version numbers."
          },
          "assets_dir": {
            "type": "string",
            "description": "[Create:REQ Update:IGN] Field for specifying the absolute path to a custom directory to store data-monitoring assets. Normally prepopulated to a default user location via UI and Python APIs."
          },
          "baseline_table_name": {
            "type": "string",
            "description": "[Create:OPT Update:OPT] Baseline table name. Baseline data is used to compute drift from the data in the monitored `table_name`. The baseline table and the monitored table shall have the same schema."
          },
          "custom_metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitorMetric"
            },
            "description": "[Create:OPT Update:OPT] Custom metrics."
          },
          "dashboard_id": {
            "type": "string",
            "description": "[Create:ERR Update:OPT] Id of dashboard that visualizes the computed metrics. This can be empty if the monitor is in PENDING state."
          },
          "data_classification_config": {
            "$ref": "#/components/schemas/MonitorDataClassificationConfig",
            "description": "[Create:OPT Update:OPT] Data classification related config."
          },
          "inference_log": {
            "$ref": "#/components/schemas/MonitorInferenceLog"
          },
          "latest_monitor_failure_msg": {
            "type": "string",
            "description": "[Create:ERR Update:IGN] The latest error message for a monitor failure."
          },
          "notifications": {
            "$ref": "#/components/schemas/MonitorNotifications",
            "description": "[Create:OPT Update:OPT] Field for specifying notification settings."
          },
          "schedule": {
            "$ref": "#/components/schemas/MonitorCronSchedule",
            "description": "[Create:OPT Update:OPT] The monitor schedule."
          },
          "slicing_exprs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "[Create:OPT Update:OPT] List of column expressions to slice data with for targeted analysis. The data is grouped by each expression independently, resulting in a separate slice for each predicate and its complements. For example `slicing_exprs=[\u201ccol_1\u201d, \u201ccol_2 > 10\u201d]` will generate the following slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in `col1`. For high-cardinality columns, only the top 100 unique values by frequency will generate slices."
          },
          "snapshot": {
            "$ref": "#/components/schemas/MonitorSnapshot",
            "description": "Configuration for monitoring snapshot tables."
          },
          "time_series": {
            "$ref": "#/components/schemas/MonitorTimeSeries",
            "description": "Configuration for monitoring time series tables."
          }
        },
        "required": [
          "output_schema_name",
          "table_name",
          "status",
          "profile_metrics_table_name",
          "drift_metrics_table_name",
          "monitor_version"
        ]
      },
      "MonitorMetric": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the metric in the output tables."
          },
          "definition": {
            "type": "string",
            "description": "Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition]. [create metric definition]: https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition"
          },
          "input_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of column names in the input table the metric should be computed for. Can use ``\":table\"`` to indicate that the metric needs information from multiple columns."
          },
          "output_data_type": {
            "type": "string",
            "description": "The output type of the custom metric."
          },
          "type": {
            "$ref": "#/components/schemas/MonitorMetricType",
            "description": "Can only be one of ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"``, ``\"CUSTOM_METRIC_TYPE_DERIVED\"``, or ``\"CUSTOM_METRIC_TYPE_DRIFT\"``. The ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"`` and ``\"CUSTOM_METRIC_TYPE_DERIVED\"`` metrics are computed on a single table, whereas the ``\"CUSTOM_METRIC_TYPE_DRIFT\"`` compare metrics across baseline and input table, or across the two consecutive time windows. - CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing columns in your table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed aggregate metrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously computed aggregate or derived metrics"
          }
        },
        "required": [
          "name",
          "definition",
          "input_columns",
          "output_data_type",
          "type"
        ],
        "description": "Custom metric definition."
      },
      "MonitorNotifications": {
        "type": "object",
        "properties": {
          "on_failure": {
            "$ref": "#/components/schemas/MonitorDestination"
          },
          "on_new_classification_tag_detected": {
            "$ref": "#/components/schemas/MonitorDestination",
            "description": "Destinations to send notifications on new classification tag detected."
          }
        }
      },
      "MonitorRefreshInfo": {
        "type": "object",
        "properties": {
          "refresh_id": {
            "type": "integer"
          },
          "state": {
            "$ref": "#/components/schemas/MonitorRefreshInfoState",
            "description": "The current state of the refresh."
          },
          "start_time_ms": {
            "type": "integer",
            "description": "Time at which refresh operation was initiated (milliseconds since 1/1/1970 UTC)."
          },
          "end_time_ms": {
            "type": "integer",
            "description": "Time at which refresh operation completed (milliseconds since 1/1/1970 UTC)."
          },
          "message": {
            "type": "string",
            "description": "An optional message to give insight into the current state of the job (e.g. FAILURE messages)."
          },
          "trigger": {
            "$ref": "#/components/schemas/MonitorRefreshInfoTrigger",
            "description": "The method by which the refresh was triggered."
          }
        },
        "required": [
          "refresh_id",
          "state",
          "start_time_ms"
        ]
      },
      "MonitorRefreshListResponse": {
        "type": "object",
        "properties": {
          "refreshes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitorRefreshInfo"
            }
          }
        }
      },
      "MonitorSnapshot": {
        "type": "object",
        "properties": {},
        "description": "Snapshot analysis configuration"
      },
      "MonitorTimeSeries": {
        "type": "object",
        "properties": {
          "timestamp_col": {
            "type": "string",
            "description": "Column for the timestamp."
          },
          "granularities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Granularities for aggregating data into time windows based on their timestamp. Currently the following static granularities are supported: {``\\\"5 minutes\\\"``, ``\\\"30 minutes\\\"``, ``\\\"1 hour\\\"``, ``\\\"1 day\\\"``, ``\\\"\\u003cn\\u003e week(s)\\\"``, ``\\\"1 month\\\"``, ``\\\"1 year\\\"``}."
          }
        },
        "required": [
          "timestamp_col",
          "granularities"
        ],
        "description": "Time series analysis configuration."
      },
      "NamedTableConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "NotificationDestination": {
        "type": "object",
        "properties": {
          "destination_id": {
            "type": "string"
          },
          "destination_type": {
            "$ref": "#/components/schemas/DestinationType",
            "description": "The type of the destination."
          },
          "special_destination": {
            "$ref": "#/components/schemas/SpecialDestination",
            "description": "This field is used to denote whether the destination is the email of the owner of the securable object. The special destination cannot be assigned to a securable and only represents the default destination of the securable. The securable types that support default special destinations are: \"catalog\", \"external_location\", \"connection\", \"credential\", and \"metastore\". The **destination_type** of a **special_destination** is always EMAIL."
          }
        }
      },
      "OnlineTable": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Full three-part (catalog, schema, table) name of the table."
          },
          "spec": {
            "$ref": "#/components/schemas/OnlineTableSpec",
            "description": "Specification of the online table."
          },
          "status": {
            "$ref": "#/components/schemas/OnlineTableStatus",
            "description": "Online Table data synchronization status"
          },
          "table_serving_url": {
            "type": "string",
            "description": "Data serving REST API URL for this table"
          },
          "unity_catalog_provisioning_state": {
            "$ref": "#/components/schemas/ProvisioningInfoState",
            "description": "The provisioning state of the online table entity in Unity Catalog. This is distinct from the state of the data synchronization pipeline (i.e. the table may be in \"ACTIVE\" but the pipeline may be in \"PROVISIONING\" as it runs asynchronously)."
          }
        },
        "description": "Online Table information."
      },
      "OnlineTableSpec": {
        "type": "object",
        "properties": {
          "perform_full_copy": {
            "type": "boolean",
            "description": "Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports \"triggered\" scheduling policy."
          },
          "pipeline_id": {
            "type": "string",
            "description": "ID of the associated pipeline. Generated by the server - cannot be set by the caller."
          },
          "primary_key_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Primary Key columns to be used for data insert/update in the destination."
          },
          "run_continuously": {
            "$ref": "#/components/schemas/OnlineTableSpecContinuousSchedulingPolicy",
            "description": "Pipeline runs continuously after generating the initial data."
          },
          "run_triggered": {
            "$ref": "#/components/schemas/OnlineTableSpecTriggeredSchedulingPolicy",
            "description": "Pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers)"
          },
          "source_table_full_name": {
            "type": "string",
            "description": "Three-part (catalog, schema, table) name of the source Delta table."
          },
          "timeseries_key": {
            "type": "string",
            "description": "Time series key to deduplicate (tie-break) rows with the same primary key."
          }
        },
        "description": "Specification of an online table."
      },
      "OnlineTableSpecContinuousSchedulingPolicy": {
        "type": "object",
        "properties": {}
      },
      "OnlineTableSpecTriggeredSchedulingPolicy": {
        "type": "object",
        "properties": {}
      },
      "OnlineTableStatus": {
        "type": "object",
        "properties": {
          "continuous_update_status": {
            "$ref": "#/components/schemas/ContinuousUpdateStatus"
          },
          "detailed_state": {
            "$ref": "#/components/schemas/OnlineTableState",
            "description": "The state of the online table."
          },
          "failed_status": {
            "$ref": "#/components/schemas/FailedStatus"
          },
          "message": {
            "type": "string",
            "description": "A text description of the current state of the online table."
          },
          "provisioning_status": {
            "$ref": "#/components/schemas/ProvisioningStatus"
          },
          "triggered_update_status": {
            "$ref": "#/components/schemas/TriggeredUpdateStatus"
          }
        },
        "description": "Status of an online table."
      },
      "OptionSpec": {
        "type": "object",
        "properties": {
          "allowed_values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "For drop down / radio button selections, UI will want to know the possible input values, it can also be used by other option types to limit input selections."
          },
          "default_value": {
            "type": "string",
            "description": "The default value of the option, for example, value '443' for 'port' option."
          },
          "description": {
            "type": "string",
            "description": "A concise user facing description of what the input value of this option should look like."
          },
          "hint": {
            "type": "string",
            "description": "The hint is used on the UI to suggest what the input value can possibly be like, for example: example.com for 'host' option. Unlike default value, it will not be applied automatically without user input."
          },
          "is_copiable": {
            "type": "boolean",
            "description": "Indicates whether an option should be displayed with copy button on the UI."
          },
          "is_creatable": {
            "type": "boolean",
            "description": "Indicates whether an option can be provided by users in the create/update path of an entity."
          },
          "is_hidden": {
            "type": "boolean",
            "description": "Is the option value not user settable and is thus not shown on the UI."
          },
          "is_loggable": {
            "type": "boolean",
            "description": "Specifies whether this option is safe to log, i.e. no sensitive information."
          },
          "is_required": {
            "type": "boolean",
            "description": "Is the option required."
          },
          "is_secret": {
            "type": "boolean",
            "description": "Is the option value considered secret and thus redacted on the UI."
          },
          "is_updatable": {
            "type": "boolean",
            "description": "Is the option updatable by users."
          },
          "name": {
            "type": "string",
            "description": "The unique name of the option."
          },
          "oauth_stage": {
            "$ref": "#/components/schemas/OptionSpecOauthStage",
            "description": "Specifies when the option value is displayed on the UI within the OAuth flow."
          },
          "type": {
            "$ref": "#/components/schemas/OptionSpecOptionType",
            "description": "The type of the option."
          }
        },
        "description": "Spec of an allowed option on a securable kind and its attributes. This is mostly used by UI to\n    provide user friendly hints and descriptions in order to facilitate the securable creation\n    process."
      },
      "PermissionsChange": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            }
          },
          "principal": {
            "type": "string",
            "description": "The principal whose privileges we are changing. Only one of principal or principal_id should be specified, never both at the same time."
          },
          "remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            },
            "description": "The set of privileges to remove."
          }
        }
      },
      "PipelineProgress": {
        "type": "object",
        "properties": {
          "estimated_completion_time_seconds": {
            "type": "number",
            "description": "The estimated time remaining to complete this update in seconds."
          },
          "latest_version_currently_processing": {
            "type": "integer",
            "description": "The source table Delta version that was last processed by the pipeline. The pipeline may not have completely processed this version yet."
          },
          "sync_progress_completion": {
            "type": "number",
            "description": "The completion ratio of this update. This is a number between 0 and 1."
          },
          "synced_row_count": {
            "type": "integer",
            "description": "The number of rows that have been synced in this update."
          },
          "total_row_count": {
            "type": "integer",
            "description": "The total number of rows that need to be synced in this update. This number may be an estimate."
          }
        },
        "description": "Progress information of the Online Table data synchronization pipeline."
      },
      "PolicyInfo": {
        "type": "object",
        "properties": {
          "to_principals": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "for_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Type of securables that the policy should take effect on. Only `TABLE` is supported at this moment. Required on create and optional on update."
          },
          "policy_type": {
            "$ref": "#/components/schemas/PolicyType",
            "description": "Type of the policy. Required on create."
          },
          "column_mask": {
            "$ref": "#/components/schemas/ColumnMaskOptions",
            "description": "Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`. Required on create and optional on update. When specified on update, the new options will replace the existing options as a whole."
          },
          "comment": {
            "type": "string",
            "description": "Optional description of the policy."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which the policy was created, in epoch milliseconds. Output only."
          },
          "created_by": {
            "type": "string",
            "description": "Username of the user who created the policy. Output only."
          },
          "except_principals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional list of user or group names that should be excluded from the policy."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the policy. This field is output only and is generated by the system."
          },
          "match_columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MatchColumn"
            },
            "description": "Optional list of condition expressions used to match table columns. Only valid when `for_securable_type` is `TABLE`. When specified, the policy only applies to tables whose columns satisfy all match conditions."
          },
          "name": {
            "type": "string",
            "description": "Name of the policy. Required on create and optional on update. To rename the policy, set `name` to a different value on update."
          },
          "on_securable_fullname": {
            "type": "string",
            "description": "Full name of the securable on which the policy is defined. Required on create."
          },
          "on_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Type of the securable on which the policy is defined. Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment. Required on create."
          },
          "row_filter": {
            "$ref": "#/components/schemas/RowFilterOptions",
            "description": "Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`. Required on create and optional on update. When specified on update, the new options will replace the existing options as a whole."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which the policy was last modified, in epoch milliseconds. Output only."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of the user who last modified the policy. Output only."
          },
          "when_condition": {
            "type": "string",
            "description": "Optional condition when the policy should take effect."
          }
        },
        "required": [
          "to_principals",
          "for_securable_type",
          "policy_type"
        ]
      },
      "PrimaryKeyConstraint": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "child_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names for this constraint."
          },
          "rely": {
            "type": "boolean",
            "description": "True if the constraint is RELY, false or unset if NORELY."
          },
          "timeseries_columns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Column names that represent a timeseries."
          }
        },
        "required": [
          "name",
          "child_columns"
        ]
      },
      "Principal": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "principal_type": {
            "$ref": "#/components/schemas/PrincipalType"
          }
        }
      },
      "PrivilegeAssignment": {
        "type": "object",
        "properties": {
          "principal": {
            "type": "string"
          },
          "privileges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Privilege"
            },
            "description": "The privileges assigned to the principal."
          }
        }
      },
      "ProvisioningInfo": {
        "type": "object",
        "properties": {
          "state": {
            "$ref": "#/components/schemas/ProvisioningInfoState",
            "description": "The provisioning state of the resource."
          }
        },
        "description": "Status of an asynchronously provisioned resource."
      },
      "ProvisioningStatus": {
        "type": "object",
        "properties": {
          "initial_pipeline_sync_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Details about initial data synchronization. Only populated when in the PROVISIONING_INITIAL_SNAPSHOT state."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the\n    PROVISIONING_PIPELINE_RESOURCES or the PROVISIONING_INITIAL_SNAPSHOT state."
      },
      "QuotaInfo": {
        "type": "object",
        "properties": {
          "last_refreshed_at": {
            "type": "integer"
          },
          "parent_full_name": {
            "type": "string",
            "description": "Name of the parent resource. Returns metastore ID if the parent is a metastore."
          },
          "parent_securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "The quota parent securable type."
          },
          "quota_count": {
            "type": "integer",
            "description": "The current usage of the resource quota."
          },
          "quota_limit": {
            "type": "integer",
            "description": "The current limit of the resource quota."
          },
          "quota_name": {
            "type": "string",
            "description": "The name of the quota."
          }
        }
      },
      "R2Credentials": {
        "type": "object",
        "properties": {
          "access_key_id": {
            "type": "string",
            "description": "The access key ID that identifies the temporary credentials."
          },
          "secret_access_key": {
            "type": "string",
            "description": "The secret access key associated with the access key."
          },
          "session_token": {
            "type": "string",
            "description": "The generated JWT that users must pass to use the temporary credentials."
          }
        },
        "description": "R2 temporary credentials for API authentication. Read more at\n    https://developers.cloudflare.com/r2/api/s3/tokens/."
      },
      "RegenerateDashboardResponse": {
        "type": "object",
        "properties": {
          "dashboard_id": {
            "type": "string"
          },
          "parent_folder": {
            "type": "string",
            "description": "Parent folder is equivalent to {assets_dir}/{tableName}"
          }
        }
      },
      "RegisteredModelAlias": {
        "type": "object",
        "properties": {
          "alias_name": {
            "type": "string"
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog containing the model version"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the alias"
          },
          "model_name": {
            "type": "string",
            "description": "The name of the parent registered model of the model version, relative to parent schema"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema containing the model version, relative to parent catalog"
          },
          "version_num": {
            "type": "integer",
            "description": "Integer version number of the model version to which this alias points."
          }
        }
      },
      "RegisteredModelInfo": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegisteredModelAlias"
            }
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog where the schema and the registered model reside"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the registered model"
          },
          "created_at": {
            "type": "integer",
            "description": "Creation timestamp of the registered model in milliseconds since the Unix epoch"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the registered model"
          },
          "full_name": {
            "type": "string",
            "description": "The three-level (fully qualified) name of the registered model"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore"
          },
          "name": {
            "type": "string",
            "description": "The name of the registered model"
          },
          "owner": {
            "type": "string",
            "description": "The identifier of the user who owns the registered model"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema where the registered model resides"
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud under which model version data files are stored"
          },
          "updated_at": {
            "type": "integer",
            "description": "Last-update timestamp of the registered model in milliseconds since the Unix epoch"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the registered model last time"
          }
        }
      },
      "RowFilterOptions": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "using": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionArgument"
            },
            "description": "Optional list of column aliases or constant literals to be passed as arguments to the row filter function. The type of each column should match the positional argument of the row filter function."
          }
        },
        "required": [
          "function_name"
        ]
      },
      "SchemaInfo": {
        "type": "object",
        "properties": {
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent catalog."
          },
          "catalog_type": {
            "$ref": "#/components/schemas/CatalogType",
            "description": "The type of the parent catalog."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this schema was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of schema creator."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization",
            "description": "Whether predictive optimization should be enabled for this object and objects under it."
          },
          "full_name": {
            "type": "string",
            "description": "Full name of schema, in form of __catalog_name__.__schema_name__."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of schema, relative to parent catalog."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of schema."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "schema_id": {
            "type": "string",
            "description": "The unique identifier of the schema."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage location for managed tables within schema."
          },
          "storage_root": {
            "type": "string",
            "description": "Storage root URL for managed tables within schema."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this schema was created, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified schema."
          }
        },
        "description": "Next ID: 45"
      },
      "Securable": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string",
            "description": "Required. The full name of the catalog/schema/table. Optional if resource_name is present."
          },
          "provider_share": {
            "type": "string",
            "description": "Optional. The name of the Share object that contains the securable when the securable is getting shared in D2D Delta Sharing."
          },
          "type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Required. The type of securable (catalog/schema/table). Optional if resource_name is present."
          }
        },
        "description": "Generic definition of a securable, which is uniquely defined in a metastore by its type and full\n    name."
      },
      "SecurableKindManifest": {
        "type": "object",
        "properties": {
          "assignable_privileges": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Privileges that can be assigned to the securable."
          },
          "capabilities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of capabilities in the securable kind."
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OptionSpec"
            },
            "description": "Detailed specs of allowed options."
          },
          "securable_kind": {
            "$ref": "#/components/schemas/SecurableKind",
            "description": "Securable kind to get manifest of."
          },
          "securable_type": {
            "$ref": "#/components/schemas/SecurableType",
            "description": "Securable Type of the kind."
          }
        },
        "description": "Manifest of a specific securable kind."
      },
      "SecurablePermissions": {
        "type": "object",
        "properties": {
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "securable": {
            "$ref": "#/components/schemas/Securable",
            "description": "The securable for which the access request destinations are being requested."
          }
        }
      },
      "SseEncryptionDetails": {
        "type": "object",
        "properties": {
          "algorithm": {
            "$ref": "#/components/schemas/SseEncryptionDetailsAlgorithm",
            "description": "Sets the value of the 'x-amz-server-side-encryption' header in S3 request."
          },
          "aws_kms_key_arn": {
            "type": "string",
            "description": "Optional. The ARN of the SSE-KMS key used with the S3 location, when algorithm = \"SSE-KMS\". Sets the value of the 'x-amz-server-side-encryption-aws-kms-key-id' header."
          }
        },
        "description": "Server-Side Encryption properties for clients communicating with AWS s3."
      },
      "StorageCredentialInfo": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleResponse"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityResponse",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this credential was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of credential creator."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountResponse",
            "description": "The Databricks managed GCP service account configuration."
          },
          "full_name": {
            "type": "string",
            "description": "The full name of the credential."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier of the credential."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of the parent metastore."
          },
          "name": {
            "type": "string",
            "description": "The credential name. The name must be unique among storage and service credentials within the metastore."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this credential was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the credential."
          },
          "used_for_managed_storage": {
            "type": "boolean",
            "description": "Whether this credential is the current metastore's root storage credential. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "SystemSchemaInfo": {
        "type": "object",
        "properties": {
          "schema": {
            "type": "string"
          },
          "state": {
            "type": "string",
            "description": "The current state of enablement for the system schema. An empty string means the system schema is available and ready for opt-in. Possible values: AVAILABLE | ENABLE_INITIALIZED | ENABLE_COMPLETED | DISABLE_INITIALIZED | UNAVAILABLE | MANAGED"
          }
        },
        "required": [
          "schema",
          "state"
        ]
      },
      "TableConstraint": {
        "type": "object",
        "properties": {
          "foreign_key_constraint": {
            "$ref": "#/components/schemas/ForeignKeyConstraint"
          },
          "named_table_constraint": {
            "$ref": "#/components/schemas/NamedTableConstraint"
          },
          "primary_key_constraint": {
            "$ref": "#/components/schemas/PrimaryKeyConstraint"
          }
        },
        "description": "A table constraint, as defined by *one* of the following fields being set:\n    __primary_key_constraint__, __foreign_key_constraint__, __named_table_constraint__."
      },
      "TableDependency": {
        "type": "object",
        "properties": {
          "table_full_name": {
            "type": "string",
            "description": "Full name of the dependent table, in the form of __catalog_name__.__schema_name__.__table_name__."
          }
        },
        "required": [
          "table_full_name"
        ],
        "description": "A table that is dependent on a SQL object."
      },
      "TableExistsResponse": {
        "type": "object",
        "properties": {
          "table_exists": {
            "type": "boolean"
          }
        }
      },
      "TableInfo": {
        "type": "object",
        "properties": {
          "access_point": {
            "type": "string"
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "Name of parent catalog."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "The array of __ColumnInfo__ definitions of the table's columns."
          },
          "comment": {
            "type": "string",
            "description": "User-provided free-form text description."
          },
          "created_at": {
            "type": "integer",
            "description": "Time at which this table was created, in epoch milliseconds."
          },
          "created_by": {
            "type": "string",
            "description": "Username of table creator."
          },
          "data_access_configuration_id": {
            "type": "string",
            "description": "Unique ID of the Data Access Configuration to use with the table data."
          },
          "data_source_format": {
            "$ref": "#/components/schemas/DataSourceFormat"
          },
          "deleted_at": {
            "type": "integer",
            "description": "Time at which this table was deleted, in epoch milliseconds. Field is omitted if table is not deleted."
          },
          "delta_runtime_properties_kvpairs": {
            "$ref": "#/components/schemas/DeltaRuntimePropertiesKvPairs",
            "description": "Information pertaining to current state of the delta table."
          },
          "effective_predictive_optimization_flag": {
            "$ref": "#/components/schemas/EffectivePredictiveOptimizationFlag"
          },
          "enable_predictive_optimization": {
            "$ref": "#/components/schemas/EnablePredictiveOptimization"
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "full_name": {
            "type": "string",
            "description": "Full name of table, in form of __catalog_name__.__schema_name__.__table_name__"
          },
          "metastore_id": {
            "type": "string",
            "description": "Unique identifier of parent metastore."
          },
          "name": {
            "type": "string",
            "description": "Name of table, relative to parent schema."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of table."
          },
          "pipeline_id": {
            "type": "string",
            "description": "The pipeline ID of the table. Applicable for tables created by pipelines (Materialized View, Streaming Table, etc.)."
          },
          "properties": {
            "type": "object",
            "description": "A map of key-value properties attached to the securable."
          },
          "row_filter": {
            "$ref": "#/components/schemas/TableRowFilter"
          },
          "schema_name": {
            "type": "string",
            "description": "Name of parent schema relative to its parent catalog."
          },
          "securable_kind_manifest": {
            "$ref": "#/components/schemas/SecurableKindManifest",
            "description": "SecurableKindManifest of table, including capabilities the table has."
          },
          "sql_path": {
            "type": "string",
            "description": "List of schemes whose objects can be referenced without qualification."
          },
          "storage_credential_name": {
            "type": "string",
            "description": "Name of the storage credential, when a storage credential is configured for use with this table."
          },
          "storage_location": {
            "type": "string",
            "description": "Storage root URL for table (for **MANAGED**, **EXTERNAL** tables)."
          },
          "table_constraints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableConstraint"
            },
            "description": "List of table constraints. Note: this field is not set in the output of the __listTables__ API."
          },
          "table_id": {
            "type": "string",
            "description": "The unique identifier of the table."
          },
          "table_type": {
            "$ref": "#/components/schemas/TableType"
          },
          "updated_at": {
            "type": "integer",
            "description": "Time at which this table was last modified, in epoch milliseconds."
          },
          "updated_by": {
            "type": "string",
            "description": "Username of user who last modified the table."
          },
          "view_definition": {
            "type": "string",
            "description": "View definition SQL (when __table_type__ is **VIEW**, **MATERIALIZED_VIEW**, or **STREAMING_TABLE**)"
          },
          "view_dependencies": {
            "$ref": "#/components/schemas/DependencyList",
            "description": "View dependencies (when table_type == **VIEW** or **MATERIALIZED_VIEW**, **STREAMING_TABLE**) - when DependencyList is None, the dependency is not provided; - when DependencyList is an empty list, the dependency is provided but is empty; - when DependencyList is not an empty list, dependencies are provided and recorded. Note: this field is not set in the output of the __listTables__ API."
          }
        }
      },
      "TableRowFilter": {
        "type": "object",
        "properties": {
          "function_name": {
            "type": "string"
          },
          "input_column_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of table columns to be passed as input to the row filter function. The column types should match the types of the filter function arguments."
          }
        },
        "required": [
          "function_name",
          "input_column_names"
        ]
      },
      "TableSummary": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string"
          },
          "securable_kind_manifest": {
            "$ref": "#/components/schemas/SecurableKindManifest",
            "description": "SecurableKindManifest of table, including capabilities the table has."
          },
          "table_type": {
            "$ref": "#/components/schemas/TableType"
          }
        }
      },
      "TagKeyValue": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string",
            "description": "value of the tag associated with the key, could be optional"
          }
        }
      },
      "TemporaryCredentials": {
        "type": "object",
        "properties": {
          "aws_temp_credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "azure_aad": {
            "$ref": "#/components/schemas/AzureActiveDirectoryToken"
          },
          "expiration_time": {
            "type": "integer",
            "description": "Server time when the credential will expire, in epoch milliseconds. The API client is advised to cache the credential given this expiration time."
          },
          "gcp_oauth_token": {
            "$ref": "#/components/schemas/GcpOauthToken"
          }
        }
      },
      "TriggeredUpdateStatus": {
        "type": "object",
        "properties": {
          "last_processed_commit_version": {
            "type": "integer",
            "description": "The last source table Delta version that was synced to the online table. Note that this Delta version may not be completely synced to the online table yet."
          },
          "timestamp": {
            "type": "string",
            "description": "The timestamp of the last time any data was synchronized from the source table to the online table."
          },
          "triggered_update_progress": {
            "$ref": "#/components/schemas/PipelineProgress",
            "description": "Progress of the active data synchronization pipeline."
          }
        },
        "description": "Detailed status of an online table. Shown if the online table is in the ONLINE_TRIGGERED_UPDATE\n    or the ONLINE_NO_PENDING_UPDATE state."
      },
      "UnassignResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateAccountsMetastore": {
        "type": "object",
        "properties": {
          "delta_sharing_organization_name": {
            "type": "string"
          },
          "delta_sharing_recipient_token_lifetime_in_seconds": {
            "type": "integer",
            "description": "The lifetime of delta sharing recipient token in seconds."
          },
          "delta_sharing_scope": {
            "$ref": "#/components/schemas/DeltaSharingScopeEnum",
            "description": "The scope of Delta Sharing enabled for the metastore."
          },
          "external_access_enabled": {
            "type": "boolean",
            "description": "Whether to allow non-DBR clients to directly access entities under the metastore."
          },
          "owner": {
            "type": "string",
            "description": "The owner of the metastore."
          },
          "privilege_model_version": {
            "type": "string",
            "description": "Privilege model version of the metastore, of the form `major.minor` (e.g., `1.0`)."
          },
          "storage_root_credential_id": {
            "type": "string",
            "description": "UUID of storage credential to access the metastore storage_root."
          }
        }
      },
      "UpdateAccountsStorageCredential": {
        "type": "object",
        "properties": {
          "aws_iam_role": {
            "$ref": "#/components/schemas/AwsIamRoleRequest"
          },
          "azure_managed_identity": {
            "$ref": "#/components/schemas/AzureManagedIdentityResponse",
            "description": "The Azure managed identity configuration."
          },
          "azure_service_principal": {
            "$ref": "#/components/schemas/AzureServicePrincipal",
            "description": "The Azure service principal configuration."
          },
          "cloudflare_api_token": {
            "$ref": "#/components/schemas/CloudflareApiToken",
            "description": "The Cloudflare API token configuration."
          },
          "comment": {
            "type": "string",
            "description": "Comment associated with the credential."
          },
          "databricks_gcp_service_account": {
            "$ref": "#/components/schemas/DatabricksGcpServiceAccountRequest",
            "description": "The Databricks managed GCP service account configuration."
          },
          "isolation_mode": {
            "$ref": "#/components/schemas/IsolationMode",
            "description": "Whether the current securable is accessible from all workspaces or a specific set of workspaces."
          },
          "owner": {
            "type": "string",
            "description": "Username of current owner of credential."
          },
          "read_only": {
            "type": "boolean",
            "description": "Whether the credential is usable only for read operations. Only applicable when purpose is **STORAGE**."
          }
        }
      },
      "UpdateAssignmentResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateCatalogWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "workspaces": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "UpdateMetastoreAssignment": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "default_catalog_name": {
            "type": "string",
            "description": "The name of the default catalog in the metastore. This field is deprecated. Please use \"Default Namespace API\" to configure the default catalog for a Databricks workspace."
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique ID of the metastore."
          }
        },
        "required": [
          "workspace_id"
        ]
      },
      "UpdatePermissionsResponse": {
        "type": "object",
        "properties": {
          "privilege_assignments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PrivilegeAssignment"
            }
          }
        }
      },
      "UpdateRequestExternalLineage": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ExternalLineageObject"
          },
          "target": {
            "$ref": "#/components/schemas/ExternalLineageObject",
            "description": "Target object of the external lineage relationship."
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnRelationship"
            },
            "description": "List of column relationships between source and target objects."
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the external lineage relationship."
          },
          "properties": {
            "type": "object",
            "description": "Key-value properties associated with the external lineage relationship."
          }
        },
        "required": [
          "source",
          "target"
        ]
      },
      "UpdateResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateWorkspaceBindingsResponse": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkspaceBinding"
            },
            "description": "List of workspace bindings."
          }
        },
        "description": "A list of workspace IDs that are bound to the securable"
      },
      "ValidateCredentialResponse": {
        "type": "object",
        "properties": {
          "isDir": {
            "type": "boolean"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CredentialValidationResult"
            },
            "description": "The results of the validation check."
          }
        }
      },
      "ValidateStorageCredentialResponse": {
        "type": "object",
        "properties": {
          "isDir": {
            "type": "boolean"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationResult"
            },
            "description": "The results of the validation check."
          }
        }
      },
      "ValidationResult": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "operation": {
            "$ref": "#/components/schemas/ValidationResultOperation",
            "description": "The operation tested."
          },
          "result": {
            "$ref": "#/components/schemas/ValidationResultResult",
            "description": "The results of the tested operation."
          }
        }
      },
      "VolumeInfo": {
        "type": "object",
        "properties": {
          "access_point": {
            "type": "string"
          },
          "browse_only": {
            "type": "boolean",
            "description": "Indicates whether the principal is limited to retrieving metadata for the associated object through the BROWSE privilege when include_browse is enabled in the request."
          },
          "catalog_name": {
            "type": "string",
            "description": "The name of the catalog where the schema and the volume are"
          },
          "comment": {
            "type": "string",
            "description": "The comment attached to the volume"
          },
          "created_at": {
            "type": "integer"
          },
          "created_by": {
            "type": "string",
            "description": "The identifier of the user who created the volume"
          },
          "encryption_details": {
            "$ref": "#/components/schemas/EncryptionDetails"
          },
          "full_name": {
            "type": "string",
            "description": "The three-level (fully qualified) name of the volume"
          },
          "metastore_id": {
            "type": "string",
            "description": "The unique identifier of the metastore"
          },
          "name": {
            "type": "string",
            "description": "The name of the volume"
          },
          "owner": {
            "type": "string",
            "description": "The identifier of the user who owns the volume"
          },
          "schema_name": {
            "type": "string",
            "description": "The name of the schema where the volume is"
          },
          "storage_location": {
            "type": "string",
            "description": "The storage location on the cloud"
          },
          "updated_at": {
            "type": "integer"
          },
          "updated_by": {
            "type": "string",
            "description": "The identifier of the user who updated the volume last time"
          },
          "volume_id": {
            "type": "string",
            "description": "The unique identifier of the volume"
          },
          "volume_type": {
            "$ref": "#/components/schemas/VolumeType",
            "description": "The type of the volume. An external volume is located in the specified external location. A managed volume is located in the default location which is specified by the parent schema, or the parent catalog, or the Metastore. [Learn more] [Learn more]: https://docs.databricks.com/aws/en/volumes/managed-vs-external"
          }
        }
      },
      "WorkspaceBinding": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "integer"
          },
          "binding_type": {
            "$ref": "#/components/schemas/WorkspaceBindingBindingType",
            "description": "One of READ_WRITE/READ_ONLY. Default is READ_WRITE."
          }
        },
        "required": [
          "workspace_id"
        ]
      },
      "ArtifactType": {
        "type": "string",
        "x-enum": [
          "INIT_SCRIPT",
          "LIBRARY_JAR",
          "LIBRARY_MAVEN"
        ],
        "description": "The artifact type"
      },
      "CatalogIsolationMode": {
        "type": "string",
        "x-enum": [
          "ISOLATED",
          "OPEN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CatalogType": {
        "type": "string",
        "x-enum": [
          "DELTASHARING_CATALOG",
          "FOREIGN_CATALOG",
          "INTERNAL_CATALOG",
          "MANAGED_CATALOG",
          "MANAGED_ONLINE_CATALOG",
          "SYSTEM_CATALOG"
        ],
        "description": "The type of the catalog."
      },
      "ColumnTypeName": {
        "type": "string",
        "x-enum": [
          "ARRAY",
          "BINARY",
          "BOOLEAN",
          "BYTE",
          "CHAR",
          "DATE",
          "DECIMAL",
          "DOUBLE",
          "FLOAT",
          "GEOGRAPHY",
          "GEOMETRY",
          "INT",
          "INTERVAL",
          "LONG",
          "MAP",
          "NULL",
          "SHORT",
          "STRING",
          "STRUCT",
          "TABLE_TYPE",
          "TIMESTAMP",
          "TIMESTAMP_NTZ",
          "USER_DEFINED_TYPE",
          "VARIANT"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ConnectionType": {
        "type": "string",
        "x-enum": [
          "BIGQUERY",
          "DATABRICKS",
          "GA4_RAW_DATA",
          "GLUE",
          "HIVE_METASTORE",
          "HTTP",
          "MYSQL",
          "ORACLE",
          "POSTGRESQL",
          "POWER_BI",
          "REDSHIFT",
          "SALESFORCE",
          "SALESFORCE_DATA_CLOUD",
          "SERVICENOW",
          "SNOWFLAKE",
          "SQLDW",
          "SQLSERVER",
          "TERADATA",
          "UNKNOWN_CONNECTION_TYPE",
          "WORKDAY_RAAS"
        ],
        "description": "Next Id: 72"
      },
      "CreateFunctionParameterStyle": {
        "type": "string",
        "x-enum": [
          "S"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionRoutineBody": {
        "type": "string",
        "x-enum": [
          "EXTERNAL",
          "SQL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionSecurityType": {
        "type": "string",
        "x-enum": [
          "DEFINER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CreateFunctionSqlDataAccess": {
        "type": "string",
        "x-enum": [
          "CONTAINS_SQL",
          "NO_SQL",
          "READS_SQL_DATA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CredentialPurpose": {
        "type": "string",
        "x-enum": [
          "SERVICE",
          "STORAGE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "CredentialType": {
        "type": "string",
        "x-enum": [
          "ANY_STATIC_CREDENTIAL",
          "BEARER_TOKEN",
          "OAUTH_ACCESS_TOKEN",
          "OAUTH_M2M",
          "OAUTH_MTLS",
          "OAUTH_REFRESH_TOKEN",
          "OAUTH_RESOURCE_OWNER_PASSWORD",
          "OAUTH_U2M",
          "OAUTH_U2M_MAPPING",
          "OIDC_TOKEN",
          "PEM_PRIVATE_KEY",
          "SERVICE_CREDENTIAL",
          "SSWS_TOKEN",
          "UNKNOWN_CREDENTIAL_TYPE",
          "USERNAME_PASSWORD"
        ],
        "description": "Next Id: 15"
      },
      "DataSourceFormat": {
        "type": "string",
        "x-enum": [
          "AVRO",
          "BIGQUERY_FORMAT",
          "CSV",
          "DATABRICKS_FORMAT",
          "DATABRICKS_ROW_STORE_FORMAT",
          "DELTA",
          "DELTASHARING",
          "DELTA_UNIFORM_HUDI",
          "DELTA_UNIFORM_ICEBERG",
          "HIVE",
          "ICEBERG",
          "JSON",
          "MONGODB_FORMAT",
          "MYSQL_FORMAT",
          "NETSUITE_FORMAT",
          "ORACLE_FORMAT",
          "ORC",
          "PARQUET",
          "POSTGRESQL_FORMAT",
          "REDSHIFT_FORMAT",
          "SALESFORCE_DATA_CLOUD_FORMAT",
          "SALESFORCE_FORMAT",
          "SNOWFLAKE_FORMAT",
          "SQLDW_FORMAT",
          "SQLSERVER_FORMAT",
          "TERADATA_FORMAT",
          "TEXT",
          "UNITY_CATALOG",
          "VECTOR_INDEX_FORMAT",
          "WORKDAY_RAAS_FORMAT"
        ],
        "description": "Data source format"
      },
      "DeltaSharingScopeEnum": {
        "type": "string",
        "x-enum": [
          "INTERNAL",
          "INTERNAL_AND_EXTERNAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "DestinationType": {
        "type": "string",
        "x-enum": [
          "EMAIL",
          "GENERIC_WEBHOOK",
          "MICROSOFT_TEAMS",
          "SLACK",
          "URL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EffectivePredictiveOptimizationFlagInheritedFromType": {
        "type": "string",
        "x-enum": [
          "CATALOG",
          "SCHEMA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "EnablePredictiveOptimization": {
        "type": "string",
        "x-enum": [
          "DISABLE",
          "ENABLE",
          "INHERIT"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoParameterStyle": {
        "type": "string",
        "x-enum": [
          "S"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoRoutineBody": {
        "type": "string",
        "x-enum": [
          "EXTERNAL",
          "SQL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoSecurityType": {
        "type": "string",
        "x-enum": [
          "DEFINER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionInfoSqlDataAccess": {
        "type": "string",
        "x-enum": [
          "CONTAINS_SQL",
          "NO_SQL",
          "READS_SQL_DATA"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionParameterMode": {
        "type": "string",
        "x-enum": [
          "IN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "FunctionParameterType": {
        "type": "string",
        "x-enum": [
          "COLUMN",
          "PARAM"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "IsolationMode": {
        "type": "string",
        "x-enum": [
          "ISOLATION_MODE_ISOLATED",
          "ISOLATION_MODE_OPEN"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "LineageDirection": {
        "type": "string",
        "x-enum": [
          "DOWNSTREAM",
          "UPSTREAM"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MatchType": {
        "type": "string",
        "x-enum": [
          "PREFIX_MATCH"
        ],
        "description": "The artifact pattern matching type"
      },
      "ModelVersionInfoStatus": {
        "type": "string",
        "x-enum": [
          "FAILED_REGISTRATION",
          "MODEL_VERSION_STATUS_UNKNOWN",
          "PENDING_REGISTRATION",
          "READY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorCronSchedulePauseStatus": {
        "type": "string",
        "x-enum": [
          "PAUSED",
          "UNPAUSED",
          "UNSPECIFIED"
        ],
        "description": "Source link:\nhttps://src.dev.databricks.com/databricks/universe/-/blob/elastic-spark-common/api/messages/schedule.proto\nMonitoring workflow schedule pause status."
      },
      "MonitorInferenceLogProblemType": {
        "type": "string",
        "x-enum": [
          "PROBLEM_TYPE_CLASSIFICATION",
          "PROBLEM_TYPE_REGRESSION"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorInfoStatus": {
        "type": "string",
        "x-enum": [
          "MONITOR_STATUS_ACTIVE",
          "MONITOR_STATUS_DELETE_PENDING",
          "MONITOR_STATUS_ERROR",
          "MONITOR_STATUS_FAILED",
          "MONITOR_STATUS_PENDING"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "MonitorMetricType": {
        "type": "string",
        "x-enum": [
          "CUSTOM_METRIC_TYPE_AGGREGATE",
          "CUSTOM_METRIC_TYPE_DERIVED",
          "CUSTOM_METRIC_TYPE_DRIFT"
        ],
        "description": "Can only be one of ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"``, ``\"CUSTOM_METRIC_TYPE_DERIVED\"``, or\n``\"CUSTOM_METRIC_TYPE_DRIFT\"``. The ``\"CUSTOM_METRIC_TYPE_AGGREGATE\"`` and\n``\"CUSTOM_METRIC_TYPE_DERIVED\"`` metrics are computed on a single table, whereas the\n``\"CUSTOM_METRIC_TYPE_DRIFT\"`` compare metrics across baseline and input table, or across the\ntwo consecutive time windows. - CUSTOM_METRIC_TYPE_AGGREGATE: only depend on the existing\ncolumns in your table - CUSTOM_METRIC_TYPE_DERIVED: depend on previously computed aggregate\nmetrics - CUSTOM_METRIC_TYPE_DRIFT: depend on previously computed aggregate or derived metrics"
      },
      "MonitorRefreshInfoState": {
        "type": "string",
        "x-enum": [
          "CANCELED",
          "FAILED",
          "PENDING",
          "RUNNING",
          "SUCCESS",
          "UNKNOWN"
        ],
        "description": "The current state of the refresh."
      },
      "MonitorRefreshInfoTrigger": {
        "type": "string",
        "x-enum": [
          "MANUAL",
          "SCHEDULE",
          "UNKNOWN_TRIGGER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "OnlineTableState": {
        "type": "string",
        "x-enum": [
          "OFFLINE",
          "OFFLINE_FAILED",
          "ONLINE",
          "ONLINE_CONTINUOUS_UPDATE",
          "ONLINE_NO_PENDING_UPDATE",
          "ONLINE_PIPELINE_FAILED",
          "ONLINE_TRIGGERED_UPDATE",
          "ONLINE_UPDATING_PIPELINE_RESOURCES",
          "PROVISIONING",
          "PROVISIONING_INITIAL_SNAPSHOT",
          "PROVISIONING_PIPELINE_RESOURCES"
        ],
        "description": "The state of an online table."
      },
      "OptionSpecOauthStage": {
        "type": "string",
        "x-enum": [
          "BEFORE_ACCESS_TOKEN",
          "BEFORE_AUTHORIZATION_CODE"
        ],
        "description": "During the OAuth flow, specifies which stage the option should be displayed in the UI.\nOAUTH_STAGE_UNSPECIFIED is the default value for options unrelated to the OAuth flow.\nBEFORE_AUTHORIZATION_CODE corresponds to options necessary to initiate the OAuth process.\nBEFORE_ACCESS_TOKEN corresponds to options that are necessary to create a foreign connection,\nbut that should be displayed after the authorization code has already been received."
      },
      "OptionSpecOptionType": {
        "type": "string",
        "x-enum": [
          "OPTION_BIGINT",
          "OPTION_BOOLEAN",
          "OPTION_ENUM",
          "OPTION_MULTILINE_STRING",
          "OPTION_NUMBER",
          "OPTION_SERVICE_CREDENTIAL",
          "OPTION_STRING"
        ],
        "description": "Type of the option, we purposely follow JavaScript types so that the UI can map the options to\nJS types. https://www.w3schools.com/js/js_datatypes.asp Enum is a special case that it's just\nstring with selections."
      },
      "PathOperation": {
        "type": "string",
        "x-enum": [
          "PATH_CREATE_TABLE",
          "PATH_READ",
          "PATH_READ_WRITE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PolicyType": {
        "type": "string",
        "x-enum": [
          "POLICY_TYPE_COLUMN_MASK",
          "POLICY_TYPE_ROW_FILTER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "PrincipalType": {
        "type": "string",
        "x-enum": [
          "GROUP_PRINCIPAL",
          "SERVICE_PRINCIPAL",
          "USER_PRINCIPAL"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "Privilege": {
        "type": "string",
        "x-enum": [
          "ACCESS",
          "ALL_PRIVILEGES",
          "APPLY_TAG",
          "BROWSE",
          "CREATE",
          "CREATE_CATALOG",
          "CREATE_CLEAN_ROOM",
          "CREATE_CONNECTION",
          "CREATE_EXTERNAL_LOCATION",
          "CREATE_EXTERNAL_TABLE",
          "CREATE_EXTERNAL_VOLUME",
          "CREATE_FOREIGN_CATALOG",
          "CREATE_FOREIGN_SECURABLE",
          "CREATE_FUNCTION",
          "CREATE_MANAGED_STORAGE",
          "CREATE_MATERIALIZED_VIEW",
          "CREATE_MODEL",
          "CREATE_PROVIDER",
          "CREATE_RECIPIENT",
          "CREATE_SCHEMA",
          "CREATE_SERVICE_CREDENTIAL",
          "CREATE_SHARE",
          "CREATE_STORAGE_CREDENTIAL",
          "CREATE_TABLE",
          "CREATE_VIEW",
          "CREATE_VOLUME",
          "EXECUTE",
          "EXECUTE_CLEAN_ROOM_TASK",
          "EXTERNAL_USE_SCHEMA",
          "MANAGE",
          "MANAGE_ALLOWLIST",
          "MODIFY",
          "MODIFY_CLEAN_ROOM",
          "READ_FILES",
          "READ_PRIVATE_FILES",
          "READ_VOLUME",
          "REFRESH",
          "SELECT",
          "SET_SHARE_PERMISSION",
          "USAGE",
          "USE_CATALOG",
          "USE_CONNECTION",
          "USE_MARKETPLACE_ASSETS",
          "USE_PROVIDER",
          "USE_RECIPIENT",
          "USE_SCHEMA",
          "USE_SHARE",
          "WRITE_FILES",
          "WRITE_PRIVATE_FILES",
          "WRITE_VOLUME"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ProvisioningInfoState": {
        "type": "string",
        "x-enum": [
          "ACTIVE",
          "DEGRADED",
          "DELETING",
          "FAILED",
          "PROVISIONING",
          "UPDATING"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SecurableKind": {
        "type": "string",
        "x-enum": [
          "TABLE_DB_STORAGE",
          "TABLE_DELTA",
          "TABLE_DELTASHARING",
          "TABLE_DELTASHARING_MUTABLE",
          "TABLE_DELTASHARING_OPEN_DIR_BASED",
          "TABLE_DELTA_EXTERNAL",
          "TABLE_DELTA_ICEBERG_DELTASHARING",
          "TABLE_DELTA_ICEBERG_MANAGED",
          "TABLE_DELTA_UNIFORM_HUDI_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_DELTASHARING",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_HIVE_METASTORE_EXTERNAL",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_HIVE_METASTORE_MANAGED",
          "TABLE_DELTA_UNIFORM_ICEBERG_FOREIGN_SNOWFLAKE",
          "TABLE_EXTERNAL",
          "TABLE_FEATURE_STORE",
          "TABLE_FEATURE_STORE_EXTERNAL",
          "TABLE_FOREIGN_BIGQUERY",
          "TABLE_FOREIGN_DATABRICKS",
          "TABLE_FOREIGN_DELTASHARING",
          "TABLE_FOREIGN_HIVE_METASTORE",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_SHALLOW_CLONE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_SHALLOW_CLONE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_DBFS_VIEW",
          "TABLE_FOREIGN_HIVE_METASTORE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_SHALLOW_CLONE_EXTERNAL",
          "TABLE_FOREIGN_HIVE_METASTORE_SHALLOW_CLONE_MANAGED",
          "TABLE_FOREIGN_HIVE_METASTORE_VIEW",
          "TABLE_FOREIGN_MONGODB",
          "TABLE_FOREIGN_MYSQL",
          "TABLE_FOREIGN_NETSUITE",
          "TABLE_FOREIGN_ORACLE",
          "TABLE_FOREIGN_POSTGRESQL",
          "TABLE_FOREIGN_REDSHIFT",
          "TABLE_FOREIGN_SALESFORCE",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD_FILE_SHARING",
          "TABLE_FOREIGN_SALESFORCE_DATA_CLOUD_FILE_SHARING_VIEW",
          "TABLE_FOREIGN_SNOWFLAKE",
          "TABLE_FOREIGN_SQLDW",
          "TABLE_FOREIGN_SQLSERVER",
          "TABLE_FOREIGN_TERADATA",
          "TABLE_FOREIGN_WORKDAY_RAAS",
          "TABLE_ICEBERG_UNIFORM_MANAGED",
          "TABLE_INTERNAL",
          "TABLE_MANAGED_POSTGRESQL",
          "TABLE_MATERIALIZED_VIEW",
          "TABLE_MATERIALIZED_VIEW_DELTASHARING",
          "TABLE_METRIC_VIEW",
          "TABLE_METRIC_VIEW_DELTASHARING",
          "TABLE_ONLINE_VECTOR_INDEX_DIRECT",
          "TABLE_ONLINE_VECTOR_INDEX_REPLICA",
          "TABLE_ONLINE_VIEW",
          "TABLE_STANDARD",
          "TABLE_STREAMING_LIVE_TABLE",
          "TABLE_STREAMING_LIVE_TABLE_DELTASHARING",
          "TABLE_SYSTEM",
          "TABLE_SYSTEM_DELTASHARING",
          "TABLE_VIEW",
          "TABLE_VIEW_DELTASHARING"
        ],
        "description": "Latest kind: CONNECTION_OKTA_SYSTEM_LOGS_SSWS_TOKEN = 295; Next id: 296"
      },
      "SecurableType": {
        "type": "string",
        "x-enum": [
          "CATALOG",
          "CLEAN_ROOM",
          "CONNECTION",
          "CREDENTIAL",
          "EXTERNAL_LOCATION",
          "EXTERNAL_METADATA",
          "FUNCTION",
          "METASTORE",
          "PIPELINE",
          "PROVIDER",
          "RECIPIENT",
          "SCHEMA",
          "SHARE",
          "STAGING_TABLE",
          "STORAGE_CREDENTIAL",
          "TABLE",
          "VOLUME"
        ],
        "description": "The type of Unity Catalog securable."
      },
      "SpecialDestination": {
        "type": "string",
        "x-enum": [
          "SPECIAL_DESTINATION_CATALOG_OWNER",
          "SPECIAL_DESTINATION_CONNECTION_OWNER",
          "SPECIAL_DESTINATION_CREDENTIAL_OWNER",
          "SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER",
          "SPECIAL_DESTINATION_METASTORE_OWNER"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SseEncryptionDetailsAlgorithm": {
        "type": "string",
        "x-enum": [
          "AWS_SSE_KMS",
          "AWS_SSE_S3"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "SystemType": {
        "type": "string",
        "x-enum": [
          "AMAZON_REDSHIFT",
          "AZURE_SYNAPSE",
          "CONFLUENT",
          "DATABRICKS",
          "GOOGLE_BIGQUERY",
          "KAFKA",
          "LOOKER",
          "MICROSOFT_FABRIC",
          "MICROSOFT_SQL_SERVER",
          "MONGODB",
          "MYSQL",
          "ORACLE",
          "OTHER",
          "POSTGRESQL",
          "POWER_BI",
          "SALESFORCE",
          "SAP",
          "SERVICENOW",
          "SNOWFLAKE",
          "STREAM_NATIVE",
          "TABLEAU",
          "TERADATA",
          "WORKDAY"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "TableOperation": {
        "type": "string",
        "x-enum": [
          "READ",
          "READ_WRITE"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "TableType": {
        "type": "string",
        "x-enum": [
          "EXTERNAL",
          "EXTERNAL_SHALLOW_CLONE",
          "FOREIGN",
          "MANAGED",
          "MANAGED_SHALLOW_CLONE",
          "MATERIALIZED_VIEW",
          "METRIC_VIEW",
          "STREAMING_TABLE",
          "VIEW"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "ValidateCredentialResult": {
        "type": "string",
        "x-enum": [
          "FAIL",
          "PASS",
          "SKIP"
        ],
        "description": "A enum represents the result of the file operation"
      },
      "ValidationResultOperation": {
        "type": "string",
        "x-enum": [
          "DELETE",
          "LIST",
          "PATH_EXISTS",
          "READ",
          "WRITE"
        ],
        "description": "A enum represents the file operation performed on the external location with the storage\ncredential"
      },
      "ValidationResultResult": {
        "type": "string",
        "x-enum": [
          "FAIL",
          "PASS",
          "SKIP"
        ],
        "description": "A enum represents the result of the file operation"
      },
      "VolumeType": {
        "type": "string",
        "x-enum": [
          "EXTERNAL",
          "MANAGED"
        ],
        "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access::\n\n>>> Color.RED\n<Color.RED: 1>\n\n- value lookup:\n\n>>> Color(1)\n<Color.RED: 1>\n\n- name lookup:\n\n>>> Color['RED']\n<Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details."
      },
      "WorkspaceBindingBindingType": {
        "type": "string",
        "x-enum": [
          "BINDING_TYPE_READ_ONLY",
          "BINDING_TYPE_READ_WRITE"
        ],
        "description": "Using `BINDING_TYPE_` prefix here to avoid conflict with `TableOperation` enum in\n`credentials_common.proto`."
      }
    }
  }
}