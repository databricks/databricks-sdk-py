# Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Any, Iterator

{{range .ImportedEntities}}
from .{{.Package.Name}} import {{.PascalName}}{{end}}

# all definitions in this file are in alphabetical order
{{range .Types}}
{{if .Fields -}}@dataclass
class {{.PascalName}}{{if eq "List" .PascalName}}Request{{end}}:{{if .Description}}
    """{{.Comment "    " 100}}"""
    {{end}}{{- range .Fields | alphanumOnly}}
    {{.SnakeName}}: {{template "type" .Entity}}{{end}}
    {{if .HasJsonField -}}
    def as_dict(self) -> dict:
        body = {}
        {{range .Fields | alphanumOnly}}if self.{{.SnakeName -}}: body['{{.Name}}'] = {{template "as_request_type" .}}
        {{end -}}
        return body

    @classmethod
    def from_dict(cls, d: Dict[str, any]) -> '{{.PascalName}}{{if eq "List" .PascalName}}Request{{end}}':
        return cls({{range $i, $f := .Fields | alphanumOnly}}{{if $i}}, {{end}}{{$f.SnakeName}}={{template "from_dict_type" $f}}{{end}})
    {{end}}

{{else if .ArrayValue}}type {{.PascalName}} []{{template "type" .ArrayValue}}
{{else if .MapValue}}{{.PascalName}} = {{template "type-nq" .}}
{{else if .Enum}}class {{.PascalName}}(Enum):
    {{if .Description}}"""{{.Comment "    " 100}}"""{{end}}
    {{range .Enum }}
    {{.Content}}{{if eq .Content "None"}}_{{end}} = '{{.Content}}'{{end}}{{end}}
{{end}}
{{- define "from_dict_type" -}}
	{{- if not .Entity }}None
	{{- else if .Entity.ArrayValue }}{{if .Entity.ArrayValue.IsObject}}[{{.Entity.ArrayValue.PascalName}}.from_dict(v) for v in d['{{.Name}}']] if '{{.Name}}' in d else None{{else}}d.get('{{.Name}}', None){{end}}
	{{- else if or .Entity.IsObject .Entity.IsExternal }}{{.Entity.PascalName}}.from_dict(d['{{.Name}}']) if '{{.Name}}' in d else None
	{{- else if .Entity.Enum }}{{.Entity.PascalName}}(d['{{.Name}}']) if '{{.Name}}' in d else None
	{{- else}}d.get('{{.Name}}', None){{- end -}}
{{- end -}}
{{- define "as_request_type" -}}
	{{- if not .Entity }}None # ERROR: No Type
	{{- else if .Entity.ArrayValue }}[{{if .Entity.ArrayValue.IsObject}}v.as_dict(){{else}}v{{end}} for v in self.{{.SnakeName}}]
	{{- else if .Entity.IsObject }}self.{{.SnakeName}}.as_dict()
	{{- else if .Entity.Enum }}self.{{.SnakeName}}.value
	{{- else}}self.{{.SnakeName}}{{- end -}}
{{- end -}}
{{- define "type" -}}
	{{- if not . }}any # ERROR: No Type
	{{- else if .ArrayValue }}'List[{{template "type-nq" .ArrayValue}}]'
	{{- else if .MapValue }}'Dict[str,{{template "type-nq" .MapValue}}]'
	{{- else if .IsExternal }}'{{.PascalName}}'
	{{- else if .IsObject }}'{{.PascalName}}{{if eq "List" .PascalName}}Request{{end}}'
	{{- else if .Enum }}'{{.PascalName}}'
	{{- else}}{{template "type-nq" .}}{{- end -}}
{{- end -}}
{{- define "type-nq" -}}
	{{- if .IsString}}str
	{{- else if .IsEmpty}}Any
  {{- else if .IsAny}}Any
	{{- else if .IsBool}}bool
	{{- else if .IsInt64}}int
	{{- else if .IsFloat64}}float
	{{- else if .IsInt}}int
	{{- else if .ArrayValue }}List[{{template "type-nq" .ArrayValue}}]
  {{- else if .MapValue }}Dict[str,{{template "type-nq" .MapValue}}]
	{{- else if .IsExternal }}{{.PascalName}}
	{{- else if .IsObject }}{{.PascalName}}{{if eq "List" .PascalName}}Request{{end}}
	{{- else if .Enum }}{{.PascalName}}
	{{- else}}any /* MISSING TYPE */
	{{- end -}}
{{- end -}}

{{range .Services}}
class {{.Name}}API:{{if .Description}}
    """{{.Comment "    " 110}}"""
    {{end}}
    def __init__(self, api_client):
        self._api = api_client
    {{range .Methods}}
    def {{.SnakeName}}{{if .IsNameReserved}}_{{end}}(self{{if .Request}}
      {{range .Request.RequiredFields}}, {{.SnakeName}}: {{template "type-nq" .Entity}}{{end}}
      {{if .Request.NonRequiredFields}}, *
        {{range .Request.NonRequiredFields}}, {{.SnakeName}}: {{template "type-nq" .Entity}} = None{{end}}
      {{- end}}, **kwargs
    {{- end}}){{if .Response}} -> {{template "method-return-type" .}}{{end}}:
        {{if .Description}}"""{{.Comment "        " 110}}"""{{end}}
        {{if .Request -}}request = kwargs.get('request', None)
        if not request: # request is not given through keyed args
          request = {{template "type-nq" .Request}}({{range $i, $f := .Request.Fields}}{{if $i}}, {{end}}{{.SnakeName}}={{.SnakeName}}{{end}})
        {{template "method-serialize" .}}
        {{- end}}
        {{template "method-call" .}}
    {{end -}}
{{- end}}

{{define "method-serialize" -}}
        {{if .Request.HasJsonField}}body = request.as_dict(){{end}}{{if .Request.HasQueryField}}
        query = {}
        {{- range .Request.Fields}}{{if .IsQuery}}
        if {{.SnakeName}}: query['{{.Name}}'] = {{template "method-param-bind" .}}{{end}}{{end}}
        {{end}}
{{- end}}

{{define "method-call" -}}
        {{if .Pagination -}}{{template "method-call-paginated" .}}
        {{- else}}{{template "method-call-default" .}}{{end}}
{{- end}}

{{define "method-call-paginated" -}}
        {{if .Pagination.MultiRequest}}
        {{if .Pagination.NeedsOffsetDedupe -}}
        # deduplicate items that may have been added during iteration
        seen = set()
        {{- end}}{{if .Pagination.Offset}}
        query['{{.Pagination.Offset.Name}}'] = {{if eq .Pagination.Increment 1}}1{{else}}0{{end}}{{end}}
        while True:
          json = {{template "method-do" .}}
          if '{{.Pagination.Results.Name}}' not in json or not json['{{.Pagination.Results.Name}}']:
            return
          for v in json['{{.Pagination.Results.Name}}']:
            {{if .Pagination.NeedsOffsetDedupe -}}
            i = v['{{.Pagination.Entity.IdentifierField.Name}}']
            if i in seen:
              continue
            seen.add(i)
            {{end -}}
            yield {{.Pagination.Entity.PascalName}}.from_dict(v)
          {{if eq .Path "/api/2.0/clusters/events" -}}
          if 'next_page' not in json or not json['next_page']:
            return
          body = json['next_page']
          {{- else if .Pagination.Token -}}
          {{if eq "GET" .Verb}}query{{else}}body{{end}}['{{.Pagination.Token.PollField.Name}}'] = json['{{.Pagination.Token.Bind.Name}}']
          if not json['{{.Pagination.Token.Bind.Name}}']:
            return
          {{- else if eq .Pagination.Increment 1 -}}
          query['{{.Pagination.Offset.Name}}'] += 1
          {{- else -}}
          query['{{.Pagination.Offset.Name}}'] += len(json['{{.Pagination.Results.Name}}'])
          {{- end}}
        {{else}}
        json = {{template "method-do" .}}
        return [{{.Pagination.Entity.PascalName}}.from_dict(v) for v in json{{if .Pagination.Results}}['{{.Pagination.Results.Name}}']{{end}}]
        {{end}}
{{- end}}

{{define "method-call-default" -}}
        {{if .Response}}
        json = {{end}}{{template "method-do" .}}
        {{if .Response -}}
          {{if .Response.ArrayValue -}}
            return [{{.Response.ArrayValue.PascalName}}.from_dict(v) for v in json]
          {{- else -}}
            return {{.Response.PascalName}}.from_dict(json)
          {{- end}}
        {{- end}}
{{- end}}

{{define "method-do" -}}
self._api.do('{{.Verb}}', {{if .PathParts -}}
  f'{{range  .PathParts}}{{.Prefix}}{{if .Field}}{{"{"}}request.{{.Field.SnakeName}}{{"}"}}{{else if .IsAccountId}}{{"{self._api.account_id}"}}{{end}}{{ end }}'
{{- else}}'{{.Path}}'{{end}}{{if .Request}}{{if .Request.HasQueryField}}, query=query{{end}}{{if .Request.HasJsonField}}, body=body{{end}}{{end}})
{{- end}}

{{define "method-return-type" -}}
  {{if .Response.ArrayValue -}}
    Iterator[{{.Response.ArrayValue.PascalName}}]
  {{- else if .Pagination -}}
    Iterator[{{.Pagination.Entity.PascalName}}]
  {{- else -}}
    {{.Response.PascalName}}
  {{- end}}
{{- end}}

{{- define "method-param-bind" -}}
{{- if not .Entity }}None # ERROR: No Type
{{- else if .Entity.ArrayValue }}[{{if .Entity.ArrayValue.IsObject}}v.as_dict(){{else}}v{{end}} for v in request.{{.SnakeName}}]
{{- else if .Entity.IsObject }}request.{{.SnakeName}}.as_dict()
{{- else if .Entity.Enum }}request.{{.SnakeName}}.value
{{- else}}request.{{.SnakeName}}{{- end -}}
{{- end -}}